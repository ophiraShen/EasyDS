[
    {
        "id": "q081001",
        "title": "不属于内部排序的算法",
        "content": "下述排序算法中，不属于内部排序算法的是（）。\nA.插入排序\nB.选择排序\nC.拓扑排序\nD.冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc811"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于\n我们这里所提到的内部排序范畴，也不满足前面排序的定义。"
        },
        "chapter": "08"
    },
    {
        "id": "q081002",
        "title": "排序算法的稳定性定义",
        "content": "排序算法的稳定性是指（）。\nA.经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变\nB.经过排序后，能使关键字相同的元素保持原顺序中的绝对位置不变\nC.排序算法的性能与被排序元素个数关系不大",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc811"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "注意，这里的绝对位置是指若在排序前元素R在位置i，则绝对位置就是i，即排序后R的位\n置不发生变化，显然选项B是不对的。选项C、D与题目要求无关。"
        },
        "chapter": "08"
    },
    {
        "id": "q082001",
        "title": "直接插入排序比较次数",
        "content": "对5个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（）\nA. 8\nB.10\nC.15\nD.25",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "直接插入排序在最坏的情况下要做n（n-1)/2次关键字的比较，当n=5时，关键字的比较次\n数为10。注意不考虑与哨兵的比较。"
        },
        "chapter": "08"
    },
    {
        "id": "q082002",
        "title": "基本有序序列的最优排序算法",
        "content": "在待排序的元素序列基本有序的前提下，效率最高的排序算法是（）。\nA.直接插入排序B.简单选择排序\nC.快速排序\nD.归并排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "序列初始基本有序，因此使用直接插入排序算法的时间复杂度接近O(n)，而使用其他算法的\n时间复杂度均大于O(n)。"
        },
        "chapter": "08"
    },
    {
        "id": "q082003",
        "title": "图书馆书籍排序算法选择",
        "content": "在图书馆中，计算机类书籍区共有12列书架，书架上的书都是按照编号排列好的，其\n第8章排序\n343\n中有些书被读者放错了地方，但通常不超过一个书架。未来将这些书重新放回正确的位\n置，应该采用何种排序算法？（）。\nA.堆排序\nB.直接插入排序\nC．归并排序\nD.简单选择排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "大部分图书都是有序的，因此采用直接插入排序比较合适。\n04.D、A\n待排序表为反序时，直接插入排序需要进行n(n-1)/2次比较（从前往后依次需要比较1,2,\nn-1次）；待排序表为正序时，只需进行n-1次比较。注意本题不考虑与哨兵的比较。"
        },
        "chapter": "08"
    },
    {
        "id": "q082004",
        "title": "直接插入排序的比较次数",
        "content": "对有n个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数\n是（），在最好情况下所需的比较次数是（）。\nA.n-1\nB.n+1\nC.n/2\nD. n(n- 1)/2",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q082005",
        "title": "数据序列排序结果分析",
        "content": "数据序列18,10,13,4,6,7,22,2,3}只能是（）两趟排序后的结果。\nA.简单选择排序B.冒泡排序\nC.直接插入排序D．堆排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插\n入排序经过两趟排序后，前三个元素应该是局部有序的。只可能是插入排序。\n注意\n在排序过程中，每趟都能确定一个元素在其最终位置的有冒泡排序、简单选择排序、堆排序、快速排序，\n其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。\n第8章排\n序\n345"
        },
        "chapter": "08"
    },
    {
        "id": "q082006",
        "title": "直接插入排序比较次数最少",
        "content": "用直接插入排序算法对下列4个表进行（从小到大）排序，比较次数最少的是（）。\nA.94,32,40,90,80,46,21,69\nB.21,32,46,40, 80,69, 90, 94\nC.32,40,21,46,69,94, 90, 80\nD.90,69,80,46,21,32,94,40",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "越接近正序的序列，直接插入排序的比较次数就越少。选项B和C是比较接近正序的，然后\n分别判断两个序列的比较次数，以选项B为例：第一趟，插入32，比较1次；第二趟，插入46，\n比较1次；第三趟，插入40，因为40比46小但比32大，所以比较2次：第四趟，插入80，比较\n1次；第五趟，插入69，比较2次：以此类推，共比较9次。同理求出选项C的比较次数为11次。\n所以选择选项B。"
        },
        "chapter": "08"
    },
    {
        "id": "q082007",
        "title": "算法最终位置问题",
        "content": "在下列算法中，（）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最\n终位置上。\nA.堆排序\nB.冒泡排序\nC.直接插入排序D.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "子序列中的所有元素都不在最终位置上。"
        },
        "chapter": "08"
    },
    {
        "id": "q082008",
        "title": "希尔排序属于",
        "content": "希尔排序属于（\nA.插入排序\nB.交换排序\nC.选择排序\nD.归并排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "希尔排序是对直接插入排序算法改进后提出来的，本质上仍属于插入排序的范畴。"
        },
        "chapter": "08"
    },
    {
        "id": "q082009",
        "title": "希尔排序增量与排序方法",
        "content": "对序列{15,9,7,8,20,-1,4}采用希尔排序，经一趟后序列变为{15,-1,4,8,20,9,7}，则\n该次采用的增量是（）。\nA.1\nB.4\nC.3\nD.2\n10．若序列{15,9,7,8,20,-1,4}经一趟排序后变成{9,15,7,8,20,-1,4}，则采用的是（）\n方法。\nA.选择排序\nB.快速排序\nC.直接插入排序\nD.冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "希尔排序将序列分成若干组，记录只在组内进行交换。由观察可知，经过一趟后9和-1交换，\n7和4交换，可知增量为4。"
        },
        "chapter": "08"
    },
    {
        "id": "q082011",
        "title": "希尔排序增量4结果",
        "content": "对序列{98,36,-9,0,47,23,1,8,10,7}采用希尔排序，下列序列（）是增量为4的一趟\n排序结果。\nA.{10,7,-9,0,47,23,1,8,98,36}\nB.{-9,0,36,98,1,8,23,47,7,10}\nC.{36,98,-9,0,23,47,1,8,7,10}\nD.以上都不对",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "增量为4意味着所有相距为4的记录构成一组，然后在组内进行直接插入排序，经观察，只\n有选项A满足要求。"
        },
        "chapter": "08"
    },
    {
        "id": "q082012",
        "title": "希尔排序比较次数",
        "content": "对序列{E,A,S,Y,Q,U,E,S,T,I,O,N}按照字典顺序排序，采用增量d=6,3,1的希尔排\n序算法。则前两趟排序后，关键字的总比较次数为（）。\nA.15\nB.17\nC. 16\nD.18",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "第一趟：EE为一组，比较；AS为一组，比较；ST为一组，比较；YI为一组，比较后交换；QO\n为一组，比较后交换；UN为一组，比较后交换，结果为EASIONESTYQU。第二趟：EIEY为一组，\n用直接插入排序需要依次比较I和E、E和I、E和E、Y和I；AOSQ为一组，依次比较O和A、S\n和O、Q和S、Q和O：SNTU为一组，依次比较N和S、T和S、U和T。第一趟比较次数为6，第\n二趟比较次数为11，总比较次数为17。"
        },
        "chapter": "08"
    },
    {
        "id": "q082013",
        "title": "希尔排序两趟结果",
        "content": "已知输入序列{13,24,7,1,8,9,11,56,34,51,2,77,5}，增量序列d=5,3，1，采用希尔排\n序算法进行排序，则两趟排序后的结果为（）。\nA.1,7,8,9,13,24,11,34,51,2,5,56,77\nB.1,7,5,2,8,9,24,11,34,51,13,77,56\nC. 2,11,5,1,8,9,24,7,34,51,13,77,56\nD.2,5,11,1,8,9,7,24,34,13,51,77,56",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "第一趟增量d=5，第一趟排序后，结果为2,11,5,1,8,9,24,7,34,51,13,77,56。第二趟增\n量d=3，第二趟排序后，结果为1,7,5,2,8,9,24,11,34,51,13,77,56。"
        },
        "chapter": "08"
    },
    {
        "id": "q082014",
        "title": "折半插入排序时间复杂度",
        "content": "折半插入排序算法的时间复杂度为（）。\nA. O(n)\nB. O(nlog2n)\nC. 0(m)\nD. 0(n)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发\n生变化，时间复杂度仍为O（n²)。"
        },
        "chapter": "08"
    },
    {
        "id": "q082015",
        "title": "排序算法特性比较",
        "content": "有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（）算法不\n会出现此种情况。\nA.希尔排序\nB.堆排序\nC.冒泡排序\nD.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "因为希尔排序是基于插入排序算法提出的，所以它不一定在每趟排序过程后将某一元素放置\n到最终位置上。"
        },
        "chapter": "08"
    },
    {
        "id": "q082016",
        "title": "不稳定排序算法",
        "content": "以下排序算法中，不稳定的是（）。",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc821",
            "kc822",
            "kc823"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "希尔排序是一种复杂的插入排序算法，它是一种不稳定的排序算法。"
        },
        "chapter": "08"
    },
    {
        "id": "q083002",
        "title": "冒泡排序比较次数",
        "content": "若用冒泡排序算法对序列{10,14,26,29,41,52}从大到小排序，则需进行（）次比较。\nA.3\nB.10\nC.15\nD.25\n第8章排\n序\n351",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "冒泡排序始终在调整“逆序”，因此交换次数为排列中逆序的个数。对逆序序列进行冒泡排\n序，每个元素向后调整时都需要进行比较，因此共需要比较5+4+3+2+1=15次。"
        },
        "chapter": "08"
    },
    {
        "id": "q083003",
        "title": "排序算法识别",
        "content": "用某种排序算法对线性表{25,84，21,47,15,27,68,35,20进行排序时，元素序列的变化\n情况如下：\n1)25,84,21, 47, 15,27,68,35,20\n2） 20, 15,21,25,47,27,68,35, 84\n3）15,20,21,25,35,27,47,68,84\n4)15,20,21,25,27,35,47, 68, 84\n则所采用的排序算法是（）。\nA.选择排序\nB.插入排序\nC.二路归并排序D.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "选择排序在每趟结束后可以确定一个元素的最终位置，不对。插入排序，第i趟后前i+1个\n元素应该是有序的，不对。第二趟{20，15}和{21，25}是反序的，因此不是归并排序。快速排序每\n趟都将基准元素放在其最终位置，然后以它为基准将序列划分为两个子序列。观察题中的排序过\n程，可知是快速排序。"
        },
        "chapter": "08"
    },
    {
        "id": "q083004",
        "title": "快速排序一次划分结果",
        "content": "一组记录的关键码为（46，79，56，38，40，84），则利用快速排序算法，以第一个记录为基准，\n从小到大得到的一次划分结果为（）。\nA.(38,40,46,56,79,84)\nB.(40,38,46,79,56,84)\nC.(40, 38,46,56, 79,84)\nD.(40,38,46, 84,56,79)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "以46为基准元素，首先从后往前扫描比46小的元素，并与之进行交换，而后从前往后扫描\n比46大的元素并将46与该元素交换，得到（40，46，56，38，79，84）。此后，继续重复从后往前扫描\n与从前往后扫描的操作，直到46处于最终位置。"
        },
        "chapter": "08"
    },
    {
        "id": "q083005",
        "title": "快速排序最不利情况",
        "content": "快速排序算法在（）情况下最不利于发挥其长处。\nA.要排序的数据量太大\nB.要排序的数据中含有多个相同值\nC.要排序的数据个数为奇数\nD.要排序的数据已基本有序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "当待排序数据为基本有序时，每次选取第n个元素为基准，会导致划分区间分配不均匀，不\n利于发挥快速排序算法的优势。相反，当待排序数据分布较为随机时，基准元素能将序列划分为\n两个长度大致相等的序列，这时才能发挥快速排序的优势。"
        },
        "chapter": "08"
    },
    {
        "id": "q083006",
        "title": "最佳内部排序算法",
        "content": "就平均性能而言，目前最好的内部排序算法是（）。\nA.冒泡排序\nB.直接插入排序\nC.希尔排序\nD.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "这里问的是平均性能，选项A、B的平均性能都会达到O（n²)，而希尔排序虽然大大降低了\n直接插入排序的时间复杂度，但其平均性能不如快速排序。另外，虽然众多排序算法的平均时间\n复杂度也是O（nmlog2n)，但快速排序算法的常数因子是最小的。"
        },
        "chapter": "08"
    },
    {
        "id": "q083007",
        "title": "排序算法两趟结果",
        "content": "数据序列F={2,1,4，9,8，10,6,20}只能是下列排序算法中的（）两趟排序后的结果\nA.快速排序\nB.冒泡排序\nC.选择排序\nD.插入排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "若为插入排序，则前三个元素应该是有序的，显然不对。而冒泡排序和选择排序经过两趟排\n序后应该有两个元素处于最终位置（最左/右端），无论是按从小到大还是从大到小排序，数据序\n列中都没有两个满足这样的条件的元素，因此只可能选择选项A。\n【另解】先写出排好序的序列，并和题中的序列做对比。\n题中序列：2149810620\n已排好序序列：1246891020\n在已排好序的序列中，与题中序列相同的元素有4、8和20，最左和最右两个元素与题中的\n序列不同，所以不可能是冒泡排序、选择排序或插入排序。"
        },
        "chapter": "08"
    },
    {
        "id": "q083008",
        "title": "冒泡排序交换趟数",
        "content": "对元素序列！8，9,10,4，5，6,20，1,21采用冒泡排序（从后往前次序进行，要求升序），需\n要进行元素交换的趟数至少是（）（不考虑无元素交换的最后一趟）\nA.3\nB.4\nC.5\nD.8",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "从后往前冒泡的过程为，第一趟{1,8,9,10,4,5,6,20,2}，第二趟{1,2,8,9,10,4,5,6,20}，\n第三趟{1,2,4,8,9,10,5,6,20}，第四趟{1,2,4,5,8,9,10,6,20}，第五趟{1,2,4,5,6,8,9,10,20}\n经过第五趟冒泡后，序列已经全局有序，因此选择选项C。实际每趟冒泡发生交换后可以判断是\n否会产生新的逆序对，若不会产生，则本趟冒泡之后序列全局有序，所以最少5趟即可。\n354\n2026年数据结构考研复习指导"
        },
        "chapter": "08"
    },
    {
        "id": "q083009",
        "title": "双向冒泡排序趟数",
        "content": "双向冒泡排序是指对一个序列在正反两个方向交替进行扫描，第一趟把最大值放在序列\n的最右端，第二趟把最小值放在序列的最左端，之后在缩小的范围内进行同样的扫描，\n放在次右端、次左端，直至序列有序。对数组{4，7，8，3，5，6，10，9,1,21进行双向冒泡排\n序，则排序趟数是（）。（第一趟从左往右开始，从左往右或从右往左都称为一趟。）\nA.7\nB.6\nC.8\nD.9",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "第一趟从左往右的排序结果为4,7,3,5,6,8,9.1,2,10；第二趟从右往左的排序结果为1,4,7,\n结果为1,2,4,3,5,6,7,8,9,10；第五趟从左往右的排序结果为1,2,3,4,5，6,7,8,9,10，此时序\n列已有序，但仍需进行一趟无交换的排序才能确定序列已有序，因此共需6趟排序。\n10.A、D\n当每趟的枢轴值都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或\n逆序时，速度最慢。选项D中的序列已按关键字排好序，因此它是最慢的，而选项A中第一趟枢\n等分，所以该序列是快速排序最优的情况，速度最快。针对其他选项，可以进行类似的分析。"
        },
        "chapter": "08"
    },
    {
        "id": "q083010",
        "title": "快速排序最优和最差情形",
        "content": "对下列关键字序列用快速排序进行排序时，每次选取的基准元素都为待处理序列的第一\n个元素，速度最快的情形是（），速度最慢的情形是（）。\nA.{21,25,5,17,9,23,30}\nB.{25,23,30,17,21,5,9}\nC.{21,9,17,30,25,23,5}\nD.{5,9,17,21,23,25,30}",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q083011",
        "title": "快速排序移动次数比较",
        "content": "对下列4个序列，以第一个关键字为基准用快速排序算法进行排序，在第一趟过程中移\n动记录次数最多的是（）\nA.92,96,88,42,30,35,110,100\nB.92,96,100,110,42,35,30,88\nC.100,96,92,35,30,110,88,42\nD.42,30,35,92,100,96,88,110",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "对各序列分别执行一趟快速排序，可做如下分析（以选项A为例）：枢轴值为92，因此35\n单元，即第五个位置，所以选项A中序列移动的次数为4。同样，可以分析出选项B中序列的移\n动次数为8，选项C中序列的移动次数为4，选项D中序列的移动次数为2。"
        },
        "chapter": "08"
    },
    {
        "id": "q083012",
        "title": "快速排序第一趟结果分析",
        "content": "下列序列中，（）可能是执行第一趟快速排序后所得到的序列（按从大到小排序和从小\n到大排序来分别讨论）。\n1.{68, 11, 18,69,23,93,73}\nI1.68,11,69,23,18,93,73}\nIII.{93,73,68,11,69,23,18}\nIV.{68,11,69,23,18,73,93}\nA. I、IV\nB.II、III\nC. III、IV\nD.只有IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "显然，若按从小到大排序，则最终有序的序列是{11，18,23，68，69，73，93}；若按从大到小排\n序，则最终有序的序列是{93，73，69,68,23，18，11}。对比可知选项1、Ⅱ1中没有处于最终位置的元\n素，所以选项1、11都不可能。选项111中73和93处于从大到小排序后的最终位置，而且73将\n序列分割成大于73和小于73的两部分，所以选项1Ⅱ1是有可能的。选项IV中73和93处于从小\n到大排列后的最终位置，73也将序列分割成大于73和小于73的两部分。\n13.B、C\n快速排序过程构成一个递归树，递归深度即递归树的高度。枢轴值每次都将子表等分时，递\n归树的高为log2n：枢轴值每次都是子表的最大值或最小值时，递归树退化为单链表，树高为n。"
        },
        "chapter": "08"
    },
    {
        "id": "q083013",
        "title": "快速排序递归深度",
        "content": "对n个关键字进行快速排序，最大递归深度为（），最小递归深度为（）。\n352\n2026年数据结构考研复习指导\nA. 1\nB.n\nC. log2n\nD. nlog2n",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q083014",
        "title": "快速排序最好情况比较次数",
        "content": "对8个元素的序列进行快速排序，在最好情况下的关键字比较次数是（）。\nA. 7\nB.8\nC.12\nD.13",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "快速排序的最好情况是每次划分将待排序列划分为等长的两部分。因此，第一趟将第1个元\n素与后面的7个元素进行比较，将原序列划分为长度为3和4的两个子表，比较7次：第二趟对\n两个子表进行划分，将长度为3的子表划分为长度为1的两个子表（不用继续划分），比较2次，\n将长度为4的子表划分为长度为1和2的两个子表，比较3次；第三趟将长度为2的子表划分为\n长度为1的子表，比较1次。至此，排序结束，共进行的比较次数是7+2+3+1=13。"
        },
        "chapter": "08"
    },
    {
        "id": "q083015",
        "title": "快速排序递归次数分析",
        "content": "【2010统考真题】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，\n正确的是（）。\nA.递归次数与初始数据的排列次序无关\nB.每次划分后，先处理较长的分区可以减少递归次数\nC.每次划分后，先处理较短的分区可以减少递归次数\nD.递归次数与每次划分后得到的分区的处理顺序无关",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "快速排序的递归次数与元素的初始排列有关。若每次划分后分区比较平衡，则递归次数少；\n若划分后分区不平衡，则递归次数多。递归次数与分区处理顺序无关。"
        },
        "chapter": "08"
    },
    {
        "id": "q083016",
        "title": "快速排序的存储方式",
        "content": "【2011统考真题】为实现快速排序算法，待排序序列宜采用的存储方式是（）。\nA.顺序存储\nB.散列存储\nC.链式存储\nD.索引存储",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "对于绝大部分内部排序而言，只适用于顺序存储结构。快速排序在排序的过程中，既要从后\n往前查找，也要从前往后查找，因此宜采用顺序存储。"
        },
        "chapter": "08"
    },
    {
        "id": "q083017",
        "title": "快速排序第二趟结果分析",
        "content": "【2014统考真题】下列选项中，不可能是快速排序第二趟排序结果的是（）。\nA.2,3,5,4,6,7,9\nB.2,7,5,6,4,3,9\nC.3,2,5,4,7,6,9\nD.4,2,3,5,7,6,9",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "对n个元素进行第一趟快速排序后，会确定一个基准元素，根据这个基准元素在数组中的位\n置，有两种情况：①基准元素在数组的首端或尾端，接下来对剩下的n-1个元素构成的子序列进\n行第二趟快速排序，再确定一个基准元素。这样，在两趟排序后就至少能确定两个元素的最终位\n第8章排\n序\n355\n置，其中至少有一个元素是在数组的首端或尾端。②基准元素不在数组的首端或尾端，第二趟快\n速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这\n样，两趟排序后就至少能确定三个元素的最终位置。基于上述结论，观察题中的四个选项，选项\nA的2，3,6，7,9符合第一种或第二种情况；选项B中2，9符合第一种情况；选项D中5，9符合第\n一种情况；最后看选项C，只有9处于最终位置，因此不可能是快速排序第二趟的结果。"
        },
        "chapter": "08"
    },
    {
        "id": "q083018",
        "title": "快速排序第二趟结果判断",
        "content": "【2019统考真题】排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟。\n下列序列中，不可能是快速排序第二趟结果的是（）。\nA.5,2,16,12,28,60,32,72\nB.2,16,5,28,12,60,32,72\nC.2,12,16,5,28,32,72,60\nD.5,2,12,28,16,32,72,60",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "基于上题中分析得出的结论，观察题中的四个选项，选项A的28，72符合第一种情况；选项\nB的2，72符合第一种情况；选项C的2，28，32符合第一种或第二种情况；最后看选项D，只有\n12和32处于最终位置，既不符合第一种情况，又不符合第二种情况。"
        },
        "chapter": "08"
    },
    {
        "id": "q083019",
        "title": "快速排序枢轴选择与划分分析",
        "content": "【2023统考真题】使用快速排序算法对数据进行升序排序，若经过一次划分后得到的数\n据序列是68,11,70,23,80,77,48,81,93,88，则该次划分的枢轴是（）。\nA. 11\nB.70\nC. 80\nD.81\n趟排序将M中除枢轴外的n-1个元素划分为均不为空的P和Q两块，则下列叙述中，\n正确的是（）。\nA.P与Q块间有序\nB.P与Q均块内有序\nC.P和Q的元素个数大致相等\nD.P中和Q中均不存在相等的元素",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc831",
            "kc832"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "第一趟划分后得到的序列中只有一个枢轴，因此可将当前序列和最终排好序的序列进行比较，\n如下表所示。枢轴会出现在两个序列的相同位置，可以看出枢轴只可能是77、81，选项只有81。\n在当前序列中，77左边有比它大的元素80，因此77不是枢轴：而81左边都是比它小的元素，\n右边都是比它大的元素，因此81是枢轴。\n当前序列\n68\n11\n70\n23\n80\n77\n48\n81\n93\n88\n最终序列\n11\n23\n48\n68\n70\n77\n80\n81\n88\n93"
        },
        "chapter": "08"
    },
    {
        "id": "q084001",
        "title": "选择排序算法",
        "content": "在以下排序算法中，每次从未排序的记录中选取最小关键字的记录，加入已排序记录的\n末尾，该排序算法是（)。\nA.简单选择排序B.冒泡排序\nC.堆排序\nD.直接插入排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": ""
        },
        "chapter": "08"
    },
    {
        "id": "q084002",
        "title": "简单选择排序的比较与移动次数",
        "content": "简单选择排序算法的比较次数和移动次数分别为（）。\nA. O(n), O(log2n)\nB. O(log2n), O(n²)\nC. 0(n²), 0(n)\nD. O(nlogzn), O(n)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "注意，读者应熟练掌握各种排序算法的思想、过程和特点。"
        },
        "chapter": "08"
    },
    {
        "id": "q084003",
        "title": "选择最快排序方法",
        "content": "若只想得到100000个元素组成的序列中第10个最小元素之前的部分排序的序列，用（）\n方法最快。\nA.冒泡排序\nB.快速排序\nC.归并排序\nD.堆排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "采用堆排序时，读入前10个元素，建立含10个元素的大根堆，而后依次扫描剩余元素，若\n大于堆顶，则舍弃，否则用该元素取代堆顶并重新调整堆，当元素全部扫描完毕，堆中保存的即\n是最小的10个元素。冒泡排序需要从后往前执行10趟冒泡才能得到10个最小的元素。两者的\n时间复杂度都和数据规模n线性相关，但显然堆排序的常系数更小。而快速排序、归并排序的每\n一趟都不能保证得到当前序列的最小值，也无法达到线性时间复杂度。"
        },
        "chapter": "08"
    },
    {
        "id": "q084004",
        "title": "判断堆的正确选项",
        "content": "下列（）是一个堆。\nA. 19, 75, 34, 26, 97, 56\nB.97,26,34,75,19,56\nC.19,56,26,97,34,75\nD.19, 34,26, 97, 56,75",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "可将每个选项中的序列表示成完全二叉树，再看父结点与子结点的关系是否全部满足堆的定\n义。例如，选项A中序列对应的完全二叉树如下图所示。显然，最小元素19在根结点，因此可\n能是小根堆，但75与26的关系却不满足小根堆的定义，所以选项A中的序列不是一个堆。其他\n选项采用类似的过程分析。"
        },
        "chapter": "08"
    },
    {
        "id": "q084005",
        "title": "小根堆中关键字最大元素的位置",
        "content": "在含有n个元素的小根堆中（下标从1开始），关键字最大的元素可能存储在（）位置。\nA.n/2\nB.n/2+2\nC.1\nD. n/2-1",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "在小根堆中，关键字最大的元素一定存储在该堆所对应的完全二叉树的叶结点中（位于最底\n层或次底层）。又因为二叉树中的最后一个非叶结点存储在Ln/2中，所以关键字最大的元素的存\n储范围为Ln/2」+1～n。注意，读者可类比在大根堆中求关键字最小的元素的存储范围。\n06. C、C\n在向有n个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等\n于树的高度减1，因为树的高度为Llog2n]+1，所以堆的向上调整算法的比较次数最多等于[log2n]。\n此处需要注意，调整堆和建初始堆的时间复杂度是不一样的，读者可以仔细分析两个算法的具体\n执行过程。\n07.A、D\n建堆过程中，向下调整的时间与树高h有关，为O(h)。每次向下调整时，大部分结点的高度\n都较小。因此，可以证明在元素个数为n的序列上建堆，其时间复杂度为O(n)。无论是在最好情\n况下还是在最坏情况下，堆排序的时间复杂度均为O(nlog2n)。"
        },
        "chapter": "08"
    },
    {
        "id": "q084006",
        "title": "堆操作时间复杂度",
        "content": "向具有n个结点的堆中插入一个新元素的时间复杂度为（），删除一个元素的时间复杂\n度为（）。\nA. 0(1)\nB. O(n)\nC. O(log2n)\nD. O(nlog2n)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q084007",
        "title": "堆排序时间复杂度",
        "content": "构建n个记录的初始堆，其时间复杂度为（）；对n个记录进行堆排序，最坏情况下其\n时间复杂度为（）。\nA. O(n)\nB.O(n²)\nC. O(log2n)\nD. O(nlog2n)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q084008",
        "title": "排序算法比较次数与初始状态无关",
        "content": "下列4种排序算法中，排序过程中的比较次数与序列初始状态无关的是（）。\nA.简单选择排序B.直接插入排序\nC.快速排序\nD.冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": ""
        },
        "chapter": "08"
    },
    {
        "id": "q084009",
        "title": "二叉排序树与小根堆比较",
        "content": "对由相同的n个整数构成的二叉排序树和小根堆，下列说法中不正确的是（）。\nA.二叉排序树的高度大于或等于小根堆的高度\nB.对二叉排序树进行中序遍历可以得到从小到大的序列\nC.从小根堆的根结点到任意叶结点的路径构成从小到大的序列\n362\n2026年数据结构考研复习指导\nD.对小根堆进行层序遍历可以得到从小到大的序列",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "堆是顺序存储的完全二叉树，因此其高度小于或等于结点数相同的二叉排序树，选项A正确。\n选项B显然正确。根据小根堆的定义，其根结点到任意叶结点的路径构成从小到大的序列，选项\nC正确。堆的各层结点之间没有大小要求，因此层序遍历不能保证得到有序序列，选项D错误。\n第8章排\n序\n365"
        },
        "chapter": "08"
    },
    {
        "id": "q084010",
        "title": "堆排序初始小根堆",
        "content": "有一组数据（15，9，7，8,20，-1,7,4)，用堆排序的筛选方法建立的初始小根堆为（）。\nA.-1,4,8,9,20,7,15,7\nB.-1,7,15,7,4,8,20,9\nC.-1,4,7,8,20,15,7,9\nD.A、B、C均不对",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "从Ln/2」～1依次筛选堆的过程如下图所示，显然选择选项C。\n筛选结点8\n筛选结点7\n筛选结点9\n筛选结点15"
        },
        "chapter": "08"
    },
    {
        "id": "q084011",
        "title": "堆排序后剩余堆",
        "content": "对关键字序列{23，17，72，60,25，8,68，71,52}进行堆排序，输出两个最小关键字后的剩\n余堆是（）。\nA.{23,72,60,25,68,71,52}\nB.{23,25,52,60,71,72,68}\nC.{71,25,23,52,60,72,68}\nD.{23,25,68,52,60,72,71}",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "筛选法初始建堆为{8,17,23,52,25,72,68,71,60}，输出8后重建的堆为{17,25,23,52,60,72，\n68,71}，输出17后重建的堆为{23,25,68,52,60,72,71}。"
        },
        "chapter": "08"
    },
    {
        "id": "q084012",
        "title": "堆排序大根堆交换次数",
        "content": "堆排序分为两个阶段：第一阶段将给定的序列构造成一个初始堆，第二阶段逐次输出堆\n顶元素，并调整使其保持堆的性质。设有给定序列{48，62，35，77，55，14，35，98}，若在\n堆排序的第一阶段将该序列构造成一个大根堆，则交换元素的次数为（）。\nA.5\nB.6\nC.7\nD.8",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "初始序列是一棵顺序存储的完全二叉树，然后根据大根堆的要求，按照从下到上、从右到左的\n顺序进行调整。98和77比较，98和77交换（交换1次）：14和35比较，35和35比较，不交换；\n98和55比较，98和62比较，98和62交换（交换1次）：62和77比较，77和62交换（交换1次）；\n98和35比较，98和48比较，98和48交换（交换1次）；77和55比较，77和48比较，77和48交\n换（交换1次）：48和62比较，62和48交换（交换1次），共交换6次。"
        },
        "chapter": "08"
    },
    {
        "id": "q084013",
        "title": "大根堆删除堆顶元素比较次数",
        "content": "已知大根堆{62,34，53，12,8,46,22}，删除堆顶元素后需要重新调整堆，则在此过程中\n关键字的比较次数为（）。\nA.2\nB.3\nC. 4\nD. 5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "删除堆顶62后，将堆尾22放入堆顶，然后自上而下调整。首先34与53比较（第一次比较），\n较大者53与根22比较（第二次比较），53被换至堆顶；22只有一个孩子，直接与其左孩子46\n比较（第3次比较），22与46交换，至此大根堆调整结束，具体过程如下图所示。\n53"
        },
        "chapter": "08"
    },
    {
        "id": "q084014",
        "title": "根到叶路径有序的数据结构",
        "content": "从根结点到任意叶结点的路径都是有序的数据结构是（）。\nA.红黑树\nB.二叉查找树\nC.哈夫曼树\nD.堆\n调整好后得到的小根堆是（）。\nA.3,5,12,8,28,20,15,22,19\nB.3,5,12,19,20,15,22,8,28\nC.3,8,12,5,20,15,22,28,19\nD.3,12,5,8,28,20,15,22,19",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "红黑树和二叉查找树的中序序列是有序序列，从根结点到任意叶结点的路径不能保证是有序\n的。哈夫曼树是根据权值按一定规则构造的树，和关键字次序无关。若是小根堆，则从根结点到\n任意叶结点的路径是升序序列；若是大根堆，则从根结点到叶结点的路径是降序序列。"
        },
        "chapter": "08"
    },
    {
        "id": "q084016",
        "title": "大根堆调整比较次数",
        "content": "【2011统考真题】已知序列{25，13，10，12，91是大根堆，在序列尾部插入新元素18，再\n将其调整为大根堆，调整过程中元素之间进行的比较次数是（）。\nA. 1\nB.2\nC.4\nD.5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "首先18与10比较，交换；18与25比较，不交换。共比较2次，调整过程如下图所示。\n插入结点18\n筛选结点10\n筛选结点25"
        },
        "chapter": "08"
    },
    {
        "id": "q084017",
        "title": "小根堆删除关键字比较次数",
        "content": "【2015统考真题】已知小根堆为8,15，10,21,34，16，12，删除关键字8之后需重建堆，\n在此过程中，关键字之间的比较次数是（）。\nA.1\nB.2\nC.3\nD.4",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "删除8后，将12移动到堆顶，第一次是15和10比较，第二次是10和12比较并交换，第\n三次还需比较12和16，所以比较次数为3。"
        },
        "chapter": "08"
    },
    {
        "id": "q084018",
        "title": "大根堆序列变化过程",
        "content": "【2018统考真题】在将序列（6,1,5,9,8,4，7)建成大根堆时，正确的序列变化过程是（）。\nA.6,1,7,9,8,4,5→6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6,4,5\nB.6,9,5,1,8,4,7→6,9,7,1,8,4,5→9,6,7,1,8,4,5→9,8,7,1,6,4,5\nC.6,9,5,1,8,4,7→9,6,5,1,8,4,7→9,6,7,1,8,4,5→9,8,7,1,6,4,5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "要熟练掌握建堆和调整堆的方法，从序列末尾开始向前遍历，变换过程如下图所示。\n与7比较\n9与8比较\n7和5互换\n9和1互换\n9与7比车\n6向下\n9和6互换\n和8互换"
        },
        "chapter": "08"
    },
    {
        "id": "q084019",
        "title": "大根堆性质与存储方式",
        "content": "【2020统考真题】下列关于大根堆（至少含2个元素）的叙述中，正确的是（）。\nI.可以将堆视为一棵完全二叉树\nI1.可以采用顺序存储方式保存堆\nIIl.可以将堆视为一棵二叉排序树\nIV.堆中的次大值一定在根的下一层\nA.仅I、II\nB.仅II、III\nC.仅I、II和IVD.I、III和IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "简单概念题。堆是一棵完全树，采用一维数组存储，选项I正确，选项ⅡI正确。大根堆只要\n求根结点值大于左右孩子值，并不要求左右孩子值有序，选项IⅡI错误。堆的定义是递归的，所\n以其左右子树也是大根堆，所以堆的次大值一定是其左孩子或右孩子，选项IV正确。"
        },
        "chapter": "08"
    },
    {
        "id": "q084020",
        "title": "大根堆插入关键字",
        "content": "【2021统考真题】将关键字6,9,1,5.8.4,7依次插入初始为空的大根堆H，得到的H是（）。\nA.9,8,7,6,5,4,1\nB.9,8,7,5,6,1,4\nC. 9,8,7,5,6,4,1\nD.9,6,7,5,8,4,1",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "要熟练掌握调整堆的方法，建堆的过程如下图所示，所以答案选择选项B。\n第8章\n367\n周整\n调整\n周整\n周整\n（5（①\n（（4\n注意，给定序列依次插入空堆的结果与给定序列直接调整成堆的结果是不同的，最终得到的\n堆的形式也不同。若对序列6.9.1.5.8.4.7直接调整成堆，则会误选选项C。"
        },
        "chapter": "08"
    },
    {
        "id": "q084021",
        "title": "大根堆删除操作后新堆",
        "content": "【2024统考真题】已知关键字序列28,22,20，19,8,12，15，5是大根堆（最大堆），对该堆\n第8章排\n序\n363\n进行两次删除操作后，得到的新堆是（）。\nA.20,19,15,12,8,5\nB.20,19,15,5,8,12\nC.20,19,12,15,8,5\nD.20,19,8,12,15,5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc841",
            "kc842"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "该序列已调整成大根堆，接下来进行第一次删除操作：删除28后，将5放入堆顶：然后自上而\n下调整。22和20比较，较大者22与5比较，交换：19和8比较，较大者19与5比较，交换。\n5\n22\n19）\n（12）（15\n接下来进行第二次删除操作：删除22后，将15放入堆顶；然后自上而下调整。19和20比\n较，较大者20与15比较，交换；15直接与其仅有的左孩子12比较，不交换。\n15\n20\n5\n(12\n因此，进行两次删除操作后，得到的新堆是20，19，15，5，8,12。"
        },
        "chapter": "08"
    },
    {
        "id": "q085001",
        "title": "排序算法特性比较",
        "content": "以下排序算法中，（）在一趟结束后不一定能选出一个元素放在其最终位置上。\nA.简单选择排序B.冒泡排序\nC.归并排序\nD.堆排序\n02．以下排序算法中，（）不需要进行关键字的比较。\nA.快速排序\nB.归并排序\nC.基数排序\nD.堆排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "我们知道插入排序不能保证在一趟排序结束后一定有元素放在最终位置上。事实上，归并排\n序也不能保证。例如，序列{6,5，7,8,2，1,4,3}进行一趟二路归并排序（从小到大）后为{5，6,7，8\n1,2,3，4，显然它们都未被放在最终位置上。"
        },
        "chapter": "08"
    },
    {
        "id": "q085003",
        "title": "排序算法的空间复杂度分析",
        "content": "在下列排序算法中，平均情况下空间复杂度为O(n)的是（），最坏情况下空间复杂度为\nO(n)的是（）。\nI.希尔排序\nII.堆排序\nII.冒泡排序\nIV．归并排序\nV.快速排序\nVI．基数排序\nA. I、IV、 VI\nB. II、V\nC. IV、 v\nD.IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q085004",
        "title": "排序算法比较次数与初始状态无关",
        "content": "下列排序算法中，\n排序过程中比较次数的数量级与序列初始状态无关的是（）。\nA.归并排序\nB.插入排序\nC.快速排序\nD.冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "前面已讲过选择排序的比较次数与序列初始状态无关，归并排序的比较次数的数量级也与序\n列的初始状态无关。读者应能从算法的原理方面来考虑为什么和初始状态无关。"
        },
        "chapter": "08"
    },
    {
        "id": "q085005",
        "title": "二路归并排序归并趟数数量级",
        "content": "二路归并排序中，归并趟数的数量级是（）。\nA. O(n)\nB. O(log2n)\nC. O(nlog2n)\nD. 0(n²)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "N个元素进行k路归并排序的趟数m满足k\"=N，即m=|logkN，本题中为|log2n"
        },
        "chapter": "08"
    },
    {
        "id": "q085006",
        "title": "三趟多路归并排序的最小归并路数",
        "content": "若对27个元素只进行三趟多路归并排序，则选取的归并路数最少为（）。\nA.2\nB.3\nC. 4\nD.5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "N个元素进行k路归并排序的趟数m满足k\"=N，这里要求的是k，代入可得k=3。\n07.A、B\n注意，当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比\n是最多的，为2N-1次。\n建议读者对此举一反三：若将本题中的两个有序表的长度分别设为M和N，则最多（或最少）\n的比较次数是多少？时间复杂度又是多少？"
        },
        "chapter": "08"
    },
    {
        "id": "q085007",
        "title": "有序表合并比较次数",
        "content": "将两个各有N个元素的有序表合并成一个有序表，最少的比较次数是（），最多的比较\n次数是（）。\nA. N\nB.2N-1\nC.2N\nD. N-1",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q085008",
        "title": "归并排序比较次数",
        "content": "用归并排序算法对序列！1,2，6,4，5，3，8,7进行排序，共需要进行（）次比较。\nA.12\nB.13\nC.14\nD.15",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "第一趟归并后{1,2}，{4,6}，{3,5},{7,8}，共比较4次；第二趟归并后{1,2,4,6}，{3,5,7,8}，\n共比较4次；第三趟归并后{1,2,3，4,5，6,7,8}，共比较6次。三趟归并共需进行14次比较。"
        },
        "chapter": "08"
    },
    {
        "id": "q085009",
        "title": "二路归并排序第二趟结果",
        "content": "一组经过第一趟二路归并排序后的记录的关键字为25,50,15,35,80,85,20,40,36,70}，\n其中包含5个长度为2的有序表，用二路归并排序算法对该序列进行第二趟归并后的结\n果为（）。\nA.15,25,35,50,80,20,85,40,70,36\nB.15,25,35,50,20,40,80,85,36,70\nC.15,25,50,35,80,85,20,36,40, 70\nD.15,25,35,50,80,20,36, 40,70,85",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "这里采用二路归并排序算法，且是第二趟排序，因此每4个元素放在一起归并，可将序列划\n分为{25,50,15,35}，{80,85,20,40}和{36,70}，分别对它们进行排序后有{15,25,35,50}，{20,40，\n80,85}和{36,70}。"
        },
        "chapter": "08"
    },
    {
        "id": "q085010",
        "title": "生日排序算法比较",
        "content": "若将中国人按照生日（不考虑年份，只考虑月、日）来排序，则使用下列排序算法时，\n最快的是（）。\nA.归并排序\nB.希尔排序\nC.快速排序\nD.基数排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "按照所有中国人的生日排序，一方面√是非常大的，另一方面关键字所含的排序码数为2，\n且一个排序码的基数为12，另一个排序码的基数为31，都是较小的常数值，因此采用基数排序\n可以在O（N)内完成排序过程。\n378\n2026年数据结构考研复习指导"
        },
        "chapter": "08"
    },
    {
        "id": "q085011",
        "title": "线性表双数据项排序算法",
        "content": "设线性表中每个元素有两个数据项k和k2，现对线性表按以下规则进行排序：先看数据\n项k，k值小的元素在前，大的元素在后；在k值相同的情况下，再看k，k值小的元\n素在前，大的元素在后。满足这种要求的排序算法是（）。\nA.先按k进行直接插入排序，再按k进行简单选择排序\nB.先按k进行直接插入排序，再按k进行简单选择排序\nC.先按k进行简单选择排序，再按k进行直接插入排序\nD.先按k进行简单选择排序，再按k进行直接插入排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "本题思路来自基数排序的LSD，首先应确定k、k的排序顺序，若先排k再排k，则排序结果\n不符合题意，排除选项A和C。再考虑排序的稳定性，当k排好序后，再对k排序，若对k排序采\n用的方法是不稳定的，则对于k相同而k不同的元素可能会改变相对次序，从而不一定能满足题设\n要求。直接插入排序是稳定的，而简单选择排序是不稳定的，只能选择选项D。"
        },
        "chapter": "08"
    },
    {
        "id": "q085012",
        "title": "基数排序一趟结果",
        "content": "对{05,46,13,55,94,17,42}进行基数排序，一趟排序的结果是（）。\nA.05,46,13,55,94,17,42\nB.05,13,17,42,46,55,94\nC.42,13,94,05,55,46,17\nD.05,13,46,55,17,42,94\n公众号：小兔网盘\n免费网课+无水印PDF\n376\n2026年数据结构考研复习指导",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序有MSD和LSD两种，基数排序是稳定的。对于选项A，不符合LSD和MSD；\n对于选项B，符合MSD，但关键字42、46的相对位置发生了变化；对于选项D，不符合LSD\n和MSD。"
        },
        "chapter": "08"
    },
    {
        "id": "q085013",
        "title": "基数排序临时队列个数",
        "content": "有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立\n的队列个数是（）。\nA. n\nB.2\nC.5\nD.10",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序中建立的队列个数等于进制数。"
        },
        "chapter": "08"
    },
    {
        "id": "q085014",
        "title": "排序算法附加存储空间比较",
        "content": "下列各种排序算法中，（）需要的附加存储空间最大。\nA.快速排序\nB.堆排序\nC.归并排序\nD.插入排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "快速排序的平均空间复杂度是O(log2n)，归并排序的空间复杂度是O(n)，其他都是O（1)。"
        },
        "chapter": "08"
    },
    {
        "id": "q085015",
        "title": "合并升序链表的时间复杂度",
        "content": "【2013统考真题】已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n\n的一个降序链表，则最坏情况下的时间复杂度是（)。\nA. O(n)\nB.O(mn)\nC. O(min(m, n)\nD. O(max(m, n))",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "考虑两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置（取较\n小元素，头插法）。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两\n个链表中的元素依次进行比较，因为2max（m,n)≥m+n，所以时间复杂度为O（max(m,n))。此外，\n每次比较把两个链表中的较小结点插入新链表的表头，直到一个链表为空，因为原链表是升序排列\n的，要求合并后为降序排列的，因此还要把另一个链表剩下的结点一一插入新链表的表头，不论是\n最好情况还是最坏情况，都需要遍历两个链表中的所有结点。"
        },
        "chapter": "08"
    },
    {
        "id": "q085016",
        "title": "基数排序第二趟结果",
        "content": "【2013统考真题】对给定的关键字序列110,119,007,911,114,120,122进行基数排序，\n第二趟分配、收集后得到的关键字序列是（）。\nA.007,110,119,114,911,120,122\nB.007,110,119,114,911,122,120\nC. 007, 110, 911,114,119,120,122\nD.110,120,911,122,114,007,119",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序的第一趟排序是按照个位数字的大小来进行的，第二趟排序是按照十位数字的大小\n来进行的，排序的过程如下图所示。\n110—119—007—911—114—120—122\ne[o]\ne[1]\ne[2]\ne[3]\ne[4]\ne[5]\ne[6]\ne[7]\ne[8]\ne9]\n分配：\n110\n911\n122\n114\n007\n119\n120\n收集：\ne[o]\ne[1]\ne[2]\ne[3]\ne[4]\ne[5]\ne[6]\nel7\nel8\ne9\n007\n0\n120\n122\n分配：\n目\n收集："
        },
        "chapter": "08"
    },
    {
        "id": "q085017",
        "title": "排序算法移动次数与初始状态无关",
        "content": "【2015统考真题】下列排序算法中，元素的移动次数与关键字的初始状态无关的是（）。\nA.直接插入排序B.冒泡排序\nC.基数排序\nD.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序的元素移动次数与序列初态无关，而其他三种排序算法都与序列初态有关。"
        },
        "chapter": "08"
    },
    {
        "id": "q085018",
        "title": "LSD基数排序第一趟结果",
        "content": "【2021统考真题】设数组S[]={93，946，372，9,146,151,301,485,236，327,43，\n892），采用最低位优先（LSD）基数排序将S排列成升序序列。第一趟分配、收集后，元\n素372之前、之后紧邻的元素分别是（）。\nA.43,892\nB.236,301\nC. 301,892\nD.485,301",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序是一种稳定的排序算法。因为采用最低位优先（LSD）的基数排序，即第一趟对个\n位进行分配和收集操作，所以第一趟分配和收集后的结果是{151，301，372，892，93，43，485，946，\n第8章排\n序\n379\n146,236,327.9}，元素372之前、之后紧邻的元素分别是301和892。\n19.A。\n送分题。本书对归并的定义原话是“归并的含义是将两个或两个以上的有序表合并成一个新\n的有序表”，而二路归并是将两个有序表合并为一个新的有序表。"
        },
        "chapter": "08"
    },
    {
        "id": "q085019",
        "title": "二路归并排序功能",
        "content": "【2022统考真题】使用二路归并排序对含n个元素的数组M进行排序时，二路归并排序\n的功能是（）。\nA.将两个有序表合并为一个新的有序表\nB.将M划分为两部分，两部分的元素个数大致相等\nC.将M划分为n个部分，每个部分中仅含有一个元素\nD.将M划分为两部分，一部分元素的值均小于另一部分元素的值",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q085020",
        "title": "二路归并排序比较次数",
        "content": "【2024统考真题】现有由关键字组成的3个有序序列（3,5）、（7.9)和（6)，若按从左至右的\n次序选择有序序列进行二路归并排序，则关键字之间的总比较次数是（）。\nA.3\nB.4\nC.5\nD.6",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc851",
            "kc852",
            "kc853"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "从左至右对这三个有序序列进行二路归并排序的过程如下：\n①合并(3，5）和（7,9）：比较3和7（1次），选择3：比较5和7（1次），选择5；剩余元素7\n和9直接加入。②合并(3,5,7,9)和(6)：比较3和6（1次），选择3：比较5和6（1次），选择5；\n比较7和6（1次），选择6：剩余元素7和9直接加入。总共比较5次。"
        },
        "chapter": "08"
    },
    {
        "id": "q086002",
        "title": "时间复杂度为O(nlog2n)且稳定的排序算法",
        "content": "以下排序算法中时间复杂度为O(nlog2n)且稳定的是（）。\nA.堆排序\nB.快速排序\nC.归并排序\nD.直接插入排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "堆排序和快速排序不是稳定排序算法，而直接插入排序算法的时间复杂度为O（n²)。"
        },
        "chapter": "08"
    },
    {
        "id": "q086003",
        "title": "排序算法时间复杂度比较",
        "content": "设被排序的结点序列共有n个结点，在该序列中的结点已十分接近有序的情况下，用直\n接插入排序、归并排序和快速排序对其进行排序，这些算法的时间复杂度应为（）。\nA. O(n), O(n), O(n)\nB. O(n), O(nlog2n), O(nlog2n)\nC. O(n), O(nlog2n), O(n²)\nD. O(n), O(nlog2n), O(n²)",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "各种排序算法的时间和空间复杂度、稳定性等见表8.1。\n04.①I、IV、VI②II、VI、VII?IIV\n读者应能从算法的原理上理解算法的稳定性情况。堆排序和归并排序在最坏情况下的时间复\n杂度与最好情况下的时间复杂度是同一数量级的，都是O(nlog2n)。"
        },
        "chapter": "08"
    },
    {
        "id": "q086004",
        "title": "排序算法特性分析",
        "content": "下列排序算法中属于稳定排序的是（①），平均时间复杂度为O(nlog2n)的是（②），在最\n好的情况下，时间复杂度可以达到线性时间的有（③）。（注：多选题）\nI.冒泡排序II.堆排序\nIII.选择排序IV.直接插入排序\nV.希尔排序VI.归并排序VII.快速排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q086005",
        "title": "排序算法辅助空间比较",
        "content": "就排序算法所用的辅助空间而言，堆排序、快速排序和归并排序的关系是（）。\nA.堆排序<快速排序<归并排序\nB.堆排序<归并排序<快速排序\nC.堆排序>归并排序>快速排序\nD.堆排序>快速排序>归并排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "堆排序的空间复杂度为O(1)，因此快速排序的空间复杂度在最坏情况下为O(n)，平均空间复\n杂度为O（log2n)，归并排序的空间复杂度为O(n)。"
        },
        "chapter": "08"
    },
    {
        "id": "q086006",
        "title": "排序趟数与初始状态无关的算法",
        "content": "排序趟数与序列的初始状态无关的排序算法是（）。\nI.快速排序II.简单选择排序\nIII.冒泡排序IV.基数排序\nA. I、III\nB. II、IV\nC. 1、II、IV\nD. 1. IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "冒泡排序的趟数为1～n-1，和序列初态有关。简单选择排序每趟都选出一个最小（或最大）\n序的趟数和枢轴的选取有关，即和划分是否对称有关，当划分的两个区域分别包含0个元素和n-1\n个元素时，这种最大限度的不对称性发生在序列初态基本有序时。"
        },
        "chapter": "08"
    },
    {
        "id": "q086007",
        "title": "排序趟数与初始状态有关的算法",
        "content": "排序趟数与序列的初始状态有关的排序算法是（）。\nA.直接插入排序\nB.二路归并排序\nC.快速排序D.堆排序\n08．对n个元素进行排序，其排序趟数肯定为n-1趟的排序算法是（）。\nA.直接插入排序和快速排序\nB.冒泡排序和快速排序\nC.简单选择排序和直接插入排序\nD.简单选择排序和冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "直接插入排序的趟数始终为n-1，而与序列的初始状态无关。二路归并排序的趟数始终为\n[log2n]，而与序列的初始状态无关。堆排序每趟选出一个最大元素或最小元素，然后调整堆，初\n始建好堆后，需要n-1趟输出和调整堆的操作，而与序列的初始状态无关。"
        },
        "chapter": "08"
    },
    {
        "id": "q086009",
        "title": "排序方法比较次数最少的选择",
        "content": "若序列的初始状态为{1,2,3,4,5,10,6,7,8,9}，要想使得排序过程中的元素比较次数最\n少，则应该采用（）方法。\nA.插入排序\nB.选择排序\nC.希尔排序\nD.冒泡排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "选择排序和序列初态无关，直接排除。初始序列基本有序时，插入排序比较次数较少。本题\n第8章排\n序\n385\n中，插入排序仅需比较n-1+4次，而希尔排序和冒泡排序的比较次数均远大于此。"
        },
        "chapter": "08"
    },
    {
        "id": "q086010",
        "title": "不同初始序列比较次数相同的排序算法",
        "content": "对于元素个数相同的不同初始序列，总比较次数相同的排序算法是（）。\nA.折半插入排序和简单选择排序\nB.基数排序和归并排序\nC.冒泡排序和快速排序\nD.堆排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "简单选择排序的总比较次数显然是确定的。折半插入排序每趟的比较次数都为O(log2m）（m\n为当前已排好序的子序列的长度），因此总比较次数也是确定的。基数排序不是基于比较的排序\n算法。其他几种排序算法的比较次数显然和序列的初始状态有关。"
        },
        "chapter": "08"
    },
    {
        "id": "q086011",
        "title": "查找效率最低的数据结构",
        "content": "一般情况下，以下查找效率最低的数据结构是（）。\nA.有序顺序表\nB.二叉排序树\nC.堆\nD.平衡二叉树",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "堆是用于排序的，在查找时它是无序的，所以效率没有其他查找结构的高。"
        },
        "chapter": "08"
    },
    {
        "id": "q086012",
        "title": "不可并行执行的排序算法",
        "content": "一台计算机具有多核CPU，可以同时执行相互独立的任务。归并排序的各个归并段可以\n并行执行，在下列排序算法中，不可以并行执行的有（）。\nI．基数排序\nII.快速排序\nII.冒泡排序\nIV.堆排序\n第8章排序\n383\nA. I、III\nB. I、II\nC. I、III、IV\nD. II、IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "基数排序每趟需要利用前一趟已排好的序列，无法并行执行。快速排序每趟划分的子序列互\n不影响，可以并行执行。冒泡排序每趟对未排序的所有元素进行一趟处理，无法并行执行。堆排\n序可以并行执行，因为根结点的左右子树构成的子堆在执行过程中是互不影响的。"
        },
        "chapter": "08"
    },
    {
        "id": "q086013",
        "title": "排序算法第二趟结果分析",
        "content": "【2009统考真题】若数据元素序列{11，12，13,7，8,9,23，4,5}是采用下列排序算法之一得\n到的第二趟排序后的结果，则该排序算法只能是（）。\nA.冒泡排序\nB.插入排序\nC.选择排序\nD.二路归并排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里{11，12}和{4，5}\n所处的位置并不是最终位置，因此不可能是冒泡和选择排序。二路归并算法经过第二趟后应该是\n每4个元素有序的，但{11，12，13,7并非有序，因此也不可能是二路归并排序。"
        },
        "chapter": "08"
    },
    {
        "id": "q086014",
        "title": "排序算法识别",
        "content": "【2010统考真题】对一组数据(2,12,16.88,5,10)进行排序，若前3趟排序结果如下：\n第一趟排序结果：2,12,16,5,10,88\n第二趟排序结果：2,12,5,10,16,88\n第三趟排序结果：2,5,10,12,16,88\n则采用的排序算法可能是（）。\nA.冒泡排序\nB.希尔排序\nC.归并排序\nD.基数排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "题中给出的排序过程，每一趟都是从前往后依次比较使最大值沉底，符合冒泡排序的特点。\n分别用其他3种排序算法尝试，归并排序第一趟后的结果为（2，12，16，88,5，10)，基数排序第一趟\n后的结果为（10,2，12，5，16，88)，希尔排序显然不符合。"
        },
        "chapter": "08"
    },
    {
        "id": "q086015",
        "title": "排序算法确定元素位置",
        "content": "【2012统考真题】在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称\n为一趟排序。下列排序算法中，每趟排序结束都至少能够确定一个元素最终位置的方法\n是（）。\nI.简单选择排序\nII.希尔排序III.快速排序\nIV.堆排序\nV.二路归并排序\nA.仅I、III、IV\nB.仅I、III、V\nC.仅II、III、IVD.仅III、IV、V",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "对于选项1，简单选择排序每次选择未排序序列中的最小元素放入其最终位置。对于选项ⅡⅡ\n希尔排序每次对划分的子表进行排序，得到局部有序的结果，所以不能保证每趟结束都能确定一\n个元素的最终位置。对于选项III，快速排序每趟结束后都将枢轴元素放到最终位置。对于选项IV，\n堆排序属于选择排序，每次都将大根堆的根结点与表尾结点交换，确定其最终位置。对于选项V，\n二路归并排序每趟对子表进行两两归并，从而得到若干局部有序的结果，但无法确定最终位置。"
        },
        "chapter": "08"
    },
    {
        "id": "q086016",
        "title": "归并排序与插入排序的选择理由",
        "content": "【2017统考真题】在内部排序时，若选择了归并排序而未选择插入排序，则可能的理由\n是（）。\n1.归并排序的程序代码更短\nII.归并排序的占用空间更少\nIII.归并排序的运行效率更高\nA.仅ⅡI\nB.仅III\nC.仅1、II\nD.仅I、III",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "归并排序的代码比插入排序的代码更为复杂，前者的空间复杂度是O（n)，后者是O（1)。但是\n前者的时间复杂度是O(nlog2n)，后者是O(n²)。"
        },
        "chapter": "08"
    },
    {
        "id": "q086017",
        "title": "排序算法链式存储时间效率分析",
        "content": "【2017统考真题】下列排序算法中，若将顺序存储更换为链式存储，则算法的时间效率\n会降低的是（）。\nI.插入排序\nⅡ1.\n选择排序III.冒泡排序IV.希尔排序\nV.堆排序\nA.仅I、II\nB.仅II、III\nC.仅III、IV\nD.仅IV、V",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "在顺序存储的条件下，插入排序、选择排序、冒泡排序的时间复杂度都是O(r²)，更换为链\n式存储后的时间复杂度还是O（n²）。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链\n式存储不支持这种性质，所以时间复杂度会增加。"
        },
        "chapter": "08"
    },
    {
        "id": "q086018",
        "title": "排序算法选择因素",
        "content": "【2019统考真题】选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考\n虑的是()。\n1.数据的规模\nII.数据的存储方式III.算法的稳定性IV.数据的初始状态\nA.仅III\nB.仅I、ⅡI\nC.仅II、III、IVD.I、II、III、IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "当数据规模较小时可选择复杂度为O（n²）的简单排序算法，当数据规模较大时应选择复杂度\n为O(nlog2n)的排序算法，当数据规模大到内存无法放下时需选择外部排序算法，选项I正确。\n数据的存储方式主要分为顺序存储和链式存储，有些排序算法（如堆排序）只能用于顺序存储方\n式，选项ⅡI正确。若对数据稳定性有要求，则不能选择不稳定的排序算法，选项IⅢI显然正确。\n当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是\nO(n)，而归并排序的时间复杂度依旧是O(nlog2n)，选项 IV正确。"
        },
        "chapter": "08"
    },
    {
        "id": "q086019",
        "title": "直接插入排序与简单选择排序效率比较",
        "content": "【2020统考真题】对大部分元素已有序的数组排序时，直接插入排序比简单选择排序效\n率更高，其原因是（）。\n1.直接插入排序过程中元素之间的比较次数更少\nII.直接插入排序过程中所需的辅助空间更少\nIII.直接插入排序过程中元素的移动次数更少\nA.仅I\nB.仅III\nC.仅I、II\nD.I、II和IⅢI",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "考虑比较极端的情况，对于有序数组，直接插入排序的比较次数为n-1，简单选择排序的比\n386\n2026年数据结构考研复习指导\n较次数始终为1+2++n-1=n(n-1)/2，选项I正确。两种排序算法的辅助空间都是O(1)，无\n差别，选项ⅡI错误。初始有序时，移动次数均为0：对于通常情况，直接插入排序每趟插入都需\n要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，选\n项IⅢI错误。"
        },
        "chapter": "08"
    },
    {
        "id": "q086020",
        "title": "直接插入排序与快速排序的选择原因",
        "content": "【2022统考真题】对数据进行排序时，若采用直接插入排序而不采用快速排序，则可能\n的原因是（）\nI.大部分元素已有序\nII.待排序元素数量很少\nII.要求空间复杂度为O(1)\nIV.要求排序算法是稳定的\nA.仅I、II\nB.仅III、IV\nC.仅I、II、IV\nD.I、II、III、IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "直接插入排序和快速排序的特点如下表所示。\n适合初始序列情况\n适合元素数量\n空间复杂度\n稳定性\n直接插入排序\n大部分元素有序\n较少\n0(1)\n稳定\n快速排序\n基木无序\n较多\nO(log2n)\n不稳定\n可见，选项I、ⅡI、ⅢI、IV都是采用直接插入排序而不采用快速排序的可能原因。"
        },
        "chapter": "08"
    },
    {
        "id": "q086021",
        "title": "排序算法稳定性",
        "content": "【2023统考真题】下列排序算法中，不稳定的是（）。",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc861",
            "kc862"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "稳定的内部排序算法：插入排序、冒泡排序、归并排序和基数排序。不稳定的内部排序算法：\n简单选择排序、快速排序、希尔排序和堆排序。"
        },
        "chapter": "08"
    },
    {
        "id": "q087001",
        "title": "外部排序与内部排序区别",
        "content": "外部排序和内部排序的主要区别是（）。\nA.内部排序的数据量小，而外部排序的数据量大\nB.内部排序不涉及内、外存数据交换，而外部排序涉及内、外存数据交换\nC.内部排序的速度快，而外部排序的速度慢\nD.内部排序所需的内存小，而外部排序所需的内存大",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "外部排序和内部排序最主要的区别是是否涉及内存、外存的数据交换。"
        },
        "chapter": "08"
    },
    {
        "id": "q087002",
        "title": "下列关于外部排序的说法中，正确的是（）。\nA.置换选择排序得到的初始归并段的长度一定相等\nB.内外存交换数据的时间只占总排序时间的一小部分\nC.败者树是一棵完全二叉树\nD.外部排序不涉及对文件的读/写操作",
        "content": "下列关于外部排序的说法中，正确的是（）。\nA.置换选择排序得到的初始归并段的长度一定相等\nB.内外存交换数据的时间只占总排序时间的一小部分\nC.败者树是一棵完全二叉树\nD.外部排序不涉及对文件的读/写操作",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "置换选择排序得到的是长度不一定相等的归并段，选项A错误。外部排序的主要时间消耗在\n内外存之间的数据交换上，选项B错误。败者树是一棵完全二叉树，选项C正确。外部排序包括\n两个阶段：生成初始归并段和对初始归并段进行归并，这两个阶段都涉及对文件的读/写操作，选\n项D错误。"
        },
        "chapter": "08"
    },
    {
        "id": "q087003",
        "title": "多路平衡归并的作用",
        "content": "多路平衡归并的作用是（）。\nA.减少归并趟数\nB.减少初始归并段的个数\nC.便于实现败者树\nD.以上都对",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "多路平衡归并的目的是减少归并趟数，因为当m个初始归并段采用k路平衡归并时，所需趟\n数s=「logkm]，若不采用多路平衡归并，则其归并趟数大于s。"
        },
        "chapter": "08"
    },
    {
        "id": "q087004",
        "title": "5路平衡归并排序趟数计算",
        "content": "设在磁盘上存放有375000个记录，做5路平衡归并排序，内存工作区能容纳600个记\n录，为把所有记录排好序，需要做（）趟归并排序。\nA.3\nB.4\nC.5\nD.6",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "初始归并段的个数r=375000/600=625，因此，归并趟数S=「1ogmr]=「1ogs625]=4。第一趟\n把625个归并段归并成625/5=125个；第二趟把125个归并段归并成125/5=25个：第三趟把25\n个归并段归并成25/5=5个；第四趟把5个归并段归并成5/5=1个。"
        },
        "chapter": "08"
    },
    {
        "id": "q087005",
        "title": "外部排序缓冲区作用辨析",
        "content": "在下列关于外部排序过程输入/输出缓冲区作用的叙述中，不正确的是（）。\nA.暂存输入/输出记录\nB.内部归并的工作区\nC.产生初始归并段的工作区\nD.传送用户界面的消息",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "在外部排序过程中输入/输出缓冲区就是排序的内存工作区，例如做m路平衡归并需要m个\n输入缓冲区和1个输出缓冲区，用以存放参加归并的和归并完成的记录。在产生初始归并段时也\n可用作内部排序的工作区。它没有传送用户界面的消息的任务。\n06.D、A\n相比普通的m路归并：需增加一个输出缓冲区，当一个输出缓冲区满时，输出一个缓冲区的\n同时归并程序可向另一个输出缓冲区填充数据，这就实现了内部归并和输出的并行。需增加㎡个\n输入缓冲区，当m个输入缓冲区正在运行时，外部可向新增的㎡个缓冲区写入数据，这就实现了\n输入和内部归并的并行。综上，需设置2个输出缓冲区，2m个输入缓冲区。"
        },
        "chapter": "08"
    },
    {
        "id": "q087006",
        "title": "m路平衡归并排序缓冲区设置",
        "content": "在做m路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置（①）\n个输入缓冲区和（②）个输出缓冲区。\n① A. 2\nB.m\nC.2m-1\nD.2m\n② A. 2\nB. m\nC. 2m-1\nD.2m",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "未找到",
            "key_points": [
                "string"
            ],
            "explanation": "未找到解析"
        },
        "chapter": "08"
    },
    {
        "id": "q087007",
        "title": "多路归并排序最少路数",
        "content": "若只需3趟排序就可完成64个元素的多路归并排序，则选取的归并路数最少是（）。\nA.2\nB.3\nC.4\nD.5",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "归并趟数=「logkn]，其中k表示归并的路数，n表示元素个数，当k=4、n=64时，归并趟\n数恰好等于3，因此选取的归并路数至少是4。"
        },
        "chapter": "08"
    },
    {
        "id": "q087008",
        "title": "置换-选择排序的作用",
        "content": "置换-选择排序的作用是（）。\nA.用于生成外部排序的初始归并段\nB.完成将一个磁盘文件排序成有序文件的有效的外部排序算法\nC.生成的初始归并段的长度是内存工作区的2倍\nD.对外部排序中输入/归并/输出的并行处理",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "A",
            "key_points": [
                "string"
            ],
            "explanation": "置换-选择排序是外部排序中生成初始归并段的方法，用此方法得到的初始归并段的长度是\n不等长的，其长度平均是传统等长初始归并段的2倍，从而使得初始归并段数减少到原来的近二\n分之一。但是，置换-选择排序不是一种完整的生成有序文件的外部排序算法。"
        },
        "chapter": "08"
    },
    {
        "id": "q087009",
        "title": "置换选择排序的有序段关系",
        "content": "一个无序文件的n个记录采用置换选择排序产生m个有序段，则m和n的关系是（）。\nA.m与n成正比B.m=log2n\nC.m与n成反比D.以上都不对\n第8章排\n序\n393",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "设内存工作区w=1，则文件{1,2,3.4,5}产生1个有序段，而文件{5,4，3,2,1}产生5个有序\n段，因此m与待排文件、内存工作区大小w和n都有关，但不是选项A、B、C描述的直接关系。"
        },
        "chapter": "08"
    },
    {
        "id": "q087010",
        "title": "败者树选取最小记录时间",
        "content": "在由k路归并构建的败者树中选取一个关键字最小的记录，则所需时间为（）。\nA. 0(1)\nB.O(k)\nC. O(log2k)\nD.以上都不对",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "在败者树中选取最小关键字的时间复杂度取决于败者树的高度，所需时间为O(log2k)。\n第8章排\n395"
        },
        "chapter": "08"
    },
    {
        "id": "q087011",
        "title": "小顶堆与败者树比较",
        "content": "下列关于小顶堆和败者树的说法中，正确的是（）。\nI.败者树从下往上维护，每上一层，只需和失败结点比较1次\nII.败者树的每次维护，必定要从叶结点一直走到根结点，不可能从中间停止\nIII.堆从上往下维护，每下一层，若其左右孩子均不为空，则需比较2次\nIV.堆的每次维护，必定要从根结点一直走到叶结点，不可能从中间停止\nA. I、III\nB. ⅡI、III\nC.I、II、III\nD.I、III、IV",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "选项I正确，是败者树的性质。在败者树的维护过程中，会让胜利者一直调整到根结点，选\n项Ⅱ正确。以小根堆为例，每次调整时，先比较下一层的两个元素（1次），找出较小值，然后比\n较当前元素和下一层的较小元素（1次），以决定是否向下交换位置，选项ⅢI正确。堆在维护时，\n可能会在中间某层停止（若此处无须调整），而不一定要走到叶结点，选项IV错误。"
        },
        "chapter": "08"
    },
    {
        "id": "q087012",
        "title": "最佳归并树的作用",
        "content": "最佳归并树在外部排序中的作用是（）。\nA.完成m路归并排序\nB.设计m路归并排序的优化方案\nC.产生初始归并段\nD.与锦标赛树的作用类似",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "法，以初始归并段的长度为权值，构造具有最小带权路径长度的m叉哈夫曼树，可以有效地减少\n归并过程中的读/写记录数，加快外部排序的速度。"
        },
        "chapter": "08"
    },
    {
        "id": "q087013",
        "title": "最佳归并树结点个数",
        "content": "在由m个初始归并段构建的k阶最佳归并树中，不需要补充虚段，则度为k的结点个数\n是（）。\nA. (m- 1)/k\nB.m/k\nC.（m-1)/(k-1）D.无法确定",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "C",
            "key_points": [
                "string"
            ],
            "explanation": "k阶最佳归并树中只有度为0和k的结点。设结点总数为n，度为0的结点数为no，度为k\n的结点数为nk，则no=m、n-1=kxnk，n=no+nk，因此kxnk=m+nk-1，求得nk=（m-1)/(k-1)。"
        },
        "chapter": "08"
    },
    {
        "id": "q087014",
        "title": "三叉树带权路径最小长度",
        "content": "【2013统考真题】已知三叉树T中6个叶结点的权分别是2，3，4，5，6,7，T的带权（外\n部）路径长度最小是（）。\nA.27\nB.46\nC. 54\nD.56",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "题中的三叉树为使WPL最小，必须构造三叉哈夫曼树，应满足(no-1)%(3-1)=0的条件，因\n此需添加1个权值为0的虚叶结点，说明7个叶结点刚好可构成一棵严格的三叉树。按照哈夫曼树\n的原则，权为0的叶结点应离树根最远，构造三叉哈夫曼树的过程如下：\n①合并权值最小的三个结点0.2.3，得到新结点的权值=5，剩下5，4,5，6，7。\n②合并权值最小的三个结点4.5,5，得到新结点的权值=14，剩下14,6.7。\n③合并权值最小的三个结点6,7.14，得到新结点的权值=27，仅有27，建树完成。\nWPL=∑\"权值Wu结点×深度Dn结点;=(2+3)x3+(4+5)×2+(6+7)x1=46\n或\nWPL=≥权值W分支结点=27+14+5=46\n每个分支结点的权值都累加了其下面所有分支结点的权值，因此采用第二种方法更方便。\n14"
        },
        "chapter": "08"
    },
    {
        "id": "q087015",
        "title": "10TB数据排序方法",
        "content": "【2016统考真题】对10TB的数据文件进行排序，应使用的方法是（）。\nA.希尔排序\nB.堆排序\nC.快速排序\nD.归并排序",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序的文件无法一次性装\n入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。外部排序通常\n采用归并排序算法。选项A、B、C都是内部排序的方法。"
        },
        "chapter": "08"
    },
    {
        "id": "q087016",
        "title": "最佳归并虚段个数",
        "content": "【2019统考真题】设外存上有120个初始归并段，进行12路归并时，为实现最佳归并，\n需要补充的虚段个数是（）。\nA.1\nB.2\nC.3\nD.4",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "B",
            "key_points": [
                "string"
            ],
            "explanation": "在12路归并树中只存在度为0和度为12的结点，设度为0的结点数、度为12的结点数和要补充的\n结点数分别为no、n2和n，则有ng=120+n，ng=(12-1)n+1，可得n2=(120-1+n)/(12-1)。\n因为结点数ni2为整数，所以n是使上式整除的最小整数，求得n=2。\n此外，题中为实现最佳归并，应满足12叉哈夫曼树，n=120，m=12，不满足（n-1)%（m-1)=0\n的条件，因此需要添加两个权值为0的叶结点，使得n=122，才能满足条件。"
        },
        "chapter": "08"
    },
    {
        "id": "q087017",
        "title": "败者树中冠军结点保存的内容",
        "content": "【2024统考真题】在外排序中，利用败者树对初始为升序的归并段进行多路归并，败者\n树中记录“冠军”的结点保存的是（）。\nA.最大关键字\nB.最小关键字\nC.最大关键字所在的归并段号\nD.最小关键字所在的归并段号",
        "difficulty": "integer",
        "type": "concept",
        "knowledge_points": [
            "kc871",
            "kc872",
            "kc873",
            "kc874",
            "kc875"
        ],
        "related_questions": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "reference_answer": {
            "content": "D",
            "key_points": [
                "string"
            ],
            "explanation": "利用败者树归并升序归并段，每次需要得到当前的最小关键字，因此记录“冠军”的结点保\n存的只能是最小关键字或最小关键字所在的归并段号。通过败者树找出最小关键字后，还需要找\n396\n2026年数据结构考研复习指导\n到该关键字所在的归并段，并移动段内元素，以继续比较下一个元素，下面分别进行讨论：①假\n设记录“冠军”的结点保存的是最小关键字所在的归并段号，则能直接得到最小关键字及其所在\n的段，时间复杂度低。②假设记录“冠军”的结点保存的是最小关键字，则查找其所在的段需要\n检索所有段的首元素是否与该最小关键字相等，时间复杂度高。为了提高效率，记录“冠军”的\n结点保存的是最小关键字所在的归并段号，而不是最小关键字。"
        },
        "chapter": "08"
    }
]