[
    {
        "id": "kc0311",
        "title": "栈的基本概念",
        "chapter_id": "c03",
        "description": "1.栈的定义\n命题追踪栈的特点（2017）\n栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这\n种线性表只能在某一端进行插入和删除操作，如图3.1所示。\n\n第3章栈、队列和数组\n63\n出栈\n入栈\n栈顶\nas\nd4\na3\n栈底\n图3.1\n栈的示意图\n栈顶（Top）：线性表允许进行插入和删除操作的那一端。\n栈底（Bottom）：固定的，不允许进行插入和删除操作的另一端。\n空栈：不含任何元素的空表。\n命题追踪》入栈序列和出栈序列之间的关系（2022）\n命题追踪特定条件下的出栈序列分析（2010、2011、2013、2018、2020）\n假设某个栈S=（a1,α2,a3,a4,a5)，如图3.1所示，则a为栈底元素，as为栈顶元素。栈只能\n在栈顶进行插入和删除操作，入栈次序依次为a,a2,a3,a4,a，而出栈次序为as,a4,d3,d2,a。由\n此可见，栈的操作特性可以明显地概括为后进先出（Last InFirstOut，LIFO）。\n注意\n每接触一种新的数据结构，都应从其逻辑结构、存储结构和运算三个方面着手。\n2.栈的基本操作\n各种辅导书中给出的基本操作的名称不尽相同，但所表达的意思大致是一样的。这里我们以\n严蔚敏编写的教材为准给出栈的基本操作，希望读者能熟记下面的基本操作。\n·InitStack（&S）：初始化一个空栈S。\n·StackEmpty（S）：判断一个栈是否为空，若栈s 为空则返回true，否则返回false。\n·Push（&S，x)：入栈，若栈s 未满，则将x加入使之成为新栈顶。\n·Pop（&S，&x）：出栈，若栈s 非空，则弹出栈顶元素，并用x返回。\n·GetTop（S，&x)：读栈顶元素，但不出栈，若栈s 非空，则用x返回栈顶元素。\n·DestroyStack（&S）：销毁栈，并释放栈s占用的存储空间（“&”表示引用调用）。\n在解答算法题时，若题干未做出限制，则也可直接使用这些基本的操作函数。\nn+1\n为卡特兰数（Catalan）公式，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ]
    },
    {
        "id": "kc0312",
        "title": "栈的顺序存储结构",
        "chapter_id": "c03",
        "description": "栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。\n1.顺序栈的实现\n采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元\n素，同时附设一个指针（top）指示当前栈顶元素的位置。\n栈的顺序存储类型可描述为\n#define MaxSize 50\n//定义栈中元素的最大个数\ntypedef struct\n\n64\n2026年数据结构考研复习指导\nElemtype data[MaxSize];\n1/存放栈中元素\nint top;\n//栈顶指针\n)SqStack;\n栈顶指针：S.top，初始时设置s.top=-1；栈顶元素：S.data[S.top］。\n入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶。\n出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1。\n栈空条件：S.top==-1；栈满条件：S.top==MaxSize-1；栈长：S.top+1。\n另一种常见的方式是：初始设置栈顶指针S.top=0：入栈时先将值送到栈顶，栈顶指针再\n加1；出栈时，栈顶指针先减1，再取栈顶元素；栈空条件是S.top==0；栈满条件是\nS.top==MaxSizeo\n顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上\n溢，此时应及时向用户报告消息，以便及时处理，避免出错。\n注意\n栈和队列的判空、判满条件，会因实际给出的条件不同而变化，下面的代码实现是在栈顶指针初始\n化为-1的条件下的相应方法，而其他情况则需具体问题具体分析。\n2.顺序栈的基本操作\n命题追踪出/入栈操作的模拟（2009）\n栈操作的示意图如图3.2所示，图3.2（a)是空栈，图3.2（c)是A、B、C、D、E共5个元素依\n次入栈后的结果，图3.2(d)是在图3.2(c)之后E、D、C的相继出栈，此时栈中还有2个元素，或\n许最近出栈的元素C、D、E仍在原先的单元存储着，但top指针已经指向了新的栈顶，元素C、\nD、E已不在栈中，读者应通过该示意图深刻理解栈顶指针的作用。\ntop\nE\nD\nC\nB\ntop\ntop\ntop\n(a)空栈\n(b）1个元素\n(c）5个元素\n(d)2个元素\n图3.2栈顶指针和栈中元素之间的关系\n下面是顺序栈上常用的基本操作的实现。\n（1）初始化\nvoid InitStack(SqStack &S)(\nS.top=-1;\n/初始化栈顶指针\n（2）判栈空\nbool StackEmpty(SqStack S)(\nif(s.top==-1)\n//栈空\nreturn\ntrue;\nelse\nI/不空\nreturnfalse;\n（3）入栈\nbool Push(SqStack &S,ElemType x)(\n\n第3章栈、队列和数组\n65\nif(S.top==MaxSize-1)\n//栈满，报错\nreturn false;\nS.data[++s.top]=x;\n//指针先加1，再入栈\nreturn true;\n当栈不满时，top先加1，再入栈。若初始时将top定义为0，函数3和4应如何改写？\n（4）出栈\nbool Pop(SqStack &S,ElemType &x)(\nif(s.top==-1)\n//栈空，报错\nreturn false;\nx=S.data[s.top--];\n//先出栈，指针再减1\nreturn true;\n（5）读栈顶元素\nbool GetTop(SqStack S,ElemType &x){\nif(s.top==-1)\n//栈空，报错\nreturn false;\nx=S.data[s.top];\n//x记录栈顶元素\nreturn true;\n仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。\n注意\n这里的top指的是栈顶元素。于是，入栈操作为s.data[++s.top］=x，出栈操作为\nx=S.data[S.top--]。若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，则入栈操\n作变为 S.data[S.top++]=x；出栈操作变为 x=S.data[--S.top]。相应的栈空、栈满条件也会发\n生变化。请读者仔细体会其中的不同之处，做题时要灵活应变。\n3.共享栈\n利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分\n别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图3.3所示。\n0\nMaxSize-l\n栈数组\n0号栈栈底\n0号栈栈顶1号栈栈顶\n1号栈栈底\n图3.3两个顺序栈共享存储空间\n两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为\n再赋值，1号栈入栈时top1先减1再赋值；出栈时则刚好相反。\n共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满\n时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ]
    },
    {
        "id": "kc0313",
        "title": "栈的链式存储结构",
        "chapter_id": "c03",
        "description": "采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存\n在栈满上溢的情况。通常采用单链表实现链栈，并规定所有操作都是在单链表的表头进行的。这\n里规定链栈没有头结点，Lhead指向栈顶元素，如图3.4所示。\n\n66\n2026年数据结构考研复习指导\n栈顶结点\n栈底结点\nLhead-\na2\na\n图3.4栈的链式存储\n栈的链式存储类型可描述为\ntypedef struct Linknodet\nElemType data;\n//数据域\nstruct Linknode *next;\n/指针域\n)LiStack;\n//栈类型定义\n采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链\n表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ]
    },
    {
        "id": "kc0321",
        "title": "队列的基本概念",
        "chapter_id": "c03",
        "description": "1.队列的定义\n队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表\n的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们\n日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（FirstIn\nFirstOut，FIFO），如图3.5所示。\n\n76\n2026年数据结构考研复习指导\n出队列\na),a,a3,a4.as\n入队列\n队头\n队尾\n图3.5队列示意图\n队头（Front）：允许删除的一端，也称队首。\n队尾（Rear）：允许插入的一端。\n空队列：不含任何元素的空表。\n2.队列常见的基本操作\nInitQueue（&Q)：初始化队列，构造一个空队列Q。\nQueueEmpty（Q)：判队列空，若队列Q为空返回true，否则返回false。\nEnQueue（&Q，x)：入队，若队列Q未满，将×加入，使之成为新的队尾。\nDeQueue（&Q，&x）：出队，若队列Q非空，删除队首元素，并用x返回。\nGetHead（Q，&x）：读队首元素，若队列Q非空，则将队首元素赋值给x。\n需要注意的是，栈和队列是操作受限的线性表，因此不是任何对线性表的操作都可以作为栈\n和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ]
    },
    {
        "id": "kc0322",
        "title": "队列的顺序存储结构",
        "chapter_id": "c03",
        "description": "1.队列的顺序存储\n队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队首指\n针front指向队首元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear\n的定义可能不同，例如，可以让rear指向队尾元素、front指向队首元素。对于不同的定义，\n出入队的操作是不同的，本节后面有一些相关的习题，读者可以结合习题思考）。\n队列的顺序存储类型可描述为\n#define MaxSize 50\n1定义队列中元素的最大个数\ntypedef struct{\nElemType data[MaxSize];\n//用数组存放队列元素\nint front,rear;\n/队首指针和队尾指针\n)SqQueue;\n初始时：Q.front=Q.rear=0。\n入队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n出队操作：队不空时，先取队首元素值，再将队首指针加1。\n图3.6(a)所示为队列的初始状态，有Q.front==Q.rear==0成立，该条件可以作为队列判\n空的条件。\ncear\nfront\nd\nb\nfront\nfront\na\nrear\n(a)空队\n(b)5个元素入队\n(c）出队1次\n(d）出队3次\n图3.6队列的操作\n但能否用Q.rear==MaxSize作为队列满的条件呢？显然不能，图3.6（d)中，队列中仅有一\n\n第3章栈、队列和数组\n77\n个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在data\n数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。\n2.循环队列\n上面指出了顺序队列“假溢出”的问题，这里引出循环队列的概念。将顺序队列臆造为一个\n环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=\nMaxSize-1后，再前进一个位置就自动到0，这可以利用除法取模运算（%）来实现。\n命题追踪特定条件下循环队列队头/队尾指针的初值（2011）\n初始时：Q.front=Q.rear=0。\n队首指针进1：Q.front=（Q.front+1）%MaxSize。\n队尾指针进1：Q.rear=（Q.rear+1）%MaxSize。\n队列长度：（Q.rear+MaxSize-Q.front）MaxSize。\n出入队时：指针都按顺时针方向进1（如图3.7所示）。\n命题追踪特定条件下循环队列队空/队满的判断条件（2014）\n那么，循环队列队空和队满的判断条件是什么呢？显然，队空的条件是Q.front==Q.rear。\n若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图3.7（d1)所示，\n此时可以看出队满时也有Q.front==Q.rear。循环队列出入队示意图如图3.7所示。\nQ.front\nQ.front\n(a）初始空队\n(b)a、b、c入队\n(c)all队\nQ.front\n（d1)d、e、f、g入队\n(d2)d、e、f入队\n（无法判断队满还是队空）\n（牺牲个存储单元）\n图3.7循环队列出入队示意图\n为了区分是队空还是队满的情况，有三种处理方式：\n1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，\n约定以“队首指针在队尾指针的下一位置作为队满的标志”，如图3.7（d2）所示。\n队满条件：（Q.rear+1）%MaxSize==Q.front。\n队空条件：Q.front==Q.rear。\n队列中元素的个数：（Q.rear-Q.front+MaxSize）%MaxSize。\n2）类型中增设size数据成员，表示元素个数。若删除成功，则size减1，若插入成功，\n\n78\n2026年数据结构考研复习指导\n则size加1，队空时Q.size==0；队满时Q.size==MaxSize，两种情况都有\nQ.front==Q.rear.\n3）类型中增设tag数据成员，以区分是队满还是队空。删除成功置tag=0，若导致\nQ.front==Q.rear，则为队空；插入成功置tag=1，若导致Q.front==Q.rear，则\n为队满。\n3.循环队列的操作\n（1）初始化\nvoid InitQueue(SqQueue &Q)(\nQ.rear=Q.front=0;\n/初始化队首、队尾指针\n（2）判队空\nbool isEmpty(SqQueue Q)(\nif(Q.rear==Q.front)\n/队空条件\nreturn true;\nelse\nreturn false;\n（3）入队\nbool EnQueue(SqQueue &Q,ElemType x){\nif((Q.rear+1)%MaxSize==Q.front)\n//队满则报错\nreturn false;\nQ.data[Q.rear]=x;\nQ.rear=(Q.rear+l)MaxSize;\n/队尾指针加1取模\nreturn true;\n（4）出队\nbool DeQueue(SqQueue &Q,ElemType &x)(\nif(Q.rear==Q.front)\n/队空则报错\nreturn false;\nx=Q.data[Q.front];\nQ.front=(Q.front+1)%MaxSize;\n//队首指针加1取模\nreturn true;",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ]
    },
    {
        "id": "kc0323",
        "title": "",
        "chapter_id": "c03",
        "description": "队列的链式存储结构\n1.队列的链式存储\n命题追踪根据需求分析队列适合的存储结构（2019）\n队列的链式表示称为链式队列，它实际上是一个同时有队首指针和队尾指针的单链表，如\n图3.8所示。队首指针指向队头结点，队尾指针指向队尾结点，即单链表的最后一个结点。\nrear\nfront-\n“D\n图3.8不带队头结点的链式队列\n队列的链式存储类型可描述为\ntypedef struct LinkNodet\n//链式队列结点\nElemType data;\nstruct LinkNode *next;\n)LinkNode;\n\n第3章栈、队列和数组\n79\ntypedef struct(\n//链式队列\nLinkNode *front,*rear;\n/队列的队头和队尾指针\n)LinkQueue;\n不带头结点时，当Q.front==NULL且Q.rear==NULL时，链式队列为空。\n命题追踪链式队列队空的判断（2019）\n入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear 指向这个新插入的结\n点（若原队列为空队，则令Q.front也指向该结点）。出队时，首先判断队是否为空，若不空，\n则取出队首元素，将其从链表中删除，并让Q.front指向下一个结点（若该结点为最后一个结\n点，则置Q.front和Q.rear都为NULL）。\n不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个\n带头结点的单链表，这样插入和删除操作就统一了，如图3.9所示。\nrear\nfront-\nfront-\n图3.9带队头结点的链式队列\n用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生\n溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样\n就不会出现存储分配不合理和“溢出”的问题。\n2.链式队列的基本操作\n命题追踪链式队列出队/入队操作的基本过程（2019）\n（1）初始化\nvoidInitQueue（LinkQueue&Q）（//初始化带头结点的链式队列\nQ.front=Q.rear=（LinkNode*）malloc(sizeof(LinkNode））;//建立头结点\nQ.front->next=NULL;\n//初始为空\n（2）判队空\nbool IsEmpty(LinkQueue Q)(\nif（Q.front==Q.rear）\n//判空条件\nreturn true;\nelse\nreturn false;\n（3）入队\nvoid EnQueue(LinkQueue &Q,ElemType x){\nLinkNode*s=（LinkNode*）malloc（sizeof（LinkNode））;//创建新结点\ns->data=x;\ns->next=NULL;\nQ.rear->next=s;\n/插入链尾\nQ.rear=s;\n//修改尾指针\n（4）出队\nbool DeQueue(LinkQueue &Q,ElemType &x) {\nif(Q.front==Q.rear)\nreturn false;\n//空队\n\n80\n2026年数据结构考研复习指导\nLinkNode *p=Q.front->next;\nx=p->data;\nQ.front->next=p->next;\nif(Q.rear==p)\nQ.rear=Q.front;\nⅡ若原队列中只有一个结点，删除后变空\nfree(p);\nreturn true;",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ]
    },
    {
        "id": "kc0324",
        "title": "",
        "chapter_id": "c03",
        "description": "双端队列\n双端队列是指允许两端都可以进行插入和删除操作的线性表，如图3.10所示。双端队列两端\n的地位是平等的，为了方便理解，将左端也视为前端，右端也视为后端。\n后端\n插入\n插入\na\na2\nan1\na\n删除\n删除\n图3.10双端队列\n在双端队列入队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在\n队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在\n后出的元素的前面。思考：如何由入队序列a.b.c.d得到出队序列dca.b？\n命题追踪双端队列出队/入队操作模拟（2010、2021）\n输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为\n输出受限的双端队列，如图3.11所示。\n前端\n后端\n插入\na\na2\n插入\nan\n删除\n图3.11输出受限的双端队列\n输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为\n输入受限的双端队列，如图3.12所示。若限定双端队列从某个端点插入的元素只能从该端点删除，\n则该双端队列就蜕变为两个栈底相邻接的栈。\n后端\n插入\na\na2\nd3\nan-1\na\n删除\n删除\n图3.12输入受限的双端队列\n例设有一个双端队列，输入序列为1，2，3，4，试分别求出以下条件的输出序列。\n（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。\n（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。\n（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。\n解：先看输入受限的双端队列，如图3.13所示。假设end1端输入1,2,3，4，则end2端的输\n出相当于队列的输出，即1,2,3,4；而end1端的输出相当于栈的输出，n=4时仅通过end1端有\n14种输出序列（由Catalan公式得出），仅通过end1端不能得到的输出序列有4！-14=10种：\n\n第3章栈、队列和数组\n81\n1,4,2,3\n2,4,1,3\n3,4,1,2\n3,1,4,2\n3,1,2,4\n4,3,1,2\n4, 1,3,2\n4,2,3, 1\n4,2,1,3\n4,1,2,3\n通过end1和end2端混合输出，可以输出这10种中的8种，参看下表。其中，SL,XL分别代\n表end1端的入队和出队，XR代表end2端的出队。\n输出序列\n入队出队顺序\n输出序列\n入队出队顺序\n1,4,2,3\nSLXRSLSLSLXIXRXR\n3, 1,2,4\nSLSSLXLSLXRXRXR\n2,4,1,3\nSSLXLSISLXLXRXR\n4,1,2,3\nSSLSLSLXXRXRAR\n3,4,1,2\nSLSLSLXLSLXIXRXR\n4,1,3,2\nSSSLSLXLXRXXR\n3,1,4,2\nSSISLXLXRSLXXR\n4,3,1,2\nSSSSXXXRXR\n剩下两种是不能通过输入受限的双端队列输出的，即4,2，3，1和4,2,1,3。\n再看输出受限的双端队列，如图3.14所示。假设end1端和end2端都能输入，仅end2端可\n以输出。若都从end2端输入，就是一个栈了。当输入序列为1,2，3，4时，输出序列有14种。对\n于其他10种不能得到的输出序列，交替从end1和end2端输入，还可以输出其中8种。设SL代\n表end1端的输入，SR、X分别代表end2端的输入和输出，则可能的输出序列见下表。\n←\nend1\nend2\nendi\nend2\n图3.13例题中输入受限的双端队列\n图3.14例题中输出受限的双端队列\n输出序列\n入队出队顺序\n输出序列\n入队出队顺序\n1,4,2,3\nSLXRSLSISRXRXRYR\n3, 1,2,4\nSLSLSRXRXRSLXRXR\n2,4,1,3\nSISRYRSLSRYRXRXR\n4, 1,2,3\nSSISLSRXRXRXRYR\n3,4,1,2\nSLSLSRXRSRYRXRXR\n4,2,1,3\nSSRSLSRXRXRXRXR\n3,1,4,2\nSSLSRXRXRSRXRXR\n4,3, 1, 2\nSLSLSRSRXRXRXRXR\n通过输出受限的双端队列不能得到的两种输出序列是4,1,3,2和4,2,3,1。\n综上所述：\n1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的是4，1,3，2。\n2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的是4,2，1，3。\n3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的是4，2，3，1。\n提示\n实际双端队列的考题不会这么复杂，通常仅判断序列是否满足题设条件，代入验证即可。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ]
    },
    {
        "id": "kc0331",
        "title": "栈在括号匹配中的应用",
        "chapter_id": "c03",
        "description": "假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序任意即（[]（））或[（[][]）]\n等均为正确的格式，【（]）或（[（））或（（）］均为不正确的格式。\n考虑下列括号序列：\n\n90\n2026年数据结构考研复习指导\n2\n5\n分析如下：\n1）计算机接收第1个括号“”后，期待与之匹配的第8个括号“]”出现\n2）获得了第2个括号“（”，此时第1个括号“”暂时放在一边，而急迫期待与之匹配的第\n7个括号“）”出现。\n3）获得了第3个括号“[”，此时第2个括号“（”暂时放在一边，而急迫期待与之匹配的第\n4个括号“]”出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又\n成为当前最急迫的任务。\n4）以此类推，可见该处理过程与栈的思想吻合。\n算法的思想如下：\n1）初始设置一个空栈，顺序读入括号。\n2）若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的栈中所有未消解的\n期待的急迫性降了一级。\n3）若是右括号，则或使置于栈顶的最急迫期待得以消解，或是不合法的情况（括号序列不\n匹配，退出程序）。算法结束时，栈为空，否则括号序列不匹配。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ]
    },
    {
        "id": "kc0332",
        "title": "栈在表达式求值中的应用",
        "chapter_id": "c03",
        "description": "表达式求值是程序设计语言编译中一个最基本的问题，它是栈应用的一个典型范例。\n1.算术表达式\n中缀表达式（如3+4）是人们常用的算术表达式，操作符以中缀形式处于操作数的中间。与\n前缀表达式（如+34）或后缀表达式（如34+）相比，中缀表达式不容易被计算机解析，但仍被\n许多程序语言使用，因为它更符合人们的思维习惯。\n与前缀表达式或后缀表达式不同的是，中缀表达式中的括号是必需的。计算过程中必须用括\n号将操作符和对应的操作数括起来，用于指示运算的次序。后缀表达式的运算符在操作数后面，\n后缀表达式中考虑了运算符的优先级，没有括号，只有操作数和运算符。\n中缀表达式A+B*（C-D）-E/F对应的后缀表达式为ABCD-*+EF/-，将后缀表达式与原表达\n式对应的表达式树（图3.15）的后序遍历序列进行比较，可发现它们有异曲同工之妙。\n图3.15A+B*（C-D)-E/F对应的表达式树\n2.中缀表达式转后级表达式\n命题追踪中缀表达式转后缀表达式的方法（2024）\n下面先给出一种由中缀表达式转后缀表达式的手算方法。\n①中缀转前缀的方法类似，且统考真题仅考查过中缀转后缀的过程，因此本节仅介绍中缀转后缀的方法。\n\n第3章栈、队列和数组\n91\n1）按照运算符的运算顺序对所有运算单位加括号。\n3）去除所有括号。\n例如，中缀表达式A+B*（C-D）-E/F转后缀表达的过程如下（下标表示运算符的运算顺序）：\n1）加括号：（(A+③(B*②(C-①D)))-③(E/@F))。\n2）运算符后移：（(A(B(CD)-①）*②）+③(EF)/①)-③\n3）去除括号后，得到后缀表达式：ABCD-①*②+EF/@-\n在计算机中，中缀表达式转后缀表达式时需要借助一个栈，用于保存暂时还不能确定运算顺\n序的运算符。从左到右依次扫描中缀表达式中的每一项，具体转化过程如下：\n1）遇到操作数。直接加入后缀表达式。\n2）遇到界限符。若为“（”，则直接入栈；若为“）”，则不入栈，且依次弹出栈中的运算\n符并加入后缀表达式，直到遇到“（”为止，并直接删除“（”。\n3）遇到运算符。①若其优先级高于栈顶运算符或遇到栈顶为“（”，则直接入栈：②若其优\n先级低于或等于栈顶运算符，则依次弹出栈中的运算符并加入后缀表达式，直到遇到一\n个优先级低于它的运算符或遇到“（”或栈空为止，之后将当前运算符入栈。\n按上述方法扫描所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n例如，中缀表达式A+B*（C-D)-E/F转后缀表达式的过程如表3.1所示。\n表3.1中缀表达式A+B*（C-D）-E/F转后缀表达式的过程\n步\n待处理序列\n栈内\n后缀表达式\n扫描项\n说\n明\nA+B*(C-D)-E/E\nA\nA加入后缀表达式\n2\n+B*(C-D)-E/F\nA\n+\n+入栈\nB*(C-D)-E/E\n+\nA\nB\nB加入后缀表达式\n*(C-D)-E/E\n+\nAB\n*\n*优先级高于栈顶，*入栈\n5\n(C-D)-E/F\n+*\nAB\n（直接入栈\n6\nC-D)-E/F\n+*（\nAB\nC\nC加入后缀表达式\nD)-E/F\n+*(\nABC\n栈顶为（，-直接入栈\n8\nD)-E/F\n+*（-\nABC\nD\nD加入后缀表达式\n9\n)-E/E\n+*（-\nABCD\n遇到），弹出-，删除（\n10\n-E/E\n+*\nABCD-\n-优先级低于栈顶，依次弹出*、+，-入栈\n11\nE/E\nABCD-*+\nE\nE加入后缀表达式\n12\n/E\nABCD-*+E\n/\n/优先级高于栈顶，/入栈\n一\n13\n-/\nABCD-*+E\nF\nF加入后缀表达式\n14\n-/\nABCD-*+EF\n字符扫描完毕，弹出剩余运算符\nABCD-*+EE/-\n结束\n命题追踪\n栈的深度分析（2009、2012）\n所谓栈的深度，是指栈中的元素个数，通常是给出入栈和出栈序列，求最大深度（栈的容量\n应大于或等于最大深度）。有时会间接给出入栈和出栈序列，例如以中缀表达式和后缀表达式的\n形式给出入栈和出栈序列。掌握栈的先进后出的特点进行手工模拟是解决这类问题的有效方法。\n3.后缀表达式求值\n命题追踪月\n用栈实现表达式求值的分析（2018）\n通过后缀表示计算表达式值的过程：从左往右依次扫描表达式的每一项，若该项是操作数，\n\n92\n2026年数据结构考研复习指导\n则将其压入栈中；若该项是操作符<op>，则从栈中退出两个操作数Y和x,形成运算指令X<op>Y，\n并将计算结果压入栈中。当所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。\n例如，后缀表达式ABCD-*+EF/-求值的过程需要12步，见表3.2。\n表3.2后缀表达式ABCD-*+EF/-求值的过程\n步\n扫描项\n项类型\n栈中内容\n置空栈\n空\n2\nA\n操作数\n入栈\nA\n3\nB\n操作数\n入栈\nAB\nC\n操作数\n入栈\nABC\n5\nD\n操作数\n入栈\nABCD\n6\n一\n操作符\nD、C出栈，计算C-D，结果R入栈\nABR\n7\n*\n操作符\nR、B出栈，计算BxR，结果R入栈\nAR2\n8\n操作符\nR2、A出栈，计算A+R2，结果R入栈\nR3\n9\nE\n操作数\n入栈\nRE\n10\nF\n操作数\n入栈\nREF\n11\n操作符\nE、E出栈，计算E/F，结果R4入栈\nR3R4\n12\n操作符\nR4、R出栈，计算R-R4，结果Rs入栈\nR5",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ]
    },
    {
        "id": "kc0333",
        "title": "",
        "chapter_id": "c03",
        "description": "栈在递归中的应用\n递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应\n用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。\n递归通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递\n归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码\n量。但在通常情况下，它的效率并不是太高。\n以斐波那契数列为例，其定义为\n[F(n-1)+F(n-2),n>1\nF(n)={1,\nn=1\n[o,\nn=0\n这就是递归的一个典型例子，用程序实现时如下：\nint F(int n)(\n//斐波那契数列的实现\nif (n==0)\nreturn0;\n//边界条件\nelse if（n==1)\nreturn1;\n/边界条件\nelse\nreturn F(n-1)+F(n-2);\n//递归表达式\n必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：\n·递归表达式（递归体）。\n·边界条件（递归出口）。\n递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。\n命题追踪栈在函数调用中的作用和工作原理（2015、2017）\n在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来\n进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很\n\n第3章栈、队列和数组\n93\n多重复的计算。下面以n=5为例，列出递归调用执行过程，如图3.16所示。\nF(5)\nE(4)\nF(3)\nE(3）\nF(2)\nF(2）\nF(1）\nF(1)\nF(1)\nF(0)\nF(1)\nF（O)\nF（1)\nF（O)\n图3.16F（5）的递归执行过程\n显然，在递归调用的过程中，F(3)被计算2次，F(2)被计算3次。F(1)被调用5次，F(0)\n被调用3次。所以，递归的效率低下，但优点是代码简单，容易理解。在第5章的树中利用了递\n归的思想，代码变得十分简单。通常情况下，初学者很难理解递归的调用过程，若读者想具体了\n解递归是如何实现的，可以参阅编译原理教材中的相关内容。\n可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ]
    },
    {
        "id": "kc0334",
        "title": "队列在层次遍历中的应用",
        "chapter_id": "c03",
        "description": "在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层\n或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，\n就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树（见图3.17）\n层次遍历的例子，说明队列的应用。表3.3显示了层次遍历二叉树的过程。\nB\nC\nD\n?\n?\nG\n图3.17\n二叉树\n表3.3层次遍历二叉树的过程\n序\n说\n明\n队内\n队\n外\n1\nA入\nA\n2\nA出，BC入\nBC\nA\n3\nB出，D入\nCD\nAB\n4\nC出，EF入\nDEF\nABC\n5\nD出，G入\nEFG\nABCD\n6\nE出，HI入\nFGHI\nABCDE\n7\nF出\nGHI\nABCDEF\n8\nGHI出\nABCDEFGHI\n该过程的简单描述如下：\n①根结点入队。\n②若队空（所有结点都已处理完毕），则结束遍历：否则重复③操作。\n\n94\n2026年数据结构考研复习指导\n③队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右\n孩子入队，返回②。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ]
    },
    {
        "id": "kc0335",
        "title": "队列在计算机系统中的应用",
        "chapter_id": "c03",
        "description": "队列在计算机系统中的应用非常广泛，以下仅从两个方面来阐述：第一个方面是解决主机与\n外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。\n命题追踪缓冲区的逻辑结构（2009）\n对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据\n给打印机打印，输出数据的速度比打印数据的速度要快得多，因为速度不匹配，若直接把输出的\n数据送给打印机打印，则显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印\n输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中\n按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓\n冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数\n据缓冲区中所存储的数据就是一个队列。\n命题追踪多队列出队/入队操作的应用（2016）\n对于第二个方面，CPU（中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的\n例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自已的程序，它们分别\n序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用\n完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个\n用户的请求，又使CPU能够正常运行。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ]
    },
    {
        "id": "kc0391",
        "title": ",6.7。若期望驶出的次序依次为1~9，则n至少是（）。",
        "chapter_id": "c03",
        "description": "m\n：\n入口\n出口\n轨道\nA.2\nB.3\nC.4\nD.5\n17.【2017统考真题】下列关于栈的叙述中，错误的是（）。\n1.采用非递归方式重写递归程序时必须使用栈\nI1.函数调用时，系统要用栈保存必要的信息\nIII.只要确定了入栈次序，即可确定出栈次序\nIV.栈是一种受限的线性表，允许在其两端进行操作\nA.仅I\nB.仅I、ⅡI、III\nC.仅I、III、IV\nD.仅II、III、IV\n18.【2018统考真题】若栈S1中保存整数，栈S2中保存运算符，函数F（）依次执行下述各\n步操作：\n1）从S1中依次弹出两个操作数a和b。\n2）从S2中弹出一个运算符op。\n3）执行相应的运算bop a。\n4）将运算结果压入S1中。\n假定S1中的操作数依次是5，8，3,2（2在栈顶），S2中的运算符依次是*、一、+（+在\n栈顶）。调用3次F（）后，S1栈顶保存的值是（）。\nA.-15\nB.15\nC. -20\nD. 20\n19.【2024统考真题】与表达式x+y*（=-u)/v等价的后缀表达式是（）。\nA.xy=u-*v/+\nB.xy=u-v/*+\nC.+x/*y-=uv\nD.+x*y/-=uv\n二、综合应用题\n01.假设一个算术表达式中包含圆括号、方括号和花括号3种类型的括号，编写一个算法来\n判别表达式中的括号是否配对，以字符“0”作为算术表达式的结束符。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": []
    },
    {
        "id": "kc0341",
        "title": "数组的定义",
        "chapter_id": "c03",
        "description": "数组是由n（n≥1）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元\n素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。\n数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为\n其元素是定长数组的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除\n结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ]
    },
    {
        "id": "kc0342",
        "title": "数组的存储结构",
        "chapter_id": "c03",
        "description": "大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数\n据类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。\n\n第3章栈、队列和数组\n101\n以一维数组A[0.n-1]为例，其存储结构关系式为\nLOC(a,)= LOC(a)+ix L (O≤i<n)\n其中，L是每个数组元素所占的存储单元。\n命题追踪）二维数组按行优先存储的下标对应关系（2021）\n对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的\n基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组\n的行下标与列下标的范围分别为[0,h]与[0,h2]，则存储结构关系式为\nLOC(a,;)= LOC(ao)+[ix(h, +1)+ j]x L\n例如，对于数组A[2I[3]，它按行优先方式在内存中的存储形式如图3.18所示。\nlalloln Illol lollol\nIillolp\nIallolp\nA|21131=\n]\n第1行\n第2行\n图3.18\n二维数组按行优先顺序存放\n当以列优先方式存储时，得出存储结构关系式为\nLOC(a,)= LOC(ao.0) +[jx(h, +1)+i]xL\n例如，对于数组A[23，它按列优先方式在内存中的存储形式如图3.19 所示。\n[aa0121\nlollolp\nlillolp\nA|21131=\n第1列\n第2列\n第3列\n图3.19\n二维数组按列优先顺序存放",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ]
    },
    {
        "id": "kc0343",
        "title": "特殊矩阵的压缩存储",
        "chapter_id": "c03",
        "description": "压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配空间。\n特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一\n定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。\n特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律\n性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。\n1．对称矩阵\n命题追踪对称矩阵压缩存储的下标对应关系（2018、2020）\n若对一个n阶矩阵 A中的任意一个元素ai,y都有aj=aj（1≤i,j≤n），则称其为对称矩阵。\n其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如图3.20所示。\na2.\nC2.1\n<j上三角区\nCn.\nan.2\ni>j下三角区\ni=j主对角线\n图3.20n阶矩阵的划分\n\n102\n2026年数据结构考研复习指导\n对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存\n放，则会浪费几乎一半的空间，为此将n阶对称矩阵A存放在一维数组B[n（n+1）/2］中，即元\n素ai存放在b中。比如只存放下三角部分（含主对角线）的元素。\n在数组B中，位于元素aj（i≥j）前面的元素个数为\n第1行：1个元素（a1.1）。\n第2行：2个元素（a2.1,a2.2）。\n第i-1行：i-1个元素（a-1.1,a-1.2,*…,a-1,i-1）。\n第i行：j-1个元素（a.1,a,2.…,aij-1）。\n因此，元素aiy在数组B中的下标k=1+2+…+(i-1)+j-1=i(i-1)/2+j-1（数组下标从0\n开始）。因此，元素下标之间的对应关系如下：\ni(i-1)\n+j-1,\ni≥j（下三角区和主对角线元素)\n2\nj(j-1)\n+i-1,\ni<j（上三角区元素a,=a）\n2\n当数组下标从1开始时，可以采用同样的推导方法，请读者自行思考。\n注意\n二维数组A[n][n]和A[0...n-1][0...n-1]的写法是等价的。若数组写成A[1..n][1..n]，则表示\n指定了下标是从1开始的。二维数组元素写为a[i][j]，注意数组元素下标i和j通常是从0开始的\n矩阵元素通常写为a主，j，行号i和列号j通常是从1开始的。\n2.三角矩阵\n下三角矩阵[见图3.22（a)]中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵\n类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一\n次，所以可以将n阶下三角矩阵A压缩存储在B[n（n+1）/2+1]中。\n元素下标之间的对应关系为\ni(i-1)\n+i-1.\ni≥j(下三角区和主对角线元素)\n2\nK=\nn(n+1)\ni<j（上三角区元素）\n2\n下三角矩阵在内存中的压缩存储形式如图3.21所示。\na2,1\na2.2\n3.2\n3.3\nan,1\n第1行第2行\n第3行\n第n行\n常数项\n图3.21\n下三角矩阵的压缩存储\n命题追踪上三角矩阵采用行优先存储的应用（2011）\n上三角矩阵［见图3.22（b)】中，下三角区的所有元素均为同一常量。只需存储主对角线、上三\n角区上的元素和下三角区的常量一次，可将其压缩存储在B[n（n+1）/2+1]中。\n\n第3章栈、队列和数组\n103\na1\na1,1a12\n2.1\nd2.2\nd2.2\na2.n\nan.1dn2\nann\nann\n(a）下三角矩阵\n(b)上三角矩阵\n图3.22\n2三角矩阵\n在数组B中，位于元素aij（i≤j）前面的元素个数为\n第1行：n个元素\n第2行：n-1个元素\n第i-1行：n-i+2个元素\n第i行：j-i个元素\n因此，元素ay在数组B中的下标\nk=n+(n-1)+…+(n-i+2)+(j-i+1)-1=(i-1)(2n-i +2)/2+(j-i)\n因此，元素下标之间的对应关系如下：\n(i-1)(2n-i+2)\n+(i-i),\ni≤j（上三角区和主对角线元素）\n2\nK\nn(n+1)\ni>j(下三角区元素)\n2\n上三角矩阵在内存中的压缩存储形式如图3.23所示。\n0\nn(n+1)/2\na1.aa1aa2.2a2.3a2.\n….anc\n第1行\n第2行\n第n行常数项\n图3.23上三角矩阵的压缩存储\n以上推导均假设数组的下标从0开始，若题设有具体要求，则应该灵活应对。\n3.三对角矩阵\n公众号：小兔网盘免费分享无水印PDF\n对角矩阵也称带状矩阵。对n阶矩阵A中的任意一个元素aij，当li-川>1时，若有aij=0\n（1≤i,j≤n），则称为三对角矩阵，如图3.24所示。在三对角矩阵中，所有非零元素都集中在以主\n对角线为中心的3条对角线的区域，其他区域的元素都为零。\naa1.2\na2.1\na22a2.3\nd32\na3.3\n3.4\nan-1n-2an-1n-1an-1n\nann-1\nan.n]\n图3.24三对角矩阵A\n三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B\n中，且a11存放于B[0]中，其存储形式如图3.25所示。\naaa2\na2.2\na2.3\n...\nan-1.nann-1\nann\n图3.25三对角矩阵的压缩存储\n口\n公众号：小兔网盘\n免费网课+无水印PDF\n\n104\n2026年数据结构考研复习指导\n命题追踪三对角矩阵压缩存储的下标对应关系（2016）\n由此可以计算矩阵A中3条对角线上的元素a，（1≤i,j≤n,li-≤1）在一维数组B中存放\n的下标为k=2i+j-3。\n反之，若已知三对角矩阵中的某个元素a，存放在一维数组B的第k个位置，则有i=L（k+1)/3+1]，\nj=k-2i+3。例如，当k=0时，i=L(0+1)/3+1」=1，j=0-2x1+3=1，存放的是ai1；当k=\n2时，i=L（2+1）3+1]=2，j=2-2×2+3=1，存放的是a2.1；当k=4时，i=L（4+1)/3+1]=2，\nj=4-2×2+3=3，存放的是α2.3",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ]
    },
    {
        "id": "kc0344",
        "title": "稀疏矩阵",
        "chapter_id": "c03",
        "description": "矩阵中非零元素的个数1，相对矩阵元素的个数s来说非常少，即s》1的矩阵称为稀疏矩阵。\n例如，一个矩阵的阶为100×100，该矩阵中只有少于100个非零元素。\n命题追踪存储稀疏矩阵需要保存的信息（2023）\n若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零\n元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将\n非零元素及其相应的行和列构成一个三元组（行标i，列标j，值au），如图3.26所示。然后按照\n某种规律存储这些三元组线性表。稀疏矩阵压缩存储后便失去了随机存取特性。\nj\naij\n4000\n0\n0\n4\n0060\n对应的三元组\nM=\n1\n6\n0900\n2\n9\n[0 23 0 0]\n3\n1\n23\n图3.26稀疏矩阵及其对应的三元组\n命题追踪适合稀疏矩阵压缩存储的存储结构（2017）\n稀疏矩阵的三元组表既可以采用数组存储，又可以采用十字链表存储（见6.2节）。当存储稀\n疏矩阵时，不仅要保存三元组表，而且要保存稀疏矩阵的行数、列数和非零元素的个数。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ]
    }
]