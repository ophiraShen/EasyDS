[
    {
        "id": "kc0411",
        "title": "串的定义",
        "chapter_id": "c04",
        "description": "串（string）是由零个或多个字符组成的有限序列。一般记为\nS='aa..·a(n≥0)\n其中，S是串名，单引号括起来的字符序列是中的值；a可以是字母、数字或其他字符：串中字\n符的个数n称为串的长度。n=0时的串称为空串（用表示）。\n串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。某个字\n①本节不在统考大纲范围，仅供学习参考。\n\n110\n2026年数据结构考研复习指导\n符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第1个字符在主串中\n的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。\n例如，有串A='China Beijing'，B='Beijing'，C='China'，则它们的长度分别为\n13、7和5。B和C是A的子串，B在A中的位置是7，C在A中的位置是1。\n长度为串中空格字符的个数。\n串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，\n串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除\n某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": []
    },
    {
        "id": "kc0412",
        "title": "串的基本操作",
        "chapter_id": "c04",
        "description": "·StrAssign（&T，chars）：赋值操作。把中T赋值为chars。\n·StrCopy（&T，S）：复制操作。由串s复制得到串T。\n·StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。\n·StrCompare(S,T)：比较操作。若 S>T，则返回值>O；若S=T，则返回值=O；若 S<T，\n则返回值<0。\n·StrLength（S）：求串长。返回串s的元素个数。\n·SubString（&Sub,S,pos，len)：求子串。用 Sub 返回串 s 的第 pos 个字符起长度为\nlen的子串。\n·Concat（&T,S1,S2）：串联接。用T返回由 S1和 S2联接而成的新串。\n·Index（S，T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中\n第一次出现的位置：否则函数值为0。\n·ClearString（&S）：清空操作。将s清为空串。\n·DestroyString(&S）：销毁串。将串 s销毁。\n不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值\nStrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串 SubString\n五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串\n操作（除中清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": []
    },
    {
        "id": "kc0413",
        "title": "串的存储结构",
        "chapter_id": "c04",
        "description": "1.定长顺序存储表示\n类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。在中的\n定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。\n#define MAXLEN 255\n//预定义最大串长为255\ntypedef struct{\nchar ch[MAXLEN];\n/每个分量存储一个字符\nint length;\n/串的实际长度\n)sString;\n串的实际长度只能小于或等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。串长\n有两种表示方法：一是如上述定义描述的那样，用一个额外的变量1en来存放串的长度；二是在\n串值后面加一个不计入串长的结束标记字符“\\0”，此时的串长为隐含值。\n在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界MAXLEN，约定用“截\n\n第4章串\n111\n断”法处理，要克服这种端，只能不限定串长的最大长度，即采用动态分配的方式。\n2.堆分配存储表示\n堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是\n在程序执行过程中动态分配得到的。\ntypedef struct{\nchar *ch;\n/按串长分配存储区，ch指向串的基地址\nint length;\n//串的长度\n)HString;\n在C语言中，存在一个称为堆的自由存储区，并用malloc（）和free（）函数来完成动态存\n储管理。利用malloc（）为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则\n返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来指示；若分配失败，则返\n回NULL。已分配的空间可用free（）释放掉。\n上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。\n3.块链存储表示\n类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只\n有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点\n称为块，整个链表称为块链结构。图4.1(a)是结点大小为4（每个结点存放4个字符）的链表，最\n后一个结点占不满时通常用“#”补上：图4.1(b)是结点大小为1的链表。\nnead\nABCDEFGH>I###A\n（a）结点大小为4的链表\nB→\n（b）结点大小为1的链表\n图4.1串值的链式存储方式\n4.2串的模式匹配",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": []
    },
    {
        "id": "kc0421",
        "title": "简单的模式匹配算法",
        "chapter_id": "c04",
        "description": "模式匹配是指在主串中找到与模式串（想要搜索的某个字符串）相同的子串，并返回其所在\n的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。\nint Index(SString S,SString T){\nint i=1,j=1;\nwhile(i<=s.length&&j<=T.length)(\nif(S.ch[i]==T.ch[j]){\n++i;++j;\n1//继续比较后继字符\nelser\ni=i-j+2;j=1;\n//指针后退重新开始匹配\n）\nif(j>T.length)return i-T.length;\nelse return 0;\n在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前待比较的字符位置。\n\n112\n2026年数据结构考研复习指导\n算法思想是：从主串S的第一个字符起，与模式串T的第一个字符比较，若相等，则继续逐个比\n较后续字符；否则从主串的下一个字符起，再重新和模式串T的字符比较；以此类推，直至模式\n串T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式\n串T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。\n图4.2展示了模式串T='abcac'和主串s的匹配过程。\n1=3\n第一趟匹配\nab\nap\nab\n↑j=3\ni=2\n第二趟匹配\nab\ni=7\n第三趟匹配\nabc\ni=4\n第四趟匹配ab\ni=5\n第五趟匹配aba\n=\n图4.2简单模式匹配算法举例\n在简单模式匹配算法中，设主串和模式串的长度分别为n和m（n》m），则最多需要进行n-m+1\n趟匹配，每趟最多需要进行m次比较，最坏时间复杂度为O（nm）。例如，当模式串为+0000001+而\n主中为：0000000000000000000000000000000000000000000001·时，由于模式串中的前6\n个字符均为＇0＇，主串中的前45个字符均为+0＇，每趟匹配都是比较到模式串中的最后一个字符时才\n发现不等，整个匹配过程中指针i需要回溯39次，总比较次数为40x7=280次。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ]
    },
    {
        "id": "kc0422",
        "title": "串的模式匹配算法一一KMP算法",
        "chapter_id": "c04",
        "description": "在图4.2的第三趟匹配过程中，i=7、j=5 的字符比较，结果不等，于是又从i=4、j=1重新\n开始比较。然而，仔细观察会发现，i=4和j=1、i=5和j=1以及i=6和j=1这三次比较都是不\n必进行的。从第三趟部分匹配的结果可知，主串的第4个、第5介、第6个字符是'b'、'c'、'a\"\n（模式串的第2、第3、第4个字符），因为模式串的第1个字符是+a＇，所以再和这三个字符进行比\n较纯属多余，而只需将模式串向右滑动三个字符的位置，再进行i=7、j=2的比较即可。\n在简单模式匹配算法中，每趟匹配失败都是模式串向右滑动一位后从头开始比较的。而某趟\n已匹配相等的字符序列是模式串的某个前缀，因此可从分析模式串本身的结构着手，若已匹配相\n等的前缀序列中有某个后缀正好是模式串的前缀，则可将模式中向右滑动到与这些相等字符对齐\n\n第4章串\n113\n的位置（也是后面手算next数组的依据），主串指针i无须回溯，并从该位置开始继续比较。\n而模式串向右滑动位数的计算仅与模式串本身的结构有关，与主串无关。\n1.KMP算法的原理\n要了解模式串的结构，首先要弄清楚几个概念：前缀、后缀和部分匹配值。前缀是指除最后\n个字符外，字符串的所有头部子串；后缀是指除第一个字符外，字符串的所有尾部子中：部分\n匹配值则是指字符串的前缀和后缀的最长相等前后缀长度。下面以+ababa+为例进行说明：\n·+a+的前缀和后缀都为空集，最长相等前后缀长度为0。\n·'ab'的前缀为{a}，后缀为{b}，{a}n{b}=，最长相等前后缀长度为0。\n'aba'的前缀为{a，ab}，后缀为{a,ba}，{a，ab}n{a，ba}={a}，最长相等前后缀长\n度为1。\n'abab'的前缀{a,ab，aba}n后缀{b，ab，bab}={ab}，最长相等前后缀长度为2。\n'ababa'的前缀{a，ab，aba，abab}n后缀{a，ba，aba，baba}={a,aba)，公共元素有\n两个，最长相等前后缀长度为3。\n因此，模式串'ababa'的部分匹配值为00123。\n这个部分匹配值有什么作用呢？\n回到最初的问题，主串为'ababcabcacbab'，模式串为'abcac'。\n式，就得到了部分匹配值（PartialMatch，PM）的表。\n编号\nS\nPM\n下面用PM表来进行字符串匹配：\n主串\na\nb\na\n模式串\nb\n第一趟匹配过程：\n发现c与a不匹配，前面的2个字符+ab+是匹配的，查表可知，最后一个匹配字符b对应\n的部分匹配值为0，因此按照下面的公式算出模式串需要的右滑位数：\n右滑位数=已匹配的字符数－对应的部分匹配值\n因为2-0=2，所以将模式串向右滑动2位如下，进行第二趟匹配：\n主串\n模式串\n第二趟匹配过程：\n发现c与b不匹配，前面的4个字符！abca'是匹配的，查表可知，最后一个匹配字符a对\n应的部分匹配值为1，4-1=3，将模式串向右滑动3位如下，进行第三趟匹配：\n主串\n模式串\n第三趟匹配过程：\n模式串全部比较完成，匹配成功。整个匹配过程中，主串始终没有回退，所以KMP算法可\n在O(n+m)的时间数量级上完成串的模式匹配操作，大大提高了匹配效率。\n\n114\n2026年数据结构考研复习指导\n某趟发生失配时，若已匹配相等的序列中没有相等的前后缀，则对应的部分匹配值为0，此\n时滑动的位数最大，直接将模式串首字符向右滑动到主串当前位置进行下一趟比较；若已匹配相\n等的序列中存在最大相等前后缀（可理解为首尾重合），则将模式串向右滑动到和主中中该相等\n后缀对齐（这些重合的字符下一趟显然无需再比较），然后从主串当前位置进行下一趟比较。两\n还有一种特例，在上述举例中并未出现，当某趟第一个字符比较就失配时，应如何处理呢？\n此时，应让模式串向右滑动一位，再从主串当前位置的下一位开始比较。\n2.next数组的手算方法\n在实际的匹配过程中，模式串在内存中是不会滑动的，发生变化的是指针，前面的举例只\n是手动模拟KMP算法的过程，也是为了让读者更为形象地进行理解。\n命题追踪KMP算法中指针变化、比较次数的分析（2015、2019）\n每趟匹配失败时，只有模式串指针i在变化，主串指针j不会回溯，为此可以定义一个next\n数组，next[j］的含义是当模式中的第j个字符失配时，跳到next[j]位置继续比较。\n下面给出一种求next数组的手算方法，仍以模式中'abcac'为例。\n位置与主串当前位置的下一位置进行比较（注意，图中的下标为模式中编号）。\n匹配失败，说明此元素不是a\n主串\n回\n回\n模式串\na1\nb2\nC3\na4\nC5\n第2个字符失配时，令next[2]=1，模式串的下次比较位置为1，相当于向右滑动1位。\n注，模式串的next[1]=0、next[2]=1都是固定不变的。\n匹配失败，说明此元素不是b\n主串\n回\n回\n?\n?\na\n模式串\na1\nb2\nC3\na4\nC5\n右滑\na1\nb2\nC3\na4\nC5\n在后面的手算过程中，在不匹配的位置前画一条分界线，模式串一步一步往后退，直到分\n界线之前能对上（首尾重合），或模式串完全跨过分界线为止。\n第3个字符失配时，模式串的下次比较位置为1，即next[3]=1，相当于向右滑动2位。\n匹配失败，说明此元素不是c\n主串\nb\n回\n模式串\nai\nb2\nC3\na4\nC5\n右滑\na1\nb2\nC3\na4\nC5\n第4个字符失配时，模式串的下次比较位置为1，即next[4]=1，相当于向右滑动3位。\n匹配失败，说明此元素不是a\n主串\n回\nb\n模式串\nb2\nC3\na4\nC5\n右滑\na1\nC3\na4\n\n第4章串\n115\n第5个字符失配时，模式串的下次比较位置为2，即next[5]=2，相当于向右滑动3位。\n匹配失败，说明此元素不是c\n主串\nh\n模式串\na1\nb2\nC3\na\nC5\n右滑\na\nb2\nnext数组和PM表的关系是怎样的?\n通过上述举例，可以推理出next数组和PM表之间的关系：\nnext[j］=j-右滑位数=j-(已匹配的字符数-对应的部分匹配值)\n=j-[(j-1）-PM[j-1]]\n=PM[j-1]+1\n根据上述结论，将模式串，abcac+的PM表右移一位，并整体加1，就得到了模式串+abcac\n对应的next数组，通过与前面手算的结果比较，可以验证上述结论。\n编号\n1\n2\n3\n4\nS\na\nb\nC\na\nnext\n0\n1\n1\n2\n我们注意到：\n1）第一个元素右滑以后空缺的用0来填充，因为若是第一个元素匹配失败，则需要将主串\n指针和模式串指针同步右移一位，从而不需要计算模式串指针移动的位数。\n2）最后一个元素在右滑的过程中溢出，因为原来的模式串中，最后一个元素的部分匹配值\n是其下一个元素使用的，但显然已没有下一个元素，所以可以舍去。\n注\n意\n上述KMP算法的举例中，都假设串的编号是从1开始的；若串的编号是从0开始的，则next数\n组需要整体减1。\n*3.next数组的推理公式\n第1个字符与模式串的第个字符失配时，应让主串当前位置与模式串的哪个字符进行比较？\n假设此时应与模式串的第k（k<j）个字符进行比较，则模式串的前k-1个字符的子串必须\n满足下列条件，且不可能存在k'>k满足下列条件：\n'p1p2.pk-1'='pj-k+1Pj-k+2..·pj-1'\n若存在满足如上条件的子串，则发生失配时，仅需将模式串的第k个字符和主串的第i个字\n符对齐，此时模式串的前k-1个字符的子串必定与主串的第i个字符之前长度为k-1的子串相\n等，因此，只需从模式串的第k个字符与主串的第i个字符进行比较即可，如图4.3所示。\n主串\nS1\nSi-k+1\nSi-1\n#\nS\n子串\nP1\npk-1\nPj-k+1\nPj-1\nPm\n右滑\nP1\n...\nPk-1pk\nPm\n图4.3模式串右滑到合适位置（阴影对齐部分表示上下字符相等）\n①注意，当模式串匹配到位置j失配时，已匹配成功的字符数为j-1。\n\n116\n2026年数据结构考研复习指导\n当模式串已匹配相等序列中不存在满足上述条件的子串时（可视为k=1），显然应让主串的\n第i个字符和模式串的第1个字符进行比较。\n当模式串的第1个字符（j=1）与主串的第i个字符发生失配时，规定next[1]=0。\n通过上述分析可以得出next函数的公式：\n0，\nj=1\nnext[j]=\nmax{k|1<k<j且'p*Px-=P-x+\"P-+），当此集合不为空时\n[1,\n其他情况\n要用代码来实现，难度貌似还不小，下面来尝试推理求解的科学步骤。\n首先由公式可知\nnext[1]=0\n设next[j]=k，此时k应满足的条件在上文中已描述。\n此时next[j+1]=？可能有两种情况：\n（1）若pk=P，则表明在模式串中\np1...pk-ipk'=pj-k+1·.pj-iPj\n且不可能存在k'>k满足上述条件，此时 next[j+1]=k+1，即\nnext[j+l]=next[j]+1\n（2）若pk≠P，则表明在模式串中\ndt-d...+x-d.d-d...d\n匹配，当 pk≠pg 时，应将 pi\".pk 向右滑动至用第 next [k]个字符与 p;进行比较，若 Pnext[k]\n与 pg 仍不匹配，则需要寻找长度更短的相等前后缀，下一步继续用 Pnext[next[kj)与 p 进行较，\n以此类推，直到找到某个更小的k'=next[next…·[k]]（1<k'<k<j)，满足条件\n'p1..pk='pj-k+1..·pj'\n则next[j+1]=k'+1。\n也可能不存在任何k'满足上述条件，即不存在长度更短的相等前后缀，令next[j+1]=1\n理解起来有点儿费劲？下面举一个简单的例子。\n图4.4 的模式串中已求得6个字符的 next 值,现求 next[7],因为 next[6]=3,又 po≠p3,\n所以需要比较p6和p（因next[3]=1），p6≠p1，而next[1]=0，因此next[7]=1;求next[8]，\n因为p=P1，所以next[8]=next[7]+1=2；求next[9]，因为p=p2，所以next[9]=3。\n1\n2\n34\n5\n模式串\nal\nb\nnext[j]\n0112232\n图4.4求模式串的next值\n*4.KMP算法的实现\n通过上述分析写出求next值的程序如下：\nvoid get_next(sString T,int next[]){\ninti=1,j=0;\nnext[1]=0;\nwhile(i<T.length){\nif（j==011T.ch[i]==T.ch[j]){\n++i;++j；\nnext[i]=j;//若p=pj，则 next[j+1]=next[j]+1\n\n第4章串\n117\nelse\nj=next[j]；//否则令j=next[j]，循环继续\n计算机执行起来效率很高，但需要手工计算时，仍然采用前面的方法。\n与next数组的求解相比，KMP的匹配算法相对要简单很多，它在形式上与简单的模式匹配\n算法很相似。不同之处仅在于当匹配过程产生失配时，指针i不变，指针j退回到next[j］的\n位置并重新进行比较，且当指针j为0时，指针i和j同时加1。也就是说，若主串的第i个位\nint Index_KMP(SString S,SString T,int next[]){\ninti=1,j=1;\nwhile(i<=s.length&&j<=T.length)(\nif（j==0l|S.ch[i]==T.ch[j]）{\n++i;++j;\n//继续比较后继字符\nelse\nj=next[j];\n//模式串向右滑动\nif(j>T.length)\nreturn i-T.length;\n//匹配成功\nelse\nreturn 0;\n况下，普通模式匹配的实际执行时间复杂度近似为O（m+n)，因此至今仍被采用。KMP算法仅在\n主串与子串有很多“部分匹配”时才显得比普通算法快，其主要优点是主串不回溯。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ]
    },
    {
        "id": "kc0423",
        "title": "KMP算法的进一步优化",
        "chapter_id": "c04",
        "description": "前面定义的next数组在某些情况下尚有缺陷，还可以进一步优化。如图4.5所示，模式中\n主串\n模式串\nj\nnext[j]\nnextval[j]\n0\n图4.5KMP算法进一步优化示例\n当i=4、j=4 时，s4跟p4（b≠a）失配，若用之前的 next 数组，则还需要进行 s4与p3、S4\n与 p2、S4与 p1这 3次比较。事实上，因为 Pnext[4]=3=P4=a、Pnext[3]=2=P3=a、Pnext[2]=1=P2=a,\n显然后面3次用一个和p4相同的字符跟s4比较毫无意义，必然失配。那么问题出在哪里呢？\n问题在于不应该出现 pj=Pnext[ij]。理由是：当 p;≠s时，下次匹配必然是 Pnext[j]跟 s比较，\n若 p=Pnext[j]，则相当于拿一个和pg 相等的字符跟 s比较，这必然导致继续失配，这样的比较毫\n无意义。若出现p=Pnext[j]，则如何处理呢？\n等为止，更新后的数组命名为nextval。计算next数组修正值的算法如下，此时匹配算法不变。\nvoid get_nextval(sstring T,int nextval[]){\n\n118\n2026年数据结构考研复习指导\nint i=1，j=0;\nnextval[1]=0;\nwhile(i<T.length){\nif(j==01|T.ch[i]==T.ch[j]){\n++i;++j;\nif(T.ch[i]!=T.ch[j])\nnextval[i]=j;\nelsenextval[i]=nextval[j];\nelse\nj=nextval[j];\nKMP算法对于初学者来说可能不太容易掌握，建议读者结合王道课程来理解。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ]
    }
]