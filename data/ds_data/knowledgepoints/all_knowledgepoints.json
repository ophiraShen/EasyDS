[
    {
        "id": "kc0111",
        "title": "基本概念和术语",
        "chapter_id": "01",
        "description": "1.数据\n数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程\n序识别和处理的符号的集合。数据是计算机程序加工的原料。\n2.数据元素\n据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，\n它由学号、姓名、性别等数据项组成。\n\n2026年数据结构考研复习指导\n3.数据对象\n数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集\n合N={0,±1,±2,.·}。\n4.数据类型\n数据类型是一个值的集合和定义在此集合上的一组操作的总称。\n1）原子类型。其值不可再分的数据类型。\n2）结构类型。其值可以再分解为若干成分（分量）的数据类型。\n3）抽象数据类型（ADT）。一个数学模型及定义在该数学模型上的一组操作。它通常是对数\n据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合。\n5.数据结构\n数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素\n都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。\n数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。\n数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结\n构，而算法的实现依赖于所采用的存储结构?。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "extension"
            },
            {
                "id": "kc0121",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "extension"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "extension"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0342",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q011002",
            "q011003",
            "q011004",
            "q011005",
            "q012001"
        ],
        "summry": "**数据**\n**定义**：信息的载体，可被计算机程序处理的符号集合（数、字符等），是程序加工的原料。\n**数据元素**\n**定义**：数据的基本单位，由若干**数据项**（不可分割的最小单位）组成。\n**示例**：学生记录（数据元素）包含学号、姓名、性别等数据项。\n**数据对象**\n**定义**：相同性质数据元素的集合，是数据的子集。\n**示例**：整数数据对象为集合 `N={0, ±1, ±2, ...}`。\n**数据类型**\n**定义**：值的集合及其上定义的操作总称。\n**分类**：\n1. **原子类型**：值不可再分（如`int`）。\n2. **结构类型**：值可分解为多个成分（如`struct`）。\n3. **抽象数据类型（ADT）**：数学模型及操作集合（如栈、队列的接口定义）。\n**数据结构**\n**定义**：数据元素的集合及其间的特定关系，包含三方面：\n1. **逻辑结构**：数据间的抽象关系（线性、树形、图等）。\n2. **存储结构**：逻辑结构在计算机中的实现（顺序存储、链式存储等）。\n3. **数据运算**：对数据的基本操作（插入、删除、查找等）。\n- **关键点**：算法设计依赖逻辑结构，实现依赖存储结构。\n**记忆提示**：\n- 数据元素≈实体，数据项≈属性；ADT≈接口，数据结构≈接口+实现。"
    },
    {
        "id": "kc0112",
        "title": "数据结构三要素",
        "chapter_id": "01",
        "description": "1.数据的逻辑结构\n逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，\n是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构：集\n合、树和图是典型的非线性结构。数据的逻辑结构分类如图1.1所示。\n数据的逻辑结构\n线性结构\n非线性结构\n受限线性表\n线性表推广\n集合\n树形结构\n图状结构\n般线性表\n栈和队列\n数组\n般树\n义树\n有向图\n无向图\n图1.1数据的逻辑结构分类\n1）集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系，如图1.2（a)所示。\nolololololo\noo\n(a)集合\n(b)线性结构\n(d)网状结构\n(c)树形结构\n图1.2四类基本结构关系示例图\n2）线性结构。结构中的数据元素之间只存在一对一的关系，如图1.2（b)所示。\n3）树形结构。结构中的数据元素之间存在一对多的关系，如图1.2（c)所示。\n①读者应通过后续章节的学习，逐步理解设计与实现的概念与区别。\n\n第1章绪\n论\n3\n4）图状结构或网状结构。结构中的数据元素之间存在多对多的关系，如图1.2（d)所示。\n2.数据的存储结构\n存储结构是指数据结构在计算机中的表示（也称映像），也称物理结构。它包括数据元素的\n表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数\n据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。\n1）顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关\n系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存\n储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。\n2）链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指\n针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元：\n缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。\n3）索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，\n索引项的一般形式是（关键字，地址）。其优点是检索速度快：缺点是附加的索引表额外\n占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n4）散列存储。根据元素的关键字直接计算出该元素的存储地址，也称哈希（Hash）存储。\n其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元\n素存储单元的冲突，而解决冲突会增加时间和空间开销。\n3.数据的运算\n施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功\n能；运算的实现是针对存储结构的，指出运算的具体操作步骤。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0231",
                "relation_type": "extension"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0311",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0321",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0335",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "extension"
            },
            {
                "id": "kc0342",
                "relation_type": "extension"
            },
            {
                "id": "kc0343",
                "relation_type": "extension"
            },
            {
                "id": "kc0344",
                "relation_type": "extension"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0511",
                "relation_type": "extension"
            },
            {
                "id": "kc0513",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0552",
                "relation_type": "extension"
            },
            {
                "id": "kc0611",
                "relation_type": "extension"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            },
            {
                "id": "kc0624",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "extension"
            },
            {
                "id": "kc0643",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "extension"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            },
            {
                "id": "kc0751",
                "relation_type": "extension"
            },
            {
                "id": "kc0752",
                "relation_type": "extension"
            },
            {
                "id": "kc0753",
                "relation_type": "extension"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q011002",
            "q011003",
            "q011004",
            "q011005",
            "q012001"
        ],
        "summry": "**数据结构三要素**\n### **1. 数据的逻辑结构**\n- **定义**：数据元素之间的逻辑关系，与存储无关，独立于计算机。\n- **分类**：\n- **线性结构**：元素间一对一关系（如**线性表**、**栈**、**队列**）。\n- **非线性结构**：\n- **集合**：元素仅“同属一个集合”，无其他关系。\n- **树形结构**：一对多关系（如**一般树**、**二叉树**）。\n- **图状结构**：多对多关系（如**有向图**、**无向图**）。\n### **2. 数据的存储结构**\n- **定义**：逻辑结构在计算机中的物理实现，依赖具体语言。\n- **类型**：\n- **顺序存储**：\n- 元素物理位置相邻，通过邻接关系体现逻辑关系。\n- **优点**：随机存取高效，空间占用少。\n- **缺点**：易产生外部碎片，需连续内存。\n- **链式存储**：\n- 通过指针链接逻辑相邻元素，物理位置可分散。\n- **优点**：无碎片，灵活利用内存。\n- **缺点**：额外指针开销，仅支持顺序存取。\n- **索引存储**：\n- 附加索引表（关键字+地址）加速检索。\n- **优点**：查询快。\n- **缺点**：索引表占用空间，增删需维护索引。\n- **散列存储（哈希）**：\n- 通过散列函数直接计算存储地址。\n- **优点**：增删查高效。\n- **缺点**：哈希冲突需额外处理（开放寻址、链地址法）。\n### **3. 数据的运算**\n- **运算定义**：基于逻辑结构，描述功能（如“插入”“删除”）。\n- **运算实现**：基于存储结构，定义具体操作步骤（如顺序表的`O(1)`随机访问 vs 链表的`O(n)`遍历）。\n**记忆提示**：\n- **逻辑结构**：“线性≈排队，树≈家谱，图≈社交网络”。\n- **存储结构**：“顺序≈数组，链式≈火车车厢，索引≈目录，散列≈快递柜”。"
    },
    {
        "id": "kc0121",
        "title": "算法的基本概念",
        "chapter_id": "01",
        "description": "算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指\n令表示一个或多个操作。此外，一个算法还具有下列五个重要特性：\n1）有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。\n2）确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n3）可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n4）输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n\n第1章绪\n论\n5\n5）输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n通常，设计一个“好”的算法应考虑达到以下目标：\n1）正确性。算法应能够正确地解决求解问题。\n2）可读性。算法应具有良好的可读性，以帮助人们理解。\n3）健壮性。算法能对输入的非法数据做出反应或处理，而不会产生莫名其妙的输出。\n4）高效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所\n需要的最大存储空间，这两者都与问题的规模有关。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "related"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "extension"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0811",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0831",
                "relation_type": "extension"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0841",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "extension"
            },
            {
                "id": "kc0852",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q012002",
            "q012004",
            "q012005",
            "q012006",
            "q012007",
            "q012009",
            "q012012",
            "q012013",
            "q012014"
        ],
        "summry": "**算法的基本概念**\n- **定义**：算法是解决特定问题的**有限指令序列**，每条指令表示一个或多个明确的操作。\n- **五大特性**：\n1. **有穷性**：必须在有限步骤后终止，且每步执行时间有限。\n2. **确定性**：相同输入必得相同输出，指令无二义性。\n3. **可行性**：可通过基本运算（如加减、比较）的有限次实现。\n4. **输入**：零个或多个输入，取自特定集合（如数组、整数）。\n5. **输出**：至少一个输出，与输入存在特定关系（如排序后的数组）。\n- **好算法的目标**：\n1. **正确性**：严格满足问题需求。\n2. **可读性**：逻辑清晰，便于理解和维护。\n3. **健壮性**：处理非法输入（如负数输入时提示错误）。\n4. **效率与低存储**：\n- **时间效率**：执行时间与问题规模的关系（如**O(n²)**）。\n- **空间效率**：最大内存占用（如递归的栈空间消耗）。\n- **记忆提示**：算法特性记作“有确可行，输入输出”；好算法标准为“正确可读健壮高效”。"
    },
    {
        "id": "kc0122",
        "title": "算法效率的度量",
        "chapter_id": "01",
        "description": "命题追踪）（算法题）分析时空复杂度（2010—2013、2015、2016、2018—2021）\n算法效率的度量是通过时间复杂度和空间复杂度来描述的。\n1．时间复杂度\n命题追踪分析算法的时间复杂度（2011—2014、2017、2019、2022）\n一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为\nT(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算（最\n深层循环中的语句）的频度与T(n)同数量级，因此通常将算法中基本运算的执行次数的数量级作\n为该算法的时间复杂度?。于是，算法的时间复杂度记为\nT(n)= O(f(n))\n式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和fn)是定义在正整数集合上的\n两个函数，则存在正常数 C和no，使得当n≥no时，都满足0≤ T(n)≤Cf(n)。\n算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素\n的初始状态）。例如，在数组A[0...n-1]中，查找给定值k的算法大致如下：\n(1)i=n-1;\n(2）while（i>=0&&(A[i]!=k))\n(3)\ni--;\n(4)returni;\n该算法中语句3（基本运算）的频度不仅与问题规模n有关，而且与下列因素有关：\n①若A中没有与k相等的元素，则语句3的频度f(n)=n。\n②若A的最后一个元素等于k，则语句3的频度f（n)是常数0。\n最坏时间复杂度是指在最坏情况下，算法的时间复杂度。\n平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。\n最好时间复杂度是指在最好情况下，算法的时间复杂度。\n一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。\n在分析一个程序的时间复杂性时，有以下两条规则：\n1) 加法规则: T(n)= T(n) + T2(n)= O(f(n)) + O(g(n)= O(max(f(n), g(n))\n2） 乘法规则： T(n)= T(n)xT2(n)= O(f(n))xO(g(n))=O(f(n)xg(n))\n例如，设a{}、b{)、c{}三个语句块的时间复杂度分别为O(1)、O(n)、O(n²)，则\n①al\n(q\nc()\n//时间复杂度为O(²)，满足加法规则\n①取f（n）中随n增长最快的项，将其系数置为1作为时问复杂度的度量。例如，f（n）=an²+bn²+cn的时问复杂度为O（n²)。\n\n2026年数据结构考研复习指导\n6\n②\na\nb(\nc()\n/时间复杂度为0（n²)，满足乘法规则\n常见的渐近时间复杂度为\n0(1) <0(log2n)<0(n)<0(nlog2n) < 0(n²)<0(n²) <0(2\") <0(n!) <0(n\")\n2.空间复杂度\n算法的空间复杂度S(n)定义为该算法所需的存储空间，它是问题规模n的函数，记为\nS(n) = 0(g(n))\n一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需\n要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占\n空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。例如，若算法\n中新建了几个与输入数据规模n相同的辅助数组，则空间复杂度为O(n)。\n算法原地工作是指算法所需的辅助空间为常量，即O(1)。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0831",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0841",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "extension"
            },
            {
                "id": "kc0853",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q012002",
            "q012004",
            "q012005",
            "q012006",
            "q012007",
            "q012009",
            "q012012",
            "q012013",
            "q012014"
        ],
        "summry": "**算法效率的度量**\n**定义**：通过**时间复杂度**和**空间复杂度**定量描述算法执行效率。\n**核心概念**：\n**时间复杂度**：\n**频度**：语句在算法中的重复执行次数，所有语句频度之和为 **T(n)**（问题规模 **n** 的函数）。\n**基本运算**：最深层循环语句的频度决定 **T(n)**的数量级，记为**T(n) = O(f(n))**。\n**最坏/平均/最好时间复杂度**：分别对应输入数据的最不利、等概率、最有利情况。\n**分析规则**：\n1.**加法规则**：**O(f(n)) + O(g(n)) = O(max(f(n), g(n)))**。\n2. **乘法规则**：**O(f(n)) × O(g(n)) = O(f(n) × g(n))**。\n**简化原则**：取增长最快的项并忽略系数（如 **an³ + bn² → O(n³)**）。\n**常见阶数**：**O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)**。\n**空间复杂度**：\n**定义**：算法所需的存储空间 **S(n) = O(g(n))**，通常指**额外辅助空间**（排除输入和程序本身）。\n**原地工作**：辅助空间为常量（**O(1)**）。\n**关键点**：\n时间复杂度依赖**问题规模 n** 和**输入数据性质**（如查找算法中目标值的位置）。\n**优先分析最坏时间复杂度**以确保算法性能下限。\n空间复杂度关注**额外数据结构**（如辅助数组规模）。\n**示例**：\n```c\n// 时间复杂度分析\nfor (int i = 0; i < n; i++) {       // O(n)\nfor (int j = 0; j < n; j++) {   // O(n) × O(n) = O(n²)\nprintf(\"%d\", i + j);        // 基本运算\n}\n}\n```\n**快速记忆**：\n时间：**循环嵌套用乘法，并列用加法**。\n空间：**新建多少额外数据，复杂度就是多少**。"
    },
    {
        "id": "kc0211",
        "title": "线性表的定义",
        "chapter_id": "02",
        "description": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n=0\n时线性表是一个空表。若用L命名线性表，则其一般表示为\nL =(a1, a2,..., ai, ai+1,..., an)\n式中，α是唯一的“第一个”数据元素，也称表头元素；a是唯一的“最后一个”数据元素，也\n称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素\n有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。\n以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。\n\n第2章线性表\n13\n由此，我们得出线性表的特点如下：\n·表中元素的个数有限。\n·表中元素具有逻辑上的顺序性，表中元素有其先后次序。\n·表中元素都是数据元素，每个元素都是单个元素。\n·表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。\n·表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。\n注意\n线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于\n不同层面的概念，因此不要将其混淆。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "extension"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0231",
                "relation_type": "extension"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0311",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "extension"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q021001",
            "q021003",
            "q021004"
        ],
        "summry": "**线性表的定义**\n- **定义**：由**相同数据类型**的**n（n≥0）**个数据元素组成的**有限序列**，当n=0时为空表。逻辑表示为 `L=(a₁, a₂, ..., aᵢ, ..., aₙ)`。\n- **关键特性**：\n- **有序性**：元素按线性顺序排列，`a₁`为**表头元素**（唯一无前驱），`aₙ`为**表尾元素**（唯一无后继）。\n- **前驱后继**：除首尾外，每个元素有且仅有**一个直接前驱**和**一个直接后继**。\n- **数据约束**：元素类型相同、存储空间相同，仅关注逻辑关系（抽象性）。\n- **逻辑结构特点**：\n- 有限元素个数、严格顺序性、元素为原子数据（不可再分）。\n- **注意**：\n- 线性表是**逻辑结构**，与存储结构（顺序表/链表）区分。顺序表≈数组，链表≈指针链接。\n- **记忆提示**：\n- “线性表≈排队”，元素像队伍中的人，前后关系严格且唯一。"
    },
    {
        "id": "kc0212",
        "title": "线性表的基本操作",
        "chapter_id": "02",
        "description": "一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基\n本操作来实现。线性表的主要操作如下。\n·InitList（&L)：初始化表。构造一个空的线性表。\n·Length（L)：求表长。返回线性表L的长度，即L 中数据元素的个数。\n·LocateElem（L，e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n·GetElem（L，i)：按位查找操作。获取表L中第i个位置的元素的值。\n·ListInsert（&L，i，e）：插入操作。在表L中的第i个位置上插入指定元素e。\n·ListDelete（&L，i，&e）：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n·PrintList（L)：输出操作。按前后顺序输出线性表L的所有元素值。\n·Empty(L)：判空操作。若L为空表，则返回true，否则返回 false。\n·DestroyList（&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\n注意\n①基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也不同。②符号“&”表示\nC++语言中的引用调用，在C语言中采用指针也可达到同样的效果。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0311",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0751",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q021001",
            "q021003",
            "q021004"
        ],
        "summry": "**线性表的基本操作**\n- **定义**：线性表是由**相同数据类型**的有限元素组成的序列，支持一组核心操作以实现数据管理。\n- **核心操作**：\n- **InitList(&L)**：初始化空表，分配存储空间（时间复杂度**O(1)**）。\n- **Length(L)**：返回元素个数（数组实现**O(1)**，链表需遍历**O(n)**）。\n- **LocateElem(L, e)**：按值查找，返回元素位置（最优**O(1)**，最差**O(n)**）。\n- **GetElem(L, i)**：按位获取元素（数组**O(1)**，链表**O(n)**）。\n- **ListInsert(&L, i, e)**：在位置`i`插入元素`e`（数组需移动元素**O(n)**，链表**O(1)**查找+插入）。\n- **ListDelete(&L, i, &e)**：删除位置`i`元素并返回`e`（时间复杂度同插入）。\n- **PrintList(L)**：顺序输出元素（**O(n)**）。\n- **Empty(L)**：判断表是否为空（**O(1)**）。\n- **DestroyList(&L)**：释放内存空间（数组**O(1)**，链表需遍历**O(n)**）。\n- **关键注意**：\n1. 操作实现依赖**存储结构**（顺序存储 vs 链式存储）。\n2. **“&”**表示引用调用（C++）或指针传递（C），直接修改原表。\n- **应用场景**：\n- 顺序表：频繁随机访问（如数组）。\n- 链表：频繁插入/删除（如动态内存管理）。\n- **记忆提示**：\n- **“增删查改”**是核心，存储结构定效率。\n- 顺序表：**随机访问快**，链表：**动态操作优**。"
    },
    {
        "id": "kc0221",
        "title": "顺序表的定义",
        "chapter_id": "02",
        "description": "命题追踪（算法题）顺序表的应用（2010、2011、2018、2020）\n线性表的顺序存储也称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元\n素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在顺序表的起始位置，\n第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素α在顺序表中的位序。因\n此，顺序表的特点是表中元素的逻辑顺序与其存储的物理顺序相同。\n假设顺序表L存储的起始位置为LOC（A），sizeof（ElemType）是每个数据元素所占用存\n储空间的大小，则表L所对应的顺序存储结构如图2.1所示。\n数组下标\n顺序表\n内存地址\nLOC(A)\n0\na\na2\nLOC(A)+sizeof(ElemType)\n1\n：\ni-1\na\nLOC(A)+(i-1)xsizeof(ElemType)\nn-1\nan\nLOC(A)+(n-1)xsizeof(ElemType)\n：\nMaxSize-l\nLOC(A)+(MaxSize-1)xsizeof(ElemType)\n图2.1线性表的顺序存储结构\n每个数据元素的存储位置都和顺序表的起始位置相差一个和该数据元素的位序成正比的常\n数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随\n机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。\n注意\n线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。\n\n第2章线性表\n15\n假定线性表的元素类型为ElemType，则静态分配的顺序表存储结构描述为\n#define MaxSize 50\n//定义线性表的最大长度\ntypedef struct{\nElemType data[MaxSize];\n//顺序表的元素\nint length;\n//顺序表的当前长度\n)SqList;\n//顺序表的类型定义\n维数组可以是静态分配的，也可以是动态分配的。对数组进行静态分配时，因为数组的大\n小和空间事先已经固定，所以一旦空间占满，再加入新数据就会产生溢出，进而导致程序崩溃。\n而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦\n数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到\n扩充数组存储空间的目的，而不需要为线性表一次性地划分所有空间。\n动态分配的顺序表存储结构描述为\n#define InitSize 100\n//表长度的初始定义\ntypedef struct{\nElemType *data;\n//指示动态分配数组的指针\nint MaxSize,length;\n//数组的最大容量和当前个数\n)SeqList;\n//动态分配数组顺序表的类型定义\nC的初始动态分配语句为\nL.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);\nC++的初始动态分配语句为\nL.data=new ElemType[InitSize];\n注意\n动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，\n只是分配的空间大小可以在运行时动态决定。\nVV\nvV\n顺序表的主要优点：①可进行随机访问，即可通过首地址和元素序号可以在0（1）时间内找到\n指定的元素；②存储密度高，每个结点只存储数据元素。顺序表的缺点也很明显：①元素的插入\n和删除需要移动大量的元素，插入操作平均需要移动n/2个元素，删除操作平均需要移动（n-1)/2\n个元素；②顺序存储分配需要一段连续的存储空间，不够灵活。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q022001",
            "q022003",
            "q022004",
            "q022005",
            "q022006",
            "q022007",
            "q022008",
            "q022009",
            "q022012",
            "q022013",
            "q022014",
            "q022015"
        ],
        "summry": "**顺序表**\n- **定义**：线性表的顺序存储结构，使用**连续内存空间**依次存储元素，逻辑相邻则物理相邻。\n- **特性**：\n- **随机存取**：通过首地址和位序可直接访问元素（`LOC(A) + (i-1)*sizeof(ElemType)`）。\n- **存储密度高**：仅存储数据元素，无额外指针开销。\n- **静态/动态分配**：\n- 静态：固定大小数组（`SqList`），空间满时溢出。\n- 动态：指针分配（`SeqList`），可扩容（`malloc`/`new`）。\n- **操作复杂度**：\n- **查找**：**O(1)**（随机访问）。\n- **插入/删除**：**O(n)**（需移动元素，平均n/2次）。\n- **应用场景**：频繁查询、少增删的场景（如数组缓存）。\n- **实现要点**：\n- 位序从1开始，数组下标从0开始（注意转换）。\n- 动态分配仍为顺序存储，非链式结构。\n- **优缺点**：\n- 优点：存取快、存储紧凑。\n- 缺点：增删效率低、需连续内存。\n- **记忆提示**：\n- \"顺序表≈数组\"，\"静态固定大小，动态可扩容\"。\n- 插入删除口诀：\"中间操作要移位，头尾操作最省时\"。"
    },
    {
        "id": "kc0222",
        "title": "顺序表上基本操作的实现",
        "chapter_id": "02",
        "description": "命题追踪顺序表上操作的时间复杂度分析（2023）\n这里仅讨论顺序表的初始化、插入、删除和按值查找，其他基本操作的算法都很简单。\n注意\n在各种操作的实现中（包括严蔚敏老师撰写的教材），往往可以忽略边界条件判断、变量定义、内存\n分配不足等细节，即不要求代码具有可执行性，而重点在于算法的思想，\n1.顺序表的初始化\n静态分配和动态分配的顺序表的初始化操作是不同的。静态分配在声明一个顺序表时，就已\n为其分配了数组空间，因此初始化时只需将顺序表的当前长度设为0。\n//SqListL;\n1//声明一个顺序表\nvoid InitList(SqList &L){\nL.length=0;\n//顺序表初始长度为0\n\n16\n2026年数据结构考研复习指导\n动态分配的初始化为顺序表分配一个预定义大小的数组空间，并将顺序表的当前长度设为0。\nvoid InitList(SeqList &L)(\nL.data=（ElemType*)malloc（InitSize*sizeof（ElemType));//分配存储空间\nL.length=0;\n//顺序表初始长度为0\nL.MaxSize=InitSize;\n//初始存储容量\n2.插入操作\n在顺序表L的第i（1<=i<=L.length+1）个位置插入新元素é。若i的输入不合法，则\n返回false，表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾\n出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。\nbool ListInsert(SqList &L,int i,ElemType e)(\nif(i<1l|i>L.length+1)\n//判断i的范围是否有效\nreturn false;\nif(L.length>=MaxSize)\n//当前存储空间已满，不能插入\nreturn false;\nfor(int j=L.length;j>=i;j--)\n//将第i个元素及之后的元素后移\nL.data[j]=L.data[j-1];\n//在位置i处放入é\nL.data[i-1]=e;\nL.length++;\n//线性表长度加1\nreturn true;\n注意\n区别顺序表的位序和数组下标。为何判断插入位置是否合法时if语句中用1ength+1，而移动元素的\nfor语句中只用length？\n最好情况：在表尾插入（i=n+1），元素后移语句将不执行，时间复杂度为O(1)。\n最坏情况：在表头插入（i=1)，元素后移语句将执行n次，时间复杂度为O(n)。\n平均情况：假设p（p;=1/(n+1)）是在第i个位置上插入一个结点的概率，则在长度为n的\n线性表中插入一个结点时，所需移动结点的平均次数为\n1\n1+1\n1 n(n+1)\nn\np（n-i+1）=\n（n-i+1）=\n(n-i+1)=\nn+1\n=n+1\nn+1\n2\n2\ni=l\n因此，顺序表插入算法的平均时间复杂度为O(n)。\n3．删除操作\n删除顺序表L中第i（1<=i<=L.length）个位置的元素，用引用变量e返回。若i的输\n入不合法，则返回false：否则，将被删元素赋给引用变量e，并将第i+1个元素及其后的所有\n元素依次往前移动一个位置，返回true。\nbool ListDelete(SqList &L,int i,ElemType &e)(\nif(i<llli>L.length)\n//判断i的范围是否有效\nreturn false;\ne=L.data[i-1];\n/将被删除的元素赋值给e\nfor（int j=i;j<L.length;j++)\n/将第i个位置后的元素前移\nL.data[j-1]=L.data[j];\nL.length--;\n//线性表长度减1\nreturn true;\n最好情况：删除表尾元素（i=n），无须移动元素，时间复杂度为O（1)。\n\n第2章线性\n表\n17\n最坏情况：删除表头元素（i=1)，需移动除表头元素外的所有元素，时间复杂度为O(n)。\n平均情况：假设p;（p,=1/n）是删除第i个位置上结点的概率，则在长度为n的线性表中删\n除一个结点时，所需移动结点的平均次数为\n1 n(n-1) n-1\np;(n-i)=\n-（n-i）：\n（n-i)\n=1n\nn=1\nn\n2\ni=l\n因此，顺序表删除算法的平均时间复杂度为O（n)。\n可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插\n入和删除元素的位置。图2.2所示为一个顺序表在进行插入和删除操作前、后的状态，以及其数\n据元素在存储空间中的位置变化和表长变化。在图2.2（a)中，将第4个至第7个元素从后往前依\n次后移一个位置，在图2.2（b）中，将第5个至第7个元素从前往后依次前移一个位置。\n0\n0\n6\ndata\n25\n3457\n0963\ndata\n25345716480963\n删除16\ndata\n57\n50\ndata\n(a)插入新元素示例\n(b）删除表中元素示例\n图2.2顺序表的插入和删除\n4.按值查找（顺序查找）\n在顺序表L中查找第一个元素值等于é的元素，并返回其位序。\nint LocateElem(SqList L,ElemType e){\ninti;\nfor（i=0;i<L.length;i++)\nif(L.data[i]==e)\nreturni+1;\n//下标为i的元素值等于e，返回其位序i+1\nreturn0;\n//退出循环，说明查找失败\n最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为0（1)。\n最坏情况：查找的元素在表尾（或不存在）时，需要比较n次，时间复杂度为O(n)。\n则在长度为n的线性表中查找值为e的元素所需比较的平均次数为\n\"1\n1 n(n+1)\n）n+1\n=n\nn\n2\n因此，顺序表按值查找算法的平均时间复杂度为O(n)。\n顺序表的按序号查找非常简单，即直接根据数组下标访问数组元素，其时间复杂度为O(1)。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "extension"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "extension"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q022001",
            "q022003",
            "q022004",
            "q022005",
            "q022006",
            "q022007",
            "q022008",
            "q022009",
            "q022012",
            "q022013",
            "q022014",
            "q022015"
        ],
        "summry": "**顺序表基本操作实现**\n### **1. 初始化**\n- **静态分配**：声明时已分配固定空间，初始化仅需设 `length=0`。\n```c\nvoid InitList(SqList &L) { L.length = 0; }\n```\n- **动态分配**：需手动分配初始空间，并记录容量 `MaxSize`。\n```c\nvoid InitList(SeqList &L) {\nL.data = (ElemType*)malloc(InitSize * sizeof(ElemType));\nL.length = 0;  L.MaxSize = InitSize;\n}\n```\n### **2. 插入操作**\n- **步骤**：\n1. 检查位置 `i` 合法性（`1 ≤ i ≤ length+1`）。\n2. 若空间已满，返回失败。\n3. 从第 `i` 个元素开始向后移动一位，腾出位置插入 `e`，长度 `+1`。\n- **时间复杂度**：\n- **最好**：表尾插入，**O(1)**。\n- **最坏**：表头插入，移动 `n` 次，**O(n)**。\n- **平均**：移动 `n/2` 次，**O(n)**。\n- **关键点**：\n- 位序 `i` 对应数组下标 `i-1`。\n- 合法范围检查用 `length+1`（允许插入到表尾后）。\n### **3. 删除操作**\n- **步骤**：\n1. 检查位置 `i` 合法性（`1 ≤ i ≤ length`）。\n2. 将被删元素赋值给 `e`，从 `i+1` 开始向前移动一位覆盖，长度 `-1`。\n- **时间复杂度**：\n- **最好**：删除表尾，**O(1)**。\n- **最坏**：删除表头，移动 `n-1` 次，**O(n)**。\n- **平均**：移动 `(n-1)/2` 次，**O(n)**。\n### **4. 按值查找**\n- **步骤**：遍历顺序表，返回第一个匹配元素的位序（从1开始），失败返回0。\n- **时间复杂度**：\n- **最好**：元素在表头，**O(1)**。\n- **最坏**：元素在表尾或不存在，**O(n)**。\n- **平均**：比较 `(n+1)/2` 次，**O(n)**。\n### **快速记忆**\n- **插入/删除**：移动元素数取决于位置，平均 **O(n)**。\n- **查找**：顺序扫描，平均 **O(n)**；按索引直接访问为 **O(1)**。\n- **边界**：插入检查 `length+1`，删除检查 `length`。"
    },
    {
        "id": "kc0222",
        "title": ".",
        "chapter_id": "02",
        "description": "",
        "related_points": [
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q022001",
            "q022003",
            "q022004",
            "q022005",
            "q022006",
            "q022007",
            "q022008",
            "q022009",
            "q022012",
            "q022013",
            "q022014",
            "q022015"
        ],
        "summry": "**队列（Queue）**\n- **定义**：先进先出（FIFO）的线性数据结构，元素在队尾插入（**enqueue**），在队头删除（**dequeue**）。\n- **特性**：\n- 基本操作：`enqueue(x)`（入队）、`dequeue()`（出队）、`peek()`（查看队头），均**O(1)**时间（链表实现）。\n- 循环队列：利用数组实现时通过模运算解决假溢出问题，需维护`front`和`rear`指针。\n- **应用场景**：任务调度（如打印机队列）、BFS算法、消息缓冲机制。\n- **关键细节**：\n- **链式队列**：无容量限制，但需额外存储指针；**数组队列**：空间固定，需处理满队条件。\n- 线程安全变体：**阻塞队列**（生产者-消费者模型）、**双端队列（Deque）**（两端可操作）。\n**快速记忆**：队列≈排队，先到先服务；BFS必用队列，分层遍历。"
    },
    {
        "id": "kc0233",
        "title": ".3.4.4.5来手动模拟算法的执行过程，在模",
        "chapter_id": "02",
        "description": "拟过程中要标注i和j所指示的元素。\n思考：若将本题中的有序表改为无序表，你能想到时间复杂度为O（n)的方法吗？\n（提示：使用散列表。）\n06.【解答】\n算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看\n哪个表还有剩余，将剩下的部分加到新的顺序表后面。\n本题代码如下：\nbool Merge(SeqList A,SeqList B,SeqList &C){\n/将有序顺序表A与B合并为一个新的有序顺序表C\nif(A.length+B.length>C.maxSize)\n//大于顺序表的最大长度\nreturn false;\nint i=0，j=0,k=0;\nwhile(i<A.length&&j<B.length)(\n//循环，两两比较，小者存入结果表\nif(A.data[i]<=B.data[j])\nC.data[k++]=A.data[i++];\nelse\nC.data[k++]=B.data[j++];\nwhile(i<A.length)\n//还剩一个没有比较完的顺序表\nC.data[k++]=A.data[i++];\nwhile(j<B.length)\nC.data[k++]=B.data[j++];\nC.length=k;\nreturntrue;\n注意\n本算法的方法非常典型，需牢固掌握。\n07.【解答】\n算法思想：首先将数组A[m+n]中的全部元素(a,a2,a3,…,am,b,b2,b3,.….,bn)原地逆置为\n(bn,bn-1,b-2,….,b1,amam-1,am-2,,a)，然后对前n个元素和后m个元素分别使用逆置算法，\n即可得到（b，b2,b3,.…，bm,a,a2,a3,.…,am），从而实现顺序表的位置互换。\n本题代码如下：\ntypedef int DataType;\nvoid Reverse(DataType A[],int left,int right,int arraySize){\n//逆转（aleft,aleft+l,aleft+2,\",aright)为(aright,aright-l,\",aleft)\nif(left>=rightllright>=arraySize)\nreturn;\nint mid=(left+right)/2;\nfor（int i=0;i<=mid-left;i++){\nDataType temp=A[left+i];\nA[left+i]=A[right-i];\nA[right-i]=temp;\nvoid Exchange(DataType A[],int m,int n,int arraySize)\n*数组A[m+n]中，从0到m-1存放顺序表（a1，a2，a3，\"，am），从m到m+n-1存放顺序表\n\n第2章线性\n表\n25\n(b1，b2，b3，…，bn），算法将这两个表的位置互换*/\nReverse(A,0,m+n-1,arraySize);\nReverse(A,0,n-l,arraySize);\nReverse(A,n,m+n-l,arraySize);\n08.【解答】\n算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最\n少的时间在表中查找数值为x的元素”，这里应使用折半查找法。\n本题代码如下：\nvoid SearchExchangeInsert(ElemType A[],ElemType x)(\nint low=0,high=n-1,mid;\n//low和high指向顺序表下界和上界的下标\nwhile(low<=high){\nmid=(1ow+high)/2;\n/找中间位置\nif(A[mid]==x) break;\n/找到x，退出while循环\nelse if(A[mid]<x)\nlow=mid+1；//到中点mid的右半部去查\nelse high=mid-1;\n//到中点mid的左半部去查\n/下面两个if语句只会执行\n个\nif（A[mid]==x&&mid!=n-l）{\n//若最后一个元素与×相等，则不存在与其后\n继交换的操作\n+]+]]]\nif(low>high){\n//查找失败，插入数据元素x\nfor（i=n-l;i>high;i--）A[i+l]=A[i];\n//后移元素\nA[i+1]=x;\n/插入x\n//结束插入\n本题的算法也可写成三个函数：查找函数、交换后继函数与插入函数。写成三个函数的优点\n是逻辑清晰、易读。\n09.【解析】\n1）算法的基本设计思想。\n使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进\n指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围，即可停止。\n2）算法的实现。\nvoid samekey（int A[],int B[],int C[],int n）(\nint i=0,j=0,k=0;\n//定义三个工作指针\nwhile(i<n&&j<n&&k<n){\n//相同则输出，并集体后移\nif(A[i]==B[j]&&B[j]==C[k]）{\nprintf(\"d\\n\",A[i]);\ni++;j++;k++;\n)elset\nintmaxNum=max(A[i],max（B[j],C[k])）;\nif(A[i]<maxNum)i++;\nif(B[j]<maxNum)j++;\nif(C[k]<maxNum)k++;\n3）每个指针移动的次数不超过n次，且每次循环至少有一个指针后移，所以时间复杂度为\nO(n)，算法只用到了常数个变量，空间复杂度为O(1)。\n10.【解答】\n1）算法的基本设计思想：\n\n26\n2026年数据结构考研复习指导\n可将问题视为把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个\n元素)，先将a逆置得到ab，再将b逆置得到ab-，最后将整个ab逆置得到（ab-)-=ba。设\nReverse函数执行将数组逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下：\nReverse(0,p-1)得到 cbadefgh;\nReverse（p，n-1)得到 cbahgfed;\nReverse(0,n-1)得到 defghabc。\n注：在Reverse中，两个参数分别表示数组中待转换元素的始末位置。\n2）使用C语言描述算法如下：\nvoid Reverse（int R[],int from,int to）{\nint i,temp;\nfor（i=0;i<（to-from+1)/2;i++)\n{temp=R[from+i];R[from+i]=R[to-i];R[to-i]=temp;}\nvoid Converse（int R[],int n,int p)(\nReverse(R,0,p-1);\nReverse(R,p,n-1);\nReverse(R,0,n-1);\n3）上述算法中三个Reverse函数的时间复杂度分别为 O(p/2)、O(n-p)/2)和O(n/2)，故所\n设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。\n【另解】借助辅助数组来实现。算法思想：创建大小为p的辅助数组S，将R中前p个整数\n依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的\n后续单元。时间复杂度为O(n)，空间复杂度为O(p)。\n11.【解答】\n1）算法的基本设计思想如下。\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n①若a=b，则a或b为所求中位数，算法结束。\n②若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的\n长度相等。\n③若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的\n长度相等。\n在保留的两个升序序列中，重复过程①、②、③，直到两个序列中均只含一个元素时为止，\n较小者为所求的中位数。\n2）本题代码如下：\nint M Search（int A[],int B[],intn)(\nint s1,dl,m1,s2,d2,m2;\ns1=0;d1=n-1;\ns2=0;d2=n-1;\nwhile(s1!=dl||s2!=d2）{\nm1=（s1+d1）/2;\nm2=（s2+d2)/2;\nif(A[m1]==B[m2])\nreturn A[ml];\n/满足条件①\nif(A[m1]<B[m2]){\n/满足条件②\nif（(s1+d1）%2==0）{\n1若元素个数为奇数\ns1=ml;\n川舍弃A中间点以前的部分，且保留中间点\nd2=m2;\n川舍弃B中间点以后的部分，且保留中间点\n\n第2章线性\n表\n27\nelser\n1/元素个数为偶数\ns1=m1+1;\n//舍弃A的前半部分\nd2=m2;\n//舍弃B的后半部分\nelse{\n//满足条件③\nif（（s1+d1）2==0）{\n1//若元素个数为奇数\nd1=ml;\n/舍弃A中间点以后的部分，且保留中间点\ns2=m2;\n//舍弃B中间点以前的部分，且保留中间点\nelsel\n1//元素个数为偶数\nd1=ml;\n//舍弃A的后半部分\ns2=m2+1;\n1//舍弃B的前半部分\nreturn A[s1]<B[s2]? A[s1]:B[s2];\n3）算法的时间复杂度为O（log2n)，空间复杂度为O（1)。\n【另解】对两个长度为n的升序序列A和B中的元素按从小到大的顺序依次访问，这里访问\n的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为0(1)。按\n照上述规则访问第n个元素时，这个元素为两个序列A和B的中位数。\n12.【解答】\n1）算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元\n素的元素Num。然后重新计数，确认Num是否是主元素。\n算法可分为以下两步：\n①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到\nc中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计\n数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一\n轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。\n②判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大\n于n/2，则为主元素；否则，序列中不存在主元素。\n2）算法实现如下：\nint Majority(int A[],int n)(\nint i,c,count=l;\nllc用来保存候选主元素，count用来计数\nC=A[0];\n//设置A[0]为候选主元素\nfor(i=1;i<n;i++)\n//查找候选主元素\nif(A[i]==c)\ncount++;\n//对A中的候选主元素计数\nelse\nif(count>0)\n1//处理不是候选主元素的情况\ncount--;\nelsel\n//更换候选主元素，重新计数\nC=A[i];\ncount=1;\nif(count>0)\nfor（i=count=0;i<n;i++)\n//统计候选主元素的实际出现次数\nif(A[i]==c)\ncount++;\nif(count>n/2) return c;\n//确认候选主元素\n\n28\n2026年数据结构考研复习指导\nelse return -1;\n1/不存在主元素\n3）实现的程序的时间复杂度为O(n)，空间复杂度为O(1)。\n说明\n本题若采用先排好序再统计的方法【时间复杂度为O（nlog2n)]，则只要解答正确，最高可拿11分。\n即便是写出O（n²）的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得\n不偿失的。本算法的方法非常典型，需牢固掌握\n13.【解答】\n1）算法的基本设计思想：\n要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用\n来记录A中是否出现了1~n中的正整数，B[0]对应正整数1，B[n-1]对应正整数n，初始化B\n中全部为0。A中含有n个整数，因此可能返回的值是1~n+1，当A中n个数恰好为1~n时返回\nn+1。当数组A中出现了小于或等于0或大于n的值时，会导致1~n中出现空余位置，返回结果\n必然在1~n中，因此对于A中出现了小于或等于0或大于n的值，可以不采取任何操作。\n经过以上分析可以得出算法流程：从A[0]开始遍历A，若0<A[i]<=n，则令B[A[i]-1]=1；\n否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，\n返回i+1即为结果，此时说明A中未出现的最小正整数在1和n之间。若B[i]全部不为0，返\n回i+1（跳出循环时i=n，i+1等于n+1），此时说明A中未出现的最小正整数是n+1。\n2）算法实现：\nint findMissMin(int A[],int n)\nint i,*B;\n/标记数组\nB=(int *)malloc(sizeof(int）*n);//分配空间\nmemset(B,0,sizeof(int)*n);\n/赋初值为0\nfor(i=0;i<n;i++)\nif(A[i]>0&&A[i]<=n)\n/若A[i]的值介于1~n，则标记数组B\nB[A[i]-1]=1;\nfor(i=0;i<n;i++)\n/扫描数组B，找到目标值\nif （B[i]==0）break;\nreturn i+l;\n/返回结果\n3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为O（1)量级，因此时间复\n杂度为O(n)。空间复杂度：额外分配了B[n］，空间复杂度为O(n)。\n14.【解答】\n分析。由D=a-b+b-c+c-a≥0有如下结论。\n①当a=b=c时，距离最小。\n②其余情况。不失一般性，假设a≤b≤c，观察下面的数轴：\nq-D=17\nL2=b-\nD-=\n=7+7+7=0<|-0|+|-q|+1q-=q\n由D的表达式可知，事实上决定D大小的关键是a和c之间的距离，于是问题就可以简化\n\n第2章线性表\n29\n为每次固定c找一个a，使得L=c-a最小。\n1）算法的基本设计思想：\n①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。\n②集合S、S和S分别保存在数组A、B、C中。数组的下标变量i=j=k=0，当i<IS小\nj<IS|且k<[S;[时（IS|表示集合S中的元素个数），循环执行下面的a）～c)。\na）计算(A[i],BU],C[k])的距离D：（计算D)\nb）若D<Dmin，则Dmin=D；（更新D)\nc）将A[i]、BU]、C[K]中的最小值的下标+1;\n（对照分析：最小值为a，最大值为c，这里c\n不变而更新a，试图寻找更小的距离D）\n③输出 Dmin，结束。\n2）算法实现：\n#define INT_MAX Ox7fffffff\nintabs_（inta）{//计算绝对值\nif(a<o)return-a;\nelse return a;\nboolxls_min（inta，intb，intc）（//a是否是三个数中的最小值\nif（a<=b&&a<=c) return true;\nreturn false;\n/D_min用于记录三元组的最小距离，初值赋为INTMAX\nint i=0,j=0,k=0,D_min=INT_MAX,D;\nwhile(i<n&&j<m&&k<p&&D_min>0){\nD=abs_(A[i]-B[j])+abs_(B[j]-C[k]）+abs_(C[k]-A[i]);//计算D\nif（D<D_min)D_min=D;\n//更新D\nif(xls_min(A[i],B[j],C[k]）)\n//更新a\ni++;\nelse if(xls_min(B[j],C[k],A[i]))\nj++;\nelse k++;\nreturn D_min;\n3）设n=(ISi|+IS|+ISsl)，时间复杂度为O(n)，空间复杂度为O(1)。\n2.3线性表的链式表示\n顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任一元素，但插入和\n删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑\n上相邻的元素在物理位置上也相邻，它通过“链”建立元素之间的逻辑关系，因此插入和删除操作\n不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。\n公众号：小兔网盘免费分享无水印PDF",
        "related_points": [
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "related"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0312",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**有序顺序表合并算法**\n- **定义**：将两个**有序**顺序表A和B合并为一个新的有序顺序表C。\n- **算法思想**：\n1. **双指针比较**：初始化指针`i`（A表）、`j`（B表）、`k`（C表），循环比较`A[i]`与`B[j]`，较小者存入`C`并移动对应指针。\n2. **剩余元素处理**：若某表未遍历完，直接将其剩余元素追加到`C`中。\n- **时间复杂度**：**O(m+n)**（m、n分别为A、B表长）。\n- **空间复杂度**：**O(1)**（除结果表C外无额外空间）。\n- **关键代码**：\n```c\nwhile(i<A.length && j<B.length)\nC.data[k++] = (A.data[i]<=B.data[j]) ? A.data[i++] : B.data[j++];\nwhile(i<A.length) C.data[k++] = A.data[i++];\nwhile(j<B.length) C.data[k++] = B.data[j++];\n```\n- **注意**：需预先检查`A.length+B.length ≤ C.maxSize`。\n---\n**无序表合并优化（O(n)方法）**\n- **提示**：使用**散列表**（哈希表）。\n- **步骤**：\n1. 遍历表A，将所有元素存入哈希表。\n2. 遍历表B，检查元素是否在哈希表中，若存在则加入结果表C。\n- **时间复杂度**：**O(n)**（哈希插入和查询均摊O(1)）。\n- **空间复杂度**：**O(n)**（哈希表存储开销）。\n---\n**顺序表位置互换（逆置法）**\n- **问题**：将数组`A[m+n]`的前m个元素（a₁~aₘ）与后n个元素（b₁~bₙ）互换位置。\n- **算法思想**：\n1. **整体逆置**：将`A`逆置为`(bₙ,...,b₁, aₘ,...,a₁)`。\n2. **局部逆置**：分别逆置前n个元素（b部分）和后m个元素（a部分）。\n- **时间复杂度**：**O(n)**（三次逆置，每次O(n)）。\n- **关键代码**：\n```c\nReverse(A, 0, m+n-1);  // 整体逆置\nReverse(A, 0, n-1);     // 逆置前n个（原b部分）\nReverse(A, n, m+n-1);   // 逆置后m个（原a部分）\n```\n---\n**主元素查找算法**\n- **定义**：出现次数超过`n/2`的元素。\n- **算法思想**：\n1. **候选主元素标记**：遍历数组，维护候选元素`c`和计数器`count`。若当前元素等于`c`则`count++`，否则`count--`；若`count=0`则更新`c`为当前元素。\n2. **验证阶段**：再次遍历统计`c`的实际出现次数。\n- **时间复杂度**：**O(n)**（两遍扫描）。\n- **空间复杂度**：**O(1)**。\n---\n**未出现的最小正整数**\n- **算法思想**：\n1. **标记法**：使用辅助数组`B[n]`，遍历原数组`A`，若`1 ≤ A[i] ≤ n`则标记`B[A[i]-1]=1`。\n2. **扫描B**：返回第一个`B[i]=0`的`i+1`，或`n+1`（若B全为1）。\n- **时间复杂度**：**O(n)**。\n- **空间复杂度**：**O(n)**（辅助数组B）。\n---\n**快速记忆提示**\n- **合并有序表**：双指针“擂台赛”，小者入队，剩者抄底。\n- **逆置法交换**：整体倒置→局部倒置≈“翻煎饼”。\n- **主元素查找**：候选元素“幸存者”+二次验证。"
    },
    {
        "id": "kc0231",
        "title": "单链表的定义",
        "chapter_id": "02",
        "description": "命题追踪单链表的应用（2009、2012、2013、2015、2016、2019）\n线性表的链式存储也称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元\n素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存\n放一个指向其后继的指针。单链表结点结构如图2.3所示，其中data为数据域，存放数据元素；\n\n30\n2026年数据结构考研复习指导\nnext为指针域，存放其后继结点的地址。\ndata\nnext\n图2.3单链表结点结构\n单链表中结点类型的描述如下：\ntypedef struct LNode\n//定义单链表结点类型\nElemType data;\n//数据域\nstruct LNode *next;\n//指针域\n)LNode,*LinkList;\n利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存\n储空间的缺点。单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能\n直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。\n通常用头指针L（或head等）来标识一个单链表，指出链表的起始地址，头指针为NULL\n时表示一个空表。此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称\n为头结点。头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，\n头指针工指向头结点，如图2.4(a)所示。单链表不带头结点时，头指针L指向第一个数据结点，\n如图2.4(b)所示。表尾结点的指针域为NULL（用“^”表示）。\n(a)带表头结点的单链表\n(b)不带表头结点的单链表\n图2.4带头结点和不带头结点的单链表\n头结点和头指针的关系：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结\n点是带头结点的链表中的第一个结点，结点内通常不存储信息。\n引入头结点后，可以带来两个优点：\n①第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作\n和在表的其他位置上的操作一致，无须进行特殊处理。\n②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），\n因此空表和非空表的处理也就得到了统一。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0232",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**单链表**\n- **定义**：线性表的链式存储结构，通过**指针**连接一组**任意存储单元**存储数据元素。每个结点包含：\n- **数据域**（`data`）：存储元素值。\n- **指针域**（`next`）：指向后继结点的地址。\n- **结点类型**：\n```c\ntypedef struct LNode {\nElemType data;      // 数据域\nstruct LNode *next; // 指针域\n} LNode, *LinkList;\n```\n- **特性**：\n- **非随机存取**：必须从头结点开始遍历查找（**O(n)**）。\n- **空间权衡**：避免连续存储需求，但指针域占用额外空间。\n- **头结点 vs 头指针**：\n- **头指针**（`L/head`）：始终指向链表第一个结点（头结点或首数据结点），`NULL`表示空表。\n- **头结点**：附加在首数据结点前，数据域可空或存表长，其优点：\n1. **统一操作**：首数据结点与其他结点处理逻辑一致。\n2. **空表处理简化**：头指针永非空，空表仅需头结点`next=NULL`。\n- **应用场景**：\n- 动态内存分配（如操作系统内存管理）。\n- 频繁插入/删除（优于顺序表**O(1)** vs **O(n)**）。\n- **快速记忆**：\n- **链式≈火车车厢**：每节车厢（结点）独立存放，通过挂钩（指针）连接。\n- **头结点≈哨兵**：简化边界条件处理。"
    },
    {
        "id": "kc0232",
        "title": "单链表上基本操作的实现",
        "chapter_id": "02",
        "description": "带头结点单链表的操作代码书写较为方便，如无特殊说明，本节均默认链表带头结点。\n1.单链表的初始化\n带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要\n创建一个头结点，并让头指针指向头结点，头结点的next域初始化为NULL。\nbool InitList（LinkList &L)(\n//带头结点的单链表的初始化\nL=(LNode*)malloc(sizeof(LNode));\n//创建头结点?\nL->next=NULL;\n/头结点之后暂时还没有元素结点\nreturn true;\n不带头结点的单链表初始化时，只需将头指针L初始化为NULL。\nbool InitList(LinkList &L)(\n//不带头结点的单链表的初始化\n①执行s=（LNode*）malloc（sizeof（LNode））的作用是由系统生成一个LNode型的结点，并将该结点的起始位置赋给指针变量s。\n\n第2章线性\n表\n31\nL=NULL;\nreturn true;\n注意\n设p为指向链表结点的结构体指针，则*p表示结点本身，因此可用p->data或（*p）.data访问*p\n这个结点的数据域，二者完全等价。成员运算符（.）左边是一个普通的结构体变量，而指向运算符（一>）\n左边是一个结构体指针。通过（*p）.next可以得到指向下一个结点的指针，因此（*（*p）.next）.data\n就是下一个结点中存放的数据，或者直接用p->next->data。\n2.求表长操作\n求表长操作是计算单链表中数据结点的个数，需要从第一个结点开始依次访问表中每个结\n点，为此需设置一个计数变量，每访问一个结点，其值加1，直到访问到空结点为止。\nint Length(LinkList L){\nint len=0;\n//计数变量，初始为0\nLNode *p=L;\nwhile(p->next!=NULL){\np=p->next;\nlen++;\n//每访问一个结点，计数加1\nreturn len;\n求表长操作的时间复杂度为O(n)。另需注意的是，因为单链表的长度是不包括头结点的，因\n此不带头结点和带头结点的单链表在求表长操作上会略有不同。\n3.按序号查找结点\n从单链表的第一个结点开始，沿着next域从前往后依次搜索，直到找到第i个结点为止，\n则返回该结点的指针：若i大于单链表的表长，则返回NULL。\nLNode *GetElem(LinkList L,int i）(\nLNode *p=L;\n//指针p指向当前扫描到的结点\nint j=0;\n//记录当前结点的位序，头结点是第0个结点\nwhile(p!=NULL&&j<i）\n//循环找到第i个结点\np=p->next;\nj++;\nreturn\n!d\n//返回第i个结点的指针或NULL\n按序号查找操作的时间复杂度为O(n)。\n4.按值查找表结点\n从单链表的第一个结点开始，从前往后依次比较表中各结点的数据域，若某结点的data域\n等于给定值e，则返回该结点的指针：若整个单链表中没有这样的结点，则返回NULL。\nLNode *LocateElem(LinkList L,ElemType e){\nLNode *p=L->next;\np=p->next;\nreturn p;\n/找到后返回该结点指针，否则返回NULL\n按值查找操作的时间复杂度为O(n)。\n5.插入结点操作\n插入结点操作将值为×的新结点插入到单链表的第i个位置。先检查插入位置的合法性，然\n\n32\n2026年数据结构考研复习指导\n后找到待插入位置的前驱，即第i-1个结点，再在其后插入。其操作过程如图2.5所示。\n图2.5单链表的插入操作\n命题追踪单链表插入操作的过程（2016、2024）\n首先查找第i-1个结点，假设第i-1个结点为*p，然后令新结点*s的指针域指向*p的后\n继，再令结点*p的指针域指向新插入的结点*s。\nbool ListInsert(LinkList &L,int i,ElemType e){\nLNode *p=L;\n//指针p指向当前扫描到的结点\nint j=0;\n/记录当前结点的位序，头结点是第0个结点\nwhile（p!=NULL&&j<i-1){\n//循环找到第i-1个结点\np=p->next;\nj++;\nif(p==NULL)\n//i值不合法\nreturn false;\nLNode *s=(LNode*)malloc(sizeof(LNode));\ns->data=e;\ns->next=p->next;\n//图2.5中操作步骤①\np->next=s;\n//图2.5中操作步骤②\nreturn true;\n插入时，①和②的顺序不能颠倒，否则，先执行p->next=s后，指向其原后继的指针就不\n存在了，再执行s->next=p->next时，相当于执行了s->next=s，显然有误。本算法主要的\n时间开销在于查找第i-1个元素，时间复杂度为O（n)。若在指定结点后插入新结点，则时间复杂\n度仅为O(1)。需注意的是，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做\n特殊处理，将头指针L指向新的首结点。当链表带头结点时，插入位置i为1时不用做特殊处理。\n扩展：对某一结点进行前插操作。\n前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插\n入算法中，通常都采用后插操作。以上面的算法为例，先找到第i-1个结点，即插入结点的前驱，\n再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头\n结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为*s，将*s插入到*p\n的前面。我们仍然将*s插入到*p的后面，然后将p->data与s->data交换，这样做既满足逻\n辑关系，又能使得时间复杂度为O(1)。该方法的主要代码片段如下：\nx-dxu-\n//修改指针域，不能颠倒\np->next=s;\ntemp=p->data;\nI交换数据域部分\np->data=s->data;\ns->data=temp;\n6.删除结点操作\n删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1\n个结点，即被删结点的前驱，再删除第i个结点。其操作过程如图2.6所示。\n\n第2章\n线\n性\n未\n33\n图2.6单链表结点的删除\n假设结点*p为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改*p\n的指针域，将*p的指针域next指向*g的下一结点，然后释放*g的存储空间。\nbool ListDelete（LinkList &L,int i,ElemType &e){\nLNode *p=L;\n/指针p指向当前扫描到的结点\nint j=0;\n//记录当前结点的位序，头结点是第0个结点\n(>x\n//循环找到第i-1个结点\np=p->next;\nj++;\nif(p->next==NULLI1j>i-1)\n//i值不合法\nfalse;\nreturn\nLNode *q=p->next;\nl/令q指向被删除结点\ne=q->data;\n//用e返回元素的值\nxu-b=xu<-\n//将*q结点从链中“断开”\nfree(q);\n/释放结点的存储空间?\nreturn\ntrue;\n同插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为O(n)。当链表不带\n头结点时，需要判断被删结点是否为首结点，若是，则要做特殊处理，将头指针L指向新的首结\n点。当链表带头结点时，删除首结点和删除其他结点的操作是相同的。\n扩展：删除结点*p。\n要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱，然后执行删\n除操作。其实，删除结点*p的操作可用删除*p的后继来实现，实质就是将其后继的值赋予其自\n身，然后再删除后继，也能使得时间复杂度为O(1)。该方法的主要代码片段如下：\nq=p->next;\n//令g指向*p的后继结点\np->data=p->next->data;\n//用后继结点的数据域覆盖\nxu<-b=xu<-\n//将*g结点从链中“断开”\nfree（q);\n//释放后继结点的存储空间\n7.采用头插法建立单链表\n该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将\n新结点插入到当前链表的表头，即头结点之后，如图2.7所示。算法实现如下：\n每次将s所指的结点插在前端\n图2.7采用头插法建立单链表\n①执行free（q）的作用是由系统回收一个LNode型结点，回收后的空问可供再次生成结点时用。\n\n34\n2026年数据结构考研复习指导\nLinkListList_HeadInsert（LinkList&L）//逆向建立单链表\nLNode *s; int x;\n//设元素类型为整型\nL=(LNode*)malloc(sizeof(LNode)）;\n//创建头结点\nL->next=NULL;\n/初始为空链表\nscanf(\"%d\",&x）;\n//输入结点的值\nwhi1e(x!=9999)(\n//输入9999表示结束\ns=（LNode*）malloc（sizeof（LNode））;//创建新结点\ns->data=x;\ns->next=L->next;\nL->next=s;\n//将新结点插入表中，L为头指针\nscanf（\"d\",&x）;\nreturn L;\n采用头插法建立单链表时，读入数据的顺序与生成的链表中元素的顺序是相反的，可用来实\n现链表的逆置。每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。\n思考\n若单链表不带头结点，则上述代码中哪些地方需要修改？①\n8.采用尾插法建立单链表\n头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。\n若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加\n一个尾指针r，使其始终指向当前链表的尾结点，如图2.8所示。算法实现如下：\n每次将s所指的结点插在末端\n图2.8采用尾插法建立单链表\nLinkList List_TailInsert（LinkList&L）//正向建立单链表\nint x;\n//设元素类型为整型\nL=（LNode*)malloc(sizeof（LNode)）;\n//创建头结点\nLNode *s,*r=L;\n//r为表尾指针\nscanf(\"d\"，&x）;\n/输入结点的值\nwhile(x!=9999){\n//输入9999表示结束\ns=（LNode*)malloc（sizeof(LNode));\ns->data=x;\nr->next=s;\nr=s;\n//r指向新的表尾结点\nscanf(\"%d\",&x）;\nr->next=NULL;\n//尾结点指针置空\nreturn L;\n因为附设了一个指向表尾结点的指针，所以时间复杂度和头插法的相同。\n①主要修改之处：因为在头部插入新结点，每次插入新结点后，都需要将它的地址赋值给头指针L。\n\n第2章线性\n表\n35\n注意\n单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通\n过画图的方法理清算法的思路，然后进行算法的编写。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**单链表基本操作实现**\n### **1. 初始化**\n- **带头结点**：\n- 创建头结点，头指针指向头结点，`next`域置`NULL`。\n```c\nbool InitList(LinkList &L) {\nL = (LNode*)malloc(sizeof(LNode));  // 创建头结点\nL->next = NULL;                     // 空链表\nreturn true;\n}\n```\n- **不带头结点**：\n- 头指针直接置`NULL`。\n```c\nbool InitList(LinkList &L) {\nL = NULL;\nreturn true;\n}\n```\n- **关键点**：\n- 头结点简化操作（如插入/删除首元结点无需特殊处理）。\n### **2. 求表长**\n- **算法**：遍历链表，计数非头结点数量。\n```c\nint Length(LinkList L) {\nint len = 0;\nLNode *p = L->next;  // 跳过头结点\nwhile (p != NULL) {\nlen++;\np = p->next;\n}\nreturn len;\n}\n```\n- **时间复杂度**：**O(n)**。\n- **注意**：不带头结点时，`p`初始为`L`而非`L->next`。\n### **3. 按序号查找**\n- **算法**：从头结点开始遍历，直到第`i`个结点。\n```c\nLNode *GetElem(LinkList L, int i) {\nLNode *p = L;\nint j = 0;\nwhile (p != NULL && j < i) {\np = p->next;\nj++;\n}\nreturn p;  // 返回结点指针或NULL\n}\n```\n- **时间复杂度**：**O(n)**。\n### **4. 按值查找**\n- **算法**：遍历比较数据域，返回匹配结点。\n```c\nLNode *LocateElem(LinkList L, ElemType e) {\nLNode *p = L->next;\nwhile (p != NULL && p->data != e) {\np = p->next;\n}\nreturn p;  // 返回结点指针或NULL\n}\n```\n- **时间复杂度**：**O(n)**。\n### **5. 插入结点**\n- **后插法**：\n1. 找到第`i-1`个结点（前驱）。\n2. 新结点`s`的`next`指向前驱的`next`。\n3. 前驱的`next`指向`s`。\n```c\nbool ListInsert(LinkList &L, int i, ElemType e) {\nLNode *p = GetElem(L, i-1);  // 查找前驱\nif (p == NULL) return false;\nLNode *s = (LNode*)malloc(sizeof(LNode));\ns->data = e;\ns->next = p->next;  // 步骤①\np->next = s;        // 步骤②\nreturn true;\n}\n```\n- **前插法转化**：插入到`*p`后，交换数据域。\n```c\ns->next = p->next;\np->next = s;\nswap(p->data, s->data);  // 交换数据\n```\n- **时间复杂度**：查找**O(n)**，插入**O(1)**。\n### **6. 删除结点**\n- **常规删除**：\n1. 找到第`i-1`个结点（前驱）。\n2. 前驱的`next`指向被删结点的`next`。\n3. 释放被删结点。\n```c\nbool ListDelete(LinkList &L, int i, ElemType &e) {\nLNode *p = GetElem(L, i-1);  // 查找前驱\nif (p == NULL || p->next == NULL) return false;\nLNode *q = p->next;\ne = q->data;\np->next = q->next;  // 断开链接\nfree(q);\nreturn true;\n}\n```\n- **高效删除**：若已知`*p`，复制后继数据并删除后继。\n```c\nq = p->next;\np->data = q->data;  // 覆盖数据\np->next = q->next;\nfree(q);\n```\n- **时间复杂度**：查找**O(n)**，删除**O(1)**。\n### **7. 建立单链表**\n- **头插法**：新结点插入头结点后，生成逆序链表。\n```c\nvoid HeadInsert(LinkList &L) {\nLNode *s; int x;\nL = (LNode*)malloc(sizeof(LNode));\nL->next = NULL;\nwhile (scanf(\"%d\", &x), x != 9999) {\ns = (LNode*)malloc(sizeof(LNode));\ns->data = x;\ns->next = L->next;  // 插入表头\nL->next = s;\n}\n}\n```\n- **尾插法**：维护尾指针`r`，生成正序链表。\n```c\nvoid TailInsert(LinkList &L) {\nLNode *s, *r = L;\nwhile (scanf(\"%d\", &x), x != 9999) {\ns = (LNode*)malloc(sizeof(LNode));\ns->data = x;\nr->next = s;  // 插入表尾\nr = s;        // 更新尾指针\n}\nr->next = NULL;\n}\n```\n- **时间复杂度**：均为**O(n)**。\n### **关键总结**\n- **操作核心**：定位前驱结点（插入/删除需前驱）。\n- **易错点**：\n- 插入/删除时指针修改顺序不可颠倒。\n- 不带头结点时需特殊处理首元结点。\n- **记忆技巧**：\n- 头插法→逆序；尾插法→正序。\n- 删除`*p`→“替身法”（覆盖后继数据）。"
    },
    {
        "id": "kc0233",
        "title": "双链表",
        "chapter_id": "02",
        "description": "单链表结点中只有一个指向其后继的指针，使得单链表只能从前往后依次遍历。要访问\n某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为O(n)。\n为了克服单链表的这个缺点，引入了双链表，双链表结点中有两个指针prior和next，分\n别指向其直接前驱和直接后继，如图2.9所示。表头结点的prior域和尾结点的next域都\n是NULL。\n图2.9双链表示意图\n双链表中结点类型的描述如下：\ntypedef struct DNodel\n//定义双链表结点类型\nElemType data;\n//数据域\nstruct DNode *prior,*next;\n//前驱和后继指针\n)DNode，*DLinklist;\n双链表在单链表结点中增加了一个指向其前驱的指针prior，因此双链表的按值查找和按位\n查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这\n是因为“链”变化时也需要对指针prior做出修改，其关键是保证在修改的过程中不断链。此外，\n双链表可以很方便地找到当前结点的前驱，因此，插入、删除操作的时间复杂度仅为O(1)。\n1.双链表的插入操作\n在双链表中p所指的结点之后插入结点*s，其指针的变化过程如图2.10所示。\n公众号：小兔网盘\n图2.10双链表插入结点过程\n免费网课+无水印PDF\n命题追踪双链表中插入操作的实现（2023）\n插入操作的代码片段如下：\nxau<-d=xau<-s ①\n//将结点*s插入到结点*p之后\no-x-\n③ s->prior=p;\n④ p->next=s;\n上述代码的语句顺序不是唯一的，但也不是任意的，①步必须在④步之前，否则*p的后继结\n点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求\n在结点*p之前插入结点*s，请读者思考具体的操作步骤。\n\n36\n2026年数据结构考研复习指导\n2.双链表的删除操作\n删除双链表中结点*p的后继结点*q，其指针的变化过程如图2.11所示。\n②\n图2.11双链表删除结点过程\n命题追踪双链表中删除操作的实现（2016）\n删除操作的代码片段如下：\np->next=q->next;\n//图2.11中步骤①\nd=rotd<-xu<-b\n//图2.11中步骤②\nfree(q);\n//释放结点空间\n若问题改成要求删除结点*g的前驱结点*p，请读者思考具体的操作步骤。\n在建立双链表的操作中，也可采用如同单链表的头插法和尾插法，但在操作上需要注意指针\n的变化和单链表有所不同。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**双链表**\n- **定义**：链表结点包含两个指针（`prior`和`next`），分别指向直接前驱和直接后继，支持双向遍历。\n- **特性**：\n- 表头结点`prior`和尾结点`next`为`NULL`。\n- 按值/位查找与单链表相同（**O(n)**），但插入/删除前驱结点仅需**O(1)**。\n- **实现要点**：\n- **插入**（在结点`*p`后插入`*s`）：\n```c\ns->next = p->next;  // ① s后继指向p的原后继\nif (p->next) p->next->prior = s;  // ② p原后继的前驱指向s（非尾结点时）\ns->prior = p;      // ③ s前驱指向p\np->next = s;       // ④ p后继指向s\n```\n*记忆提示：先处理新结点`s`的指针，再调整原链表指针，避免断链。*\n- **删除**（删除`*p`的后继`*q`）：\n```c\np->next = q->next;          // ① p跳过q指向q的后继\nif (q->next) q->next->prior = p;  // ② q后继的前驱指向p（非尾结点时）\nfree(q);                    // 释放空间\n```\n- **优缺点**：\n- **优点**：双向遍历，快速操作前驱/后继。\n- **缺点**：额外空间存储前驱指针，插入/删除需维护更多指针。\n- **应用场景**：需频繁前向/后向遍历的场景（如浏览器历史记录、双向队列）。\n- **图示类比**：类似地铁双向轨道，可向前或向后行驶。"
    },
    {
        "id": "kc0234",
        "title": "循环链表",
        "chapter_id": "02",
        "description": "1.循环单链表\n循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，\n从而整个链表形成一个环，如图2.12所示。\n在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，\n循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针L。\n图2.12循环单链表\n命题追踪循环单链表中删除首元素的操作（2021）\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是，若操作是在表尾进行，则\n执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，\n所以在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。\n在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意\n个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。\n其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，\nr->next即头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度。\n2.循环双链表\n由循环单链表的定义不难推出循环双链表。不同的是，在循环双链表中，头结点的prior\n指针还要指向表尾结点，如图2.13所示。当某结点*p为尾结点时，p->next==L；当循环双链\n表为空表时，其头结点的prior域和next域都等于L。\n\n第2章线性\n表\n37\n图2.13循环双链表",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**循环链表**\n### **1. 循环单链表**\n- **定义**：单链表的变体，尾结点指针指向头结点而非`NULL`，形成闭环。\n- **特性**：\n- **判空条件**：头结点指针是否指向自身（`L->next == L`）。\n- **遍历特性**：可从任意结点出发遍历全表（单链表仅能从表头开始）。\n- **尾指针优化**：若仅设尾指针`r`，则`r->next`即头结点，**表头/尾插入**操作均为**O(1)**（头指针方案尾插需**O(n)**）。\n- **操作要点**：\n- 插入/删除逻辑与单链表基本一致，但需维护循环性（如尾插时更新尾结点指向头结点）。\n- **删除首元素**：需更新尾结点指针（若存在）以保持闭环。\n### **2. 循环双链表**\n- **定义**：双链表的循环版本，头结点`prior`指向尾结点，尾结点`next`指向头结点。\n- **特性**：\n- **判空条件**：头结点的`prior`和`next`均指向自身（`L->next == L && L->prior == L`）。\n- **双向遍历**：支持从任意结点向前或向后遍历。\n- **操作要点**：\n- 插入/删除需同步更新`prior`和`next`指针，确保闭环。\n### **对比与记忆提示**\n- **循环单链表** ≈ 单链表首尾相连，尾指针优化加速头尾操作。\n- **循环双链表** ≈ 双链表首尾双向相连，判空检查两个指针。\n- **关键区别**：循环链表无`NULL`指针，判空依赖指向头结点的自环。\n**应用场景**：需频繁头尾操作或循环遍历的场景（如轮询调度、约瑟夫问题）。"
    },
    {
        "id": "kc0235",
        "title": "静态链表",
        "chapter_id": "02",
        "description": "静态链表是用数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，\n与前面所讲的链表中的指针不同的是，这里的指针是结点在数组中的相对地址（数组下标），也\n称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。\n静态链表和单链表的对应关系如图2.14所示。\n2\n6\na\nd\n(a）静态链表示例\n(b)静态链表对应的单链表\n图2.14静态链表存储示意图\n静态链表结构类型的描述如下：\n#define MaxSize 50\n//静态链表的最大长度\ntypedef struct{\n//静态链表结构类型的定义\nElemType data;\n//存储数据元素\nint next;\n//下一个元素的数组下标\n)SLinkList[MaxSize];\n静态链表以next==-1作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，\n只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些\n不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**静态链表**\n- **定义**：用数组模拟链式存储结构的线性表，通过数组下标（游标）实现逻辑上的链表关系。\n- **结构**：\n- **数据域** `data`：存储元素值。\n- **指针域** `next`：记录下一个节点的数组下标（类似单链表的指针）。\n- **结束标志**：`next == -1`表示链表终止。\n- **特性**：\n- 预先分配连续内存空间（类似**顺序表**），但操作通过修改游标实现（类似**单链表**）。\n- 插入/删除仅需修改游标，无需移动元素，时间复杂度**O(1)**（需先查找为**O(n)**）。\n- **应用场景**：\n- 不支持指针的高级语言（如Basic）中替代动态链表。\n- 需固定内存分配的场景（如嵌入式系统）。\n- **优缺点**：\n- **优点**：避免频繁内存分配/释放，适合内存受限环境。\n- **缺点**：容量固定，灵活性低于动态链表；需手动管理空闲节点（类似内存池）。\n- **实现要点**：\n- 初始化时链表中所有节点为备用链（空闲状态），插入时从备用链分配节点。\n- 删除节点后需将其回收到备用链，防止内存“泄漏”。\n- **记忆提示**：\n- “数组当链表用，游标代指针”。\n- 插入/删除类比单链表，但操作对象是数组下标。"
    },
    {
        "id": "kc0236",
        "title": "顺序表和链表的比较",
        "chapter_id": "02",
        "description": "1.存取（读/写）方式\n顺序表既可以顺序存取，也可以随机存取，链表只能从表头开始依次顺序存取。例如在第i\n个位置上执行存取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。\n2.逻辑结构与物理结构\n采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻\n辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。\n3.查找、插入和删除操作\n对于按值查找，顺序表无序时，两者的时间复杂度均为O（n)：顺序表有序时，可采用折半查\n找，此时的时间复杂度为O(log2n)。对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，\n而链表的平均时间复杂度为O(n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链\n表的插入、删除操作，只需修改相关结点的指针域即可。\n\n38\n2026年数据结构考研复习指导\n4.空间分配\n顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出\n现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量\n闲置：预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元\n素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存\n储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。此外，链表\n的每个结点都带有指针域，因此存储密度不够大。\n在实际中应该怎样选取存储结构呢？\n1.基于存储的考虑\n难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链\n表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n2.基于运算的考虑\n在顺序表中按序号访问α,的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，\n因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且\n表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操\n作主要是比较操作，从这个角度考虑显然后者优于前者。\n3.基于环境的考虑\n顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前\n者实现较为简单，这也是用户考虑的一个因素。\n总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性\n表选择顺序存储，而频繁进行插入、删除操作的线性表（动态性较强）宜选择链式存储。\n注意\n只有熟练掌握顺序存储和链式存储，才能深刻理解它们的优缺点。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0234",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q023001",
            "q023002",
            "q023003",
            "q023004",
            "q023005",
            "q023006",
            "q023007",
            "q023008",
            "q023009",
            "q023010",
            "q023011",
            "q023012",
            "q023013",
            "q023014",
            "q023015",
            "q023016",
            "q023019",
            "q023022",
            "q023023",
            "q023024",
            "q023025",
            "q023027",
            "q023028",
            "q023029",
            "q023030",
            "q023032",
            "q023033",
            "q023034",
            "q023035",
            "q023036"
        ],
        "summry": "**顺序表和链表的比较**\n1. **存取方式**\n- **顺序表**：支持**随机存取**（直接访问第`i`个元素，**O(1)**）和顺序存取。\n- **链表**：仅支持**顺序存取**（必须从头遍历，**O(n)**）。\n2. **逻辑与物理结构**\n- **顺序表**：逻辑相邻的元素物理存储位置必然相邻（连续内存）。\n- **链表**：逻辑相邻的元素物理存储可能分散，通过指针链接逻辑关系。\n3. **操作效率**\n- **查找**：\n- 按值查找（无序）：均为**O(n)**。\n- 按值查找（有序顺序表）：可**折半查找**（**O(log n)**），链表仍为**O(n)**。\n- 按序号查找：顺序表**O(1)**，链表**O(n)**。\n- **插入/删除**：\n- 顺序表平均移动半数元素（**O(n)**）；链表仅修改指针（**O(1)**，不计查找时间）。\n4. **空间分配**\n- **顺序表**：\n- 静态分配：需预判规模，易溢出或浪费。\n- 动态分配：扩容需移动数据，可能失败。\n- **链表**：动态申请节点，空间利用率低（指针开销），但灵活无连续内存要求。\n**选择策略**\n- **存储考量**：链表适合长度不确定或动态增长；顺序表适合规模可预估。\n- **操作频率**：\n- 高频按序号访问 → 顺序表。\n- 高频插入/删除 → 链表。\n- **实现难度**：顺序表（数组）更易实现，链表需指针操作。\n**总结**\n- **顺序表**：稳定、少修改、高频随机访问场景。\n- **链表**：动态性强、频繁增删、长度变化大场景。\n**记忆提示**：\n- 顺序表 ≈ 数组：连续内存，快速访问，增删慢。\n- 链表 ≈ 珍珠串：离散存储，增删快，访问慢。"
    },
    {
        "id": "kc0311",
        "title": "栈的基本概念",
        "chapter_id": "03",
        "description": "1.栈的定义\n命题追踪栈的特点（2017）\n栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这\n种线性表只能在某一端进行插入和删除操作，如图3.1所示。\n\n第3章栈、队列和数组\n63\n出栈\n入栈\n栈顶\nas\nd4\na3\n栈底\n图3.1\n栈的示意图\n栈顶（Top）：线性表允许进行插入和删除操作的那一端。\n栈底（Bottom）：固定的，不允许进行插入和删除操作的另一端。\n空栈：不含任何元素的空表。\n命题追踪》入栈序列和出栈序列之间的关系（2022）\n命题追踪特定条件下的出栈序列分析（2010、2011、2013、2018、2020）\n假设某个栈S=（a1,α2,a3,a4,a5)，如图3.1所示，则a为栈底元素，as为栈顶元素。栈只能\n在栈顶进行插入和删除操作，入栈次序依次为a,a2,a3,a4,a，而出栈次序为as,a4,d3,d2,a。由\n此可见，栈的操作特性可以明显地概括为后进先出（Last InFirstOut，LIFO）。\n注意\n每接触一种新的数据结构，都应从其逻辑结构、存储结构和运算三个方面着手。\n2.栈的基本操作\n各种辅导书中给出的基本操作的名称不尽相同，但所表达的意思大致是一样的。这里我们以\n严蔚敏编写的教材为准给出栈的基本操作，希望读者能熟记下面的基本操作。\n·InitStack（&S）：初始化一个空栈S。\n·StackEmpty（S）：判断一个栈是否为空，若栈s 为空则返回true，否则返回false。\n·Push（&S，x)：入栈，若栈s 未满，则将x加入使之成为新栈顶。\n·Pop（&S，&x）：出栈，若栈s 非空，则弹出栈顶元素，并用x返回。\n·GetTop（S，&x)：读栈顶元素，但不出栈，若栈s 非空，则用x返回栈顶元素。\n·DestroyStack（&S）：销毁栈，并释放栈s占用的存储空间（“&”表示引用调用）。\n在解答算法题时，若题干未做出限制，则也可直接使用这些基本的操作函数。\nn+1\n为卡特兰数（Catalan）公式，可采用数学归纳法证明，有兴趣的读者可以参考组合数学教材。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ],
        "summry": "**栈的基本概念**\n- **定义**：限定仅在**栈顶**进行插入（入栈）和删除（出栈）操作的**线性表**，遵循**后进先出（LIFO）**原则。\n- **逻辑结构**：\n- **栈顶**（动态端）：唯一允许操作的一端。\n- **栈底**（固定端）：不进行操作的另一端。\n- **空栈**：不含任何元素的线性表。\n- **操作特性**：\n- 入栈序列为a₁→a₂→…→aₙ时，合法出栈序列需满足**卡特兰数**（总数为$\\frac{1}{n+1}C_{2n}^n$）。\n- 典型问题：给定入栈序列，判断某出栈序列是否合法（如2010、2018等真题）。\n- **核心操作**（严蔚敏教材标准）：\n- `InitStack(&S)`：初始化空栈。\n- `StackEmpty(S)`：判空，返回布尔值。\n- `Push(&S, x)`：元素`x`入栈（需检查栈满）。\n- `Pop(&S, &x)`：栈顶元素出栈并存入`x`（需检查栈空）。\n- `GetTop(S, &x)`：读取栈顶元素（不出栈）。\n- `DestroyStack(&S)`：销毁栈并释放内存。\n- **应用场景**：\n- 函数调用栈（保存返回地址/局部变量）。\n- 表达式求值（中缀转后缀，处理括号匹配）。\n- 浏览器前进后退、撤销操作（双栈实现）。\n- **记忆技巧**：\n- **LIFO** ≈ 叠盘子（最后放的先取用）。\n- **卡特兰数**：n个元素的合法出栈序列总数（如n=3时为5种）。"
    },
    {
        "id": "kc0312",
        "title": "栈的顺序存储结构",
        "chapter_id": "03",
        "description": "栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。\n1.顺序栈的实现\n采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元\n素，同时附设一个指针（top）指示当前栈顶元素的位置。\n栈的顺序存储类型可描述为\n#define MaxSize 50\n//定义栈中元素的最大个数\ntypedef struct\n\n64\n2026年数据结构考研复习指导\nElemtype data[MaxSize];\n1/存放栈中元素\nint top;\n//栈顶指针\n)SqStack;\n栈顶指针：S.top，初始时设置s.top=-1；栈顶元素：S.data[S.top］。\n入栈操作：栈不满时，栈顶指针先加1，再送值到栈顶。\n出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1。\n栈空条件：S.top==-1；栈满条件：S.top==MaxSize-1；栈长：S.top+1。\n另一种常见的方式是：初始设置栈顶指针S.top=0：入栈时先将值送到栈顶，栈顶指针再\n加1；出栈时，栈顶指针先减1，再取栈顶元素；栈空条件是S.top==0；栈满条件是\nS.top==MaxSizeo\n顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上\n溢，此时应及时向用户报告消息，以便及时处理，避免出错。\n注意\n栈和队列的判空、判满条件，会因实际给出的条件不同而变化，下面的代码实现是在栈顶指针初始\n化为-1的条件下的相应方法，而其他情况则需具体问题具体分析。\n2.顺序栈的基本操作\n命题追踪出/入栈操作的模拟（2009）\n栈操作的示意图如图3.2所示，图3.2（a)是空栈，图3.2（c)是A、B、C、D、E共5个元素依\n次入栈后的结果，图3.2(d)是在图3.2(c)之后E、D、C的相继出栈，此时栈中还有2个元素，或\n许最近出栈的元素C、D、E仍在原先的单元存储着，但top指针已经指向了新的栈顶，元素C、\nD、E已不在栈中，读者应通过该示意图深刻理解栈顶指针的作用。\ntop\nE\nD\nC\nB\ntop\ntop\ntop\n(a)空栈\n(b）1个元素\n(c）5个元素\n(d)2个元素\n图3.2栈顶指针和栈中元素之间的关系\n下面是顺序栈上常用的基本操作的实现。\n（1）初始化\nvoid InitStack(SqStack &S)(\nS.top=-1;\n/初始化栈顶指针\n（2）判栈空\nbool StackEmpty(SqStack S)(\nif(s.top==-1)\n//栈空\nreturn\ntrue;\nelse\nI/不空\nreturnfalse;\n（3）入栈\nbool Push(SqStack &S,ElemType x)(\n\n第3章栈、队列和数组\n65\nif(S.top==MaxSize-1)\n//栈满，报错\nreturn false;\nS.data[++s.top]=x;\n//指针先加1，再入栈\nreturn true;\n当栈不满时，top先加1，再入栈。若初始时将top定义为0，函数3和4应如何改写？\n（4）出栈\nbool Pop(SqStack &S,ElemType &x)(\nif(s.top==-1)\n//栈空，报错\nreturn false;\nx=S.data[s.top--];\n//先出栈，指针再减1\nreturn true;\n（5）读栈顶元素\nbool GetTop(SqStack S,ElemType &x){\nif(s.top==-1)\n//栈空，报错\nreturn false;\nx=S.data[s.top];\n//x记录栈顶元素\nreturn true;\n仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。\n注意\n这里的top指的是栈顶元素。于是，入栈操作为s.data[++s.top］=x，出栈操作为\nx=S.data[S.top--]。若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，则入栈操\n作变为 S.data[S.top++]=x；出栈操作变为 x=S.data[--S.top]。相应的栈空、栈满条件也会发\n生变化。请读者仔细体会其中的不同之处，做题时要灵活应变。\n3.共享栈\n利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分\n别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图3.3所示。\n0\nMaxSize-l\n栈数组\n0号栈栈底\n0号栈栈顶1号栈栈顶\n1号栈栈底\n图3.3两个顺序栈共享存储空间\n两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为\n再赋值，1号栈入栈时top1先减1再赋值；出栈时则刚好相反。\n共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满\n时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0313",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ],
        "summry": "**栈的顺序存储结构**\n- **定义**\n采用**顺序存储**的栈，通过连续存储单元存放元素，并附设栈顶指针（`top`）动态指示栈顶位置。\n- **存储结构**\n```c\n#define MaxSize 50\ntypedef struct {\nElemType data[MaxSize]; // 存储栈元素\nint top;                // 栈顶指针（初始为-1或0）\n} SqStack;\n```\n- **核心操作**\n- **初始化**：`S.top = -1`（或`0`，需同步调整其他逻辑）。\n- **入栈**：先移动`top`再赋值（`S.data[++S.top] = x`）。\n- **出栈**：先取值再移动`top`（`x = S.data[S.top--]`）。\n- **判空**：`S.top == -1`（若初始为`0`则判`S.top == 0`）。\n- **判满**：`S.top == MaxSize - 1`（若初始为`0`则判`S.top == MaxSize`）。\n- **关键细节**\n- **指针初始值影响逻辑**：\n- `top = -1`：先`++top`再存值，栈空条件为`-1`。\n- `top = 0`：先存值再`top++`，栈空条件为`0`。\n- **时间复杂度**：所有操作均为**O(1)**。\n- **栈溢出**：顺序栈大小固定，需提前预估容量。\n- **共享栈**\n- **原理**：两个栈共享同一数组，栈底分别位于两端，栈顶向中间延伸。\n- **操作**：\n- **0号栈**：`top0`初始为`-1`，入栈`++top0`，出栈`top0--`。\n- **1号栈**：`top1`初始为`MaxSize`，入栈`--top1`，出栈`top1++`。\n- **优势**：空间利用率高，仅当`top0 + 1 == top1`时栈满。\n- **记忆提示**\n- **入栈口诀**：指针先动再赋值（`top=-1`时），或先赋值再动指针（`top=0`时）。\n- **共享栈**：想象两栈“背靠背”生长，中间相遇即满。\n- **典型问题**\n- 注意题目中`top`初始值的设定，直接影响判空/满条件和操作顺序。\n- 共享栈的栈满条件是`top0 + 1 == top1`，而非单个栈的边界检查。"
    },
    {
        "id": "kc0313",
        "title": "栈的链式存储结构",
        "chapter_id": "03",
        "description": "采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存\n在栈满上溢的情况。通常采用单链表实现链栈，并规定所有操作都是在单链表的表头进行的。这\n里规定链栈没有头结点，Lhead指向栈顶元素，如图3.4所示。\n\n66\n2026年数据结构考研复习指导\n栈顶结点\n栈底结点\nLhead-\na2\na\n图3.4栈的链式存储\n栈的链式存储类型可描述为\ntypedef struct Linknodet\nElemType data;\n//数据域\nstruct Linknode *next;\n/指针域\n)LiStack;\n//栈类型定义\n采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链\n表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体的实现会有所不同。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0231",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0232",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0331",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q031001",
            "q031002",
            "q031003",
            "q031004",
            "q031005",
            "q031006",
            "q031007",
            "q031008",
            "q031009",
            "q031010",
            "q031011",
            "q031012",
            "q031013",
            "q031014",
            "q031015",
            "q031016",
            "q031017",
            "q031018",
            "q031019",
            "q031021",
            "q031022",
            "q031023",
            "q031024",
            "q031025",
            "q031026",
            "q031027",
            "q031028",
            "q031029",
            "q031030",
            "q031031"
        ],
        "summry": "**栈的链式存储结构**\n- **定义**：采用单链表实现的栈结构，所有操作（入栈/出栈）均在链表**表头**进行，无头结点，`Lhead`直接指向栈顶元素。\n- **特性**：\n- **动态扩容**：无栈满上溢问题，适合动态数据场景。\n- **高效操作**：表头操作保证**O(1)**时间复杂度（插入/删除无需遍历）。\n- **共享空间**：多个链栈可共享存储池，提高内存利用率。\n- **实现要点**：\n- **结点结构**：含`data`（数据域）和`*next`（指针域），类型定义为`LiStack`。\n- **关键差异**：带头结点时，`Lhead->next`为栈顶；不带头结点时，`Lhead`即为栈顶。\n- **核心操作**：\n- **入栈**：新建结点插入表头，更新`Lhead`（类比“叠盘子”）。\n- **出栈**：删除表头结点，`Lhead`指向下一结点。\n- **应用场景**：函数调用栈、表达式求值（需快速存取最近操作数）。\n- **记忆提示**：链栈≈“倒置的单链表”，操作始终在头部（`Lhead`即栈顶）。"
    },
    {
        "id": "kc0321",
        "title": "队列的基本概念",
        "chapter_id": "03",
        "description": "1.队列的定义\n队列（Queue）简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表\n的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们\n日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是先进先出（FirstIn\nFirstOut，FIFO），如图3.5所示。\n\n76\n2026年数据结构考研复习指导\n出队列\na),a,a3,a4.as\n入队列\n队头\n队尾\n图3.5队列示意图\n队头（Front）：允许删除的一端，也称队首。\n队尾（Rear）：允许插入的一端。\n空队列：不含任何元素的空表。\n2.队列常见的基本操作\nInitQueue（&Q)：初始化队列，构造一个空队列Q。\nQueueEmpty（Q)：判队列空，若队列Q为空返回true，否则返回false。\nEnQueue（&Q，x)：入队，若队列Q未满，将×加入，使之成为新的队尾。\nDeQueue（&Q，&x）：出队，若队列Q非空，删除队首元素，并用x返回。\nGetHead（Q，&x）：读队首元素，若队列Q非空，则将队首元素赋值给x。\n需要注意的是，栈和队列是操作受限的线性表，因此不是任何对线性表的操作都可以作为栈\n和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0323",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0335",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ],
        "summry": "**队列**\n- **定义**：操作受限的线性表，遵循**先进先出（FIFO）**原则，仅允许在**队尾（Rear）**插入（入队），在**队头（Front）**删除（出队）。空队列不含任何元素。\n- **核心特性**：\n- **FIFO结构**：类比日常排队，先到者先服务。\n- **受限操作**：不支持随机访问中间元素（与栈类似）。\n- **基本操作**：\n- `InitQueue(&Q)`：初始化空队列。\n- `QueueEmpty(Q)`：判空，返回布尔值。\n- `EnQueue(&Q, x)`：元素`x`入队至队尾。\n- `DeQueue(&Q, &x)`：队首元素出队，并通过`x`返回。\n- `GetHead(Q, &x)`：读取队首元素（不删除）。\n- **应用场景**：任务调度、缓冲区管理、广度优先搜索（**BFS≈队列**）。\n- **快速记忆**：\n- **队列≈管道**：数据从一端进，另一端出，顺序严格。\n- **与栈对比**：栈是**后进先出（LIFO）**，队列是**FIFO**。"
    },
    {
        "id": "kc0322",
        "title": "队列的顺序存储结构",
        "chapter_id": "03",
        "description": "1.队列的顺序存储\n队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队首指\n针front指向队首元素，队尾指针rear指向队尾元素的下一个位置（不同教材对front和rear\n的定义可能不同，例如，可以让rear指向队尾元素、front指向队首元素。对于不同的定义，\n出入队的操作是不同的，本节后面有一些相关的习题，读者可以结合习题思考）。\n队列的顺序存储类型可描述为\n#define MaxSize 50\n1定义队列中元素的最大个数\ntypedef struct{\nElemType data[MaxSize];\n//用数组存放队列元素\nint front,rear;\n/队首指针和队尾指针\n)SqQueue;\n初始时：Q.front=Q.rear=0。\n入队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n出队操作：队不空时，先取队首元素值，再将队首指针加1。\n图3.6(a)所示为队列的初始状态，有Q.front==Q.rear==0成立，该条件可以作为队列判\n空的条件。\ncear\nfront\nd\nb\nfront\nfront\na\nrear\n(a)空队\n(b)5个元素入队\n(c）出队1次\n(d）出队3次\n图3.6队列的操作\n但能否用Q.rear==MaxSize作为队列满的条件呢？显然不能，图3.6（d)中，队列中仅有一\n\n第3章栈、队列和数组\n77\n个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在data\n数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。\n2.循环队列\n上面指出了顺序队列“假溢出”的问题，这里引出循环队列的概念。将顺序队列臆造为一个\n环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=\nMaxSize-1后，再前进一个位置就自动到0，这可以利用除法取模运算（%）来实现。\n命题追踪特定条件下循环队列队头/队尾指针的初值（2011）\n初始时：Q.front=Q.rear=0。\n队首指针进1：Q.front=（Q.front+1）%MaxSize。\n队尾指针进1：Q.rear=（Q.rear+1）%MaxSize。\n队列长度：（Q.rear+MaxSize-Q.front）MaxSize。\n出入队时：指针都按顺时针方向进1（如图3.7所示）。\n命题追踪特定条件下循环队列队空/队满的判断条件（2014）\n那么，循环队列队空和队满的判断条件是什么呢？显然，队空的条件是Q.front==Q.rear。\n若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图3.7（d1)所示，\n此时可以看出队满时也有Q.front==Q.rear。循环队列出入队示意图如图3.7所示。\nQ.front\nQ.front\n(a）初始空队\n(b)a、b、c入队\n(c)all队\nQ.front\n（d1)d、e、f、g入队\n(d2)d、e、f入队\n（无法判断队满还是队空）\n（牺牲个存储单元）\n图3.7循环队列出入队示意图\n为了区分是队空还是队满的情况，有三种处理方式：\n1）牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，\n约定以“队首指针在队尾指针的下一位置作为队满的标志”，如图3.7（d2）所示。\n队满条件：（Q.rear+1）%MaxSize==Q.front。\n队空条件：Q.front==Q.rear。\n队列中元素的个数：（Q.rear-Q.front+MaxSize）%MaxSize。\n2）类型中增设size数据成员，表示元素个数。若删除成功，则size减1，若插入成功，\n\n78\n2026年数据结构考研复习指导\n则size加1，队空时Q.size==0；队满时Q.size==MaxSize，两种情况都有\nQ.front==Q.rear.\n3）类型中增设tag数据成员，以区分是队满还是队空。删除成功置tag=0，若导致\nQ.front==Q.rear，则为队空；插入成功置tag=1，若导致Q.front==Q.rear，则\n为队满。\n3.循环队列的操作\n（1）初始化\nvoid InitQueue(SqQueue &Q)(\nQ.rear=Q.front=0;\n/初始化队首、队尾指针\n（2）判队空\nbool isEmpty(SqQueue Q)(\nif(Q.rear==Q.front)\n/队空条件\nreturn true;\nelse\nreturn false;\n（3）入队\nbool EnQueue(SqQueue &Q,ElemType x){\nif((Q.rear+1)%MaxSize==Q.front)\n//队满则报错\nreturn false;\nQ.data[Q.rear]=x;\nQ.rear=(Q.rear+l)MaxSize;\n/队尾指针加1取模\nreturn true;\n（4）出队\nbool DeQueue(SqQueue &Q,ElemType &x)(\nif(Q.rear==Q.front)\n/队空则报错\nreturn false;\nx=Q.data[Q.front];\nQ.front=(Q.front+1)%MaxSize;\n//队首指针加1取模\nreturn true;",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "extension"
            },
            {
                "id": "kc0121",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0334",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0335",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0631",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ],
        "summry": "**队列的顺序存储结构**\n- **定义**：用连续存储单元（数组）实现队列，通过**front**（队首指针）和**rear**（队尾指针）管理元素位置。\n- **初始化**：`Q.front = Q.rear = 0`（指向同一位置表示空队）。\n- **存储类型**：\n```c\n#define MaxSize 50\ntypedef struct {\nElemType data[MaxSize];\nint front, rear;\n} SqQueue;\n```\n- **基本操作**：\n- **入队**：队尾插入元素，`rear = (rear + 1) % MaxSize`（需先检查队满）。\n- **出队**：队首取出元素，`front = (front + 1) % MaxSize`（需先检查队空）。\n- **假溢出问题**：\n- 顺序队列中，`rear == MaxSize`但仍有空间未利用（因`front`移动后未重置底层数组）。\n- **解决**：通过**循环队列**逻辑成环，利用取模运算实现指针循环（`(rear + 1) % MaxSize`）。\n- **循环队列判空/满**（三种方法）：\n1. **牺牲一个单元**：\n- 队满：`(rear + 1) % MaxSize == front`。\n- 队空：`front == rear`。\n2. **增设size字段**：\n- 队空：`size == 0`；队满：`size == MaxSize`。\n3. **增设tag标志**：\n- `tag=1`且`front == rear`时为队满；`tag=0`且`front == rear`时为队空。\n- **关键公式**：\n- 队列长度：`(rear - front + MaxSize) % MaxSize`。\n- 指针移动：`front/rear = (front/rear + 1) % MaxSize`。\n- **应用场景**：\n- 需要**FIFO**特性的场景（如任务调度、缓冲区管理）。\n- **快速记忆**：循环队列≈环形跑道，队尾追队首即满（牺牲单元法）。\n- **实现示例**：\n```c\nbool EnQueue(SqQueue &Q, ElemType x) {\nif ((Q.rear + 1) % MaxSize == Q.front) return false; // 队满\nQ.data[Q.rear] = x;\nQ.rear = (Q.rear + 1) % MaxSize;\nreturn true;\n}\n```"
    },
    {
        "id": "kc0323",
        "title": "",
        "chapter_id": "03",
        "description": "队列的链式存储结构\n1.队列的链式存储\n命题追踪根据需求分析队列适合的存储结构（2019）\n队列的链式表示称为链式队列，它实际上是一个同时有队首指针和队尾指针的单链表，如\n图3.8所示。队首指针指向队头结点，队尾指针指向队尾结点，即单链表的最后一个结点。\nrear\nfront-\n“D\n图3.8不带队头结点的链式队列\n队列的链式存储类型可描述为\ntypedef struct LinkNodet\n//链式队列结点\nElemType data;\nstruct LinkNode *next;\n)LinkNode;\n\n第3章栈、队列和数组\n79\ntypedef struct(\n//链式队列\nLinkNode *front,*rear;\n/队列的队头和队尾指针\n)LinkQueue;\n不带头结点时，当Q.front==NULL且Q.rear==NULL时，链式队列为空。\n命题追踪链式队列队空的判断（2019）\n入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear 指向这个新插入的结\n点（若原队列为空队，则令Q.front也指向该结点）。出队时，首先判断队是否为空，若不空，\n则取出队首元素，将其从链表中删除，并让Q.front指向下一个结点（若该结点为最后一个结\n点，则置Q.front和Q.rear都为NULL）。\n不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个\n带头结点的单链表，这样插入和删除操作就统一了，如图3.9所示。\nrear\nfront-\nfront-\n图3.9带队头结点的链式队列\n用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生\n溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样\n就不会出现存储分配不合理和“溢出”的问题。\n2.链式队列的基本操作\n命题追踪链式队列出队/入队操作的基本过程（2019）\n（1）初始化\nvoidInitQueue（LinkQueue&Q）（//初始化带头结点的链式队列\nQ.front=Q.rear=（LinkNode*）malloc(sizeof(LinkNode））;//建立头结点\nQ.front->next=NULL;\n//初始为空\n（2）判队空\nbool IsEmpty(LinkQueue Q)(\nif（Q.front==Q.rear）\n//判空条件\nreturn true;\nelse\nreturn false;\n（3）入队\nvoid EnQueue(LinkQueue &Q,ElemType x){\nLinkNode*s=（LinkNode*）malloc（sizeof（LinkNode））;//创建新结点\ns->data=x;\ns->next=NULL;\nQ.rear->next=s;\n/插入链尾\nQ.rear=s;\n//修改尾指针\n（4）出队\nbool DeQueue(LinkQueue &Q,ElemType &x) {\nif(Q.front==Q.rear)\nreturn false;\n//空队\n\n80\n2026年数据结构考研复习指导\nLinkNode *p=Q.front->next;\nx=p->data;\nQ.front->next=p->next;\nif(Q.rear==p)\nQ.rear=Q.front;\nⅡ若原队列中只有一个结点，删除后变空\nfree(p);\nreturn true;",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0332",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0335",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ],
        "summry": "**队列的链式存储结构**\n- **定义**：用单链表实现的队列，包含**队首指针（front）**和**队尾指针（rear）**，分别指向链表的头结点和尾结点。\n- **存储类型**：\n```c\ntypedef struct LinkNode {   // 链式队列结点\nElemType data;\nstruct LinkNode *next;\n} LinkNode;\ntypedef struct {           // 链式队列\nLinkNode *front, *rear; // 队头和队尾指针\n} LinkQueue;\n```\n- **特性**：\n- **不带头结点**：判空条件为 `Q.front == NULL && Q.rear == NULL`，操作较复杂（需特殊处理空队插入）。\n- **带头结点**：统一操作逻辑，判空条件为 `Q.front == Q.rear`（头尾指针指向同一结点）。\n- **优点**：动态分配内存，无溢出风险；适合数据变动大或多队列场景。\n- **缺点**：需额外空间存储指针，操作略慢于顺序队列。\n- **核心操作**（带头结点）：\n1. **初始化**：创建头结点，`front` 和 `rear` 均指向它，`next` 置 `NULL`。\n2. **入队**：新结点插入链尾，更新 `rear`；若原队列为空，`front->next` 同步更新。\n```c\ns->next = NULL; Q.rear->next = s; Q.rear = s;\n```\n3. **出队**：删除 `front->next` 结点，若队列仅剩一个结点，出队后需置 `rear = front`。\n4. **判空**：`front == rear`。\n- **时间复杂度**：\n- 入队/出队：**O(1)**（直接操作指针，无元素移动）。\n- **应用场景**：\n- 数据规模变化频繁（如动态任务调度）。\n- 多队列共存时避免存储浪费（如操作系统多级就绪队列）。\n- **记忆提示**：\n- 链式队列 ≈ 单链表 + 队首队尾指针。\n- 带头结点 → 操作统一；不带头结点 → 边界处理多。"
    },
    {
        "id": "kc0324",
        "title": "",
        "chapter_id": "03",
        "description": "双端队列\n双端队列是指允许两端都可以进行插入和删除操作的线性表，如图3.10所示。双端队列两端\n的地位是平等的，为了方便理解，将左端也视为前端，右端也视为后端。\n后端\n插入\n插入\na\na2\nan1\na\n删除\n删除\n图3.10双端队列\n在双端队列入队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在\n队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在\n后出的元素的前面。思考：如何由入队序列a.b.c.d得到出队序列dca.b？\n命题追踪双端队列出队/入队操作模拟（2010、2021）\n输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为\n输出受限的双端队列，如图3.11所示。\n前端\n后端\n插入\na\na2\n插入\nan\n删除\n图3.11输出受限的双端队列\n输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为\n输入受限的双端队列，如图3.12所示。若限定双端队列从某个端点插入的元素只能从该端点删除，\n则该双端队列就蜕变为两个栈底相邻接的栈。\n后端\n插入\na\na2\nd3\nan-1\na\n删除\n删除\n图3.12输入受限的双端队列\n例设有一个双端队列，输入序列为1，2，3，4，试分别求出以下条件的输出序列。\n（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列。\n（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列。\n（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列。\n解：先看输入受限的双端队列，如图3.13所示。假设end1端输入1,2,3，4，则end2端的输\n出相当于队列的输出，即1,2,3,4；而end1端的输出相当于栈的输出，n=4时仅通过end1端有\n14种输出序列（由Catalan公式得出），仅通过end1端不能得到的输出序列有4！-14=10种：\n\n第3章栈、队列和数组\n81\n1,4,2,3\n2,4,1,3\n3,4,1,2\n3,1,4,2\n3,1,2,4\n4,3,1,2\n4, 1,3,2\n4,2,3, 1\n4,2,1,3\n4,1,2,3\n通过end1和end2端混合输出，可以输出这10种中的8种，参看下表。其中，SL,XL分别代\n表end1端的入队和出队，XR代表end2端的出队。\n输出序列\n入队出队顺序\n输出序列\n入队出队顺序\n1,4,2,3\nSLXRSLSLSLXIXRXR\n3, 1,2,4\nSLSSLXLSLXRXRXR\n2,4,1,3\nSSLXLSISLXLXRXR\n4,1,2,3\nSSLSLSLXXRXRAR\n3,4,1,2\nSLSLSLXLSLXIXRXR\n4,1,3,2\nSSSLSLXLXRXXR\n3,1,4,2\nSSISLXLXRSLXXR\n4,3,1,2\nSSSSXXXRXR\n剩下两种是不能通过输入受限的双端队列输出的，即4,2，3，1和4,2,1,3。\n再看输出受限的双端队列，如图3.14所示。假设end1端和end2端都能输入，仅end2端可\n以输出。若都从end2端输入，就是一个栈了。当输入序列为1,2，3，4时，输出序列有14种。对\n于其他10种不能得到的输出序列，交替从end1和end2端输入，还可以输出其中8种。设SL代\n表end1端的输入，SR、X分别代表end2端的输入和输出，则可能的输出序列见下表。\n←\nend1\nend2\nendi\nend2\n图3.13例题中输入受限的双端队列\n图3.14例题中输出受限的双端队列\n输出序列\n入队出队顺序\n输出序列\n入队出队顺序\n1,4,2,3\nSLXRSLSISRXRXRYR\n3, 1,2,4\nSLSLSRXRXRSLXRXR\n2,4,1,3\nSISRYRSLSRYRXRXR\n4, 1,2,3\nSSISLSRXRXRXRYR\n3,4,1,2\nSLSLSRXRSRYRXRXR\n4,2,1,3\nSSRSLSRXRXRXRXR\n3,1,4,2\nSSLSRXRXRSRXRXR\n4,3, 1, 2\nSLSLSRSRXRXRXRXR\n通过输出受限的双端队列不能得到的两种输出序列是4,1,3,2和4,2,3,1。\n综上所述：\n1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的是4，1,3，2。\n2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的是4,2，1，3。\n3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的是4，2，3，1。\n提示\n实际双端队列的考题不会这么复杂，通常仅判断序列是否满足题设条件，代入验证即可。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0331",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0332",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q032001",
            "q032002",
            "q032003",
            "q032005",
            "q032006",
            "q032007",
            "q032008",
            "q032009",
            "q032010",
            "q032012",
            "q032013",
            "q032014",
            "q032015",
            "q032017",
            "q032019",
            "q032020",
            "q032021"
        ],
        "summry": "**双端队列**\n- **定义**：允许在**前端**和**后端**进行插入与删除的线性表，两端操作对称（左=前端，右=后端）。\n- **核心特性**：\n- **入队规则**：前端插入元素位于后端插入元素之前，后端插入元素位于前端插入元素之后。\n- **出队规则**：无论从哪端出队，先出元素始终排列在后出元素之前。\n- **时间复杂度**：两端插入/删除均为 **O(1)**（理想实现下）。\n- **变种**：\n- **输出受限双端队列**：一端仅允许插入，另一端允许插入和删除（如后端仅插入）。\n- **输入受限双端队列**：一端仅允许删除，另一端允许插入和删除（如后端仅删除）。\n- *特例*：若限制插入端与删除端必须相同，则退化为**两个相邻栈**。\n- **应用场景**：滑动窗口算法、撤销操作历史记录、多线程任务调度。\n**典型问题分析**（输入序列1,2,3,4）：\n1. **输入受限可得，输出受限不可得**：`4,1,3,2`\n2. **输出受限可得，输入受限不可得**：`4,2,1,3`\n3. **两者均不可得**：`4,2,3,1`\n- **快速验证法**：模拟两端操作序列，优先尝试混合端操作。\n**记忆提示**：\n- 双端队列 ≈ **双向通道**，两端进出自由；受限变种 ≈ **单行道**（一端封闭）。\n- 序列合法性判断：画操作步骤图，排除不可能的组合。"
    },
    {
        "id": "kc0331",
        "title": "栈在括号匹配中的应用",
        "chapter_id": "03",
        "description": "假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序任意即（[]（））或[（[][]）]\n等均为正确的格式，【（]）或（[（））或（（）］均为不正确的格式。\n考虑下列括号序列：\n\n90\n2026年数据结构考研复习指导\n2\n5\n分析如下：\n1）计算机接收第1个括号“”后，期待与之匹配的第8个括号“]”出现\n2）获得了第2个括号“（”，此时第1个括号“”暂时放在一边，而急迫期待与之匹配的第\n7个括号“）”出现。\n3）获得了第3个括号“[”，此时第2个括号“（”暂时放在一边，而急迫期待与之匹配的第\n4个括号“]”出现。第3个括号的期待得到满足，消解之后，第2个括号的期待匹配又\n成为当前最急迫的任务。\n4）以此类推，可见该处理过程与栈的思想吻合。\n算法的思想如下：\n1）初始设置一个空栈，顺序读入括号。\n2）若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的栈中所有未消解的\n期待的急迫性降了一级。\n3）若是右括号，则或使置于栈顶的最急迫期待得以消解，或是不合法的情况（括号序列不\n匹配，退出程序）。算法结束时，栈为空，否则括号序列不匹配。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0313",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0332",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ],
        "summry": "**栈在括号匹配中的应用**\n- **定义**：利用**栈**的**后进先出（LIFO）**特性，检查括号序列的嵌套合法性。\n- **核心原理**：\n- 遇到**左括号**（`(`、`[`）时压栈，表示新增一个**待匹配的期待**。\n- 遇到**右括号**（`)`、`]`）时，检查栈顶是否为其对应的左括号：\n- 匹配则弹出栈顶（消解当前最急迫的期待）；\n- 不匹配或栈空则序列非法。\n- **最终栈空**表示所有括号正确闭合。\n- **时间复杂度**：**O(n)**（n为括号序列长度，每个括号仅入栈/出栈一次）。\n- **空间复杂度**：**O(n)**（最坏情况下所有括号入栈）。\n- **关键步骤**：\n1. 初始化空栈；\n2. 遍历括号序列：\n- 左括号 → 压栈；\n- 右括号 → 检查栈顶并弹栈（若匹配）。\n3. 最终栈空则合法，否则非法。\n- **示例**：\n- 合法序列 `[()[]]`：\n- `[`入栈 → `(`入栈 → `)`匹配`(` → `[`入栈 → `]`匹配`[` → `]`匹配`[` → 栈空。\n- 非法序列 `[(])`：\n- `[`入栈 → `(`入栈 → `]`不匹配`(` → 报错。\n- **记忆提示**：\n- **“后来先验”**：最后出现的左括号需优先匹配（栈顶）。\n- **“栈空即合法”**：所有期待需完全消解。\n- **应用场景**：编译器语法检查、表达式求值、JSON/XML标签匹配等。"
    },
    {
        "id": "kc0332",
        "title": "栈在表达式求值中的应用",
        "chapter_id": "03",
        "description": "表达式求值是程序设计语言编译中一个最基本的问题，它是栈应用的一个典型范例。\n1.算术表达式\n中缀表达式（如3+4）是人们常用的算术表达式，操作符以中缀形式处于操作数的中间。与\n前缀表达式（如+34）或后缀表达式（如34+）相比，中缀表达式不容易被计算机解析，但仍被\n许多程序语言使用，因为它更符合人们的思维习惯。\n与前缀表达式或后缀表达式不同的是，中缀表达式中的括号是必需的。计算过程中必须用括\n号将操作符和对应的操作数括起来，用于指示运算的次序。后缀表达式的运算符在操作数后面，\n后缀表达式中考虑了运算符的优先级，没有括号，只有操作数和运算符。\n中缀表达式A+B*（C-D）-E/F对应的后缀表达式为ABCD-*+EF/-，将后缀表达式与原表达\n式对应的表达式树（图3.15）的后序遍历序列进行比较，可发现它们有异曲同工之妙。\n图3.15A+B*（C-D)-E/F对应的表达式树\n2.中缀表达式转后级表达式\n命题追踪中缀表达式转后缀表达式的方法（2024）\n下面先给出一种由中缀表达式转后缀表达式的手算方法。\n①中缀转前缀的方法类似，且统考真题仅考查过中缀转后缀的过程，因此本节仅介绍中缀转后缀的方法。\n\n第3章栈、队列和数组\n91\n1）按照运算符的运算顺序对所有运算单位加括号。\n3）去除所有括号。\n例如，中缀表达式A+B*（C-D）-E/F转后缀表达的过程如下（下标表示运算符的运算顺序）：\n1）加括号：（(A+③(B*②(C-①D)))-③(E/@F))。\n2）运算符后移：（(A(B(CD)-①）*②）+③(EF)/①)-③\n3）去除括号后，得到后缀表达式：ABCD-①*②+EF/@-\n在计算机中，中缀表达式转后缀表达式时需要借助一个栈，用于保存暂时还不能确定运算顺\n序的运算符。从左到右依次扫描中缀表达式中的每一项，具体转化过程如下：\n1）遇到操作数。直接加入后缀表达式。\n2）遇到界限符。若为“（”，则直接入栈；若为“）”，则不入栈，且依次弹出栈中的运算\n符并加入后缀表达式，直到遇到“（”为止，并直接删除“（”。\n3）遇到运算符。①若其优先级高于栈顶运算符或遇到栈顶为“（”，则直接入栈：②若其优\n先级低于或等于栈顶运算符，则依次弹出栈中的运算符并加入后缀表达式，直到遇到一\n个优先级低于它的运算符或遇到“（”或栈空为止，之后将当前运算符入栈。\n按上述方法扫描所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。\n例如，中缀表达式A+B*（C-D)-E/F转后缀表达式的过程如表3.1所示。\n表3.1中缀表达式A+B*（C-D）-E/F转后缀表达式的过程\n步\n待处理序列\n栈内\n后缀表达式\n扫描项\n说\n明\nA+B*(C-D)-E/E\nA\nA加入后缀表达式\n2\n+B*(C-D)-E/F\nA\n+\n+入栈\nB*(C-D)-E/E\n+\nA\nB\nB加入后缀表达式\n*(C-D)-E/E\n+\nAB\n*\n*优先级高于栈顶，*入栈\n5\n(C-D)-E/F\n+*\nAB\n（直接入栈\n6\nC-D)-E/F\n+*（\nAB\nC\nC加入后缀表达式\nD)-E/F\n+*(\nABC\n栈顶为（，-直接入栈\n8\nD)-E/F\n+*（-\nABC\nD\nD加入后缀表达式\n9\n)-E/E\n+*（-\nABCD\n遇到），弹出-，删除（\n10\n-E/E\n+*\nABCD-\n-优先级低于栈顶，依次弹出*、+，-入栈\n11\nE/E\nABCD-*+\nE\nE加入后缀表达式\n12\n/E\nABCD-*+E\n/\n/优先级高于栈顶，/入栈\n一\n13\n-/\nABCD-*+E\nF\nF加入后缀表达式\n14\n-/\nABCD-*+EF\n字符扫描完毕，弹出剩余运算符\nABCD-*+EE/-\n结束\n命题追踪\n栈的深度分析（2009、2012）\n所谓栈的深度，是指栈中的元素个数，通常是给出入栈和出栈序列，求最大深度（栈的容量\n应大于或等于最大深度）。有时会间接给出入栈和出栈序列，例如以中缀表达式和后缀表达式的\n形式给出入栈和出栈序列。掌握栈的先进后出的特点进行手工模拟是解决这类问题的有效方法。\n3.后缀表达式求值\n命题追踪月\n用栈实现表达式求值的分析（2018）\n通过后缀表示计算表达式值的过程：从左往右依次扫描表达式的每一项，若该项是操作数，\n\n92\n2026年数据结构考研复习指导\n则将其压入栈中；若该项是操作符<op>，则从栈中退出两个操作数Y和x,形成运算指令X<op>Y，\n并将计算结果压入栈中。当所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。\n例如，后缀表达式ABCD-*+EF/-求值的过程需要12步，见表3.2。\n表3.2后缀表达式ABCD-*+EF/-求值的过程\n步\n扫描项\n项类型\n栈中内容\n置空栈\n空\n2\nA\n操作数\n入栈\nA\n3\nB\n操作数\n入栈\nAB\nC\n操作数\n入栈\nABC\n5\nD\n操作数\n入栈\nABCD\n6\n一\n操作符\nD、C出栈，计算C-D，结果R入栈\nABR\n7\n*\n操作符\nR、B出栈，计算BxR，结果R入栈\nAR2\n8\n操作符\nR2、A出栈，计算A+R2，结果R入栈\nR3\n9\nE\n操作数\n入栈\nRE\n10\nF\n操作数\n入栈\nREF\n11\n操作符\nE、E出栈，计算E/F，结果R4入栈\nR3R4\n12\n操作符\nR4、R出栈，计算R-R4，结果Rs入栈\nR5",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0313",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "extension"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0331",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "related"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ],
        "summry": "**栈在表达式求值中的应用**\n- **定义**：利用栈的**后进先出（LIFO）**特性，实现中缀表达式转后缀表达式及后缀表达式求值的过程。\n- **核心概念**：\n- **中缀表达式**：运算符位于操作数中间（如`3+4`），需处理优先级和括号。\n- **后缀表达式**（逆波兰表示法）：运算符在操作数后（如`34+`），无括号，直接按顺序计算。\n- **转换规则**：\n1. **操作数**直接输出。\n2. **界限符**：`(`入栈，`)`触发栈内运算符弹出直至`(`。\n3. **运算符**：与栈顶比较优先级，高则入栈，低/等于则弹出栈顶直至条件满足。\n- **求值规则**：遇到操作数入栈；遇到运算符弹出栈顶两操作数计算，结果压栈。\n- **时间复杂度**：\n- 中缀转后缀：**O(n)**，每个元素入栈、出栈一次。\n- 后缀求值：**O(n)**，单次扫描即可完成。\n- **关键步骤示例**（中缀`A+B*(C-D)-E/F`→后缀`ABCD-*+EF/-`）：\n1. 操作数（`A,B,C,D,E,F`）直接输出。\n2. 运算符`*`优先级高于`+`，入栈；`)`触发栈内`-`弹出。\n3. `-`优先级≤栈顶`*`，弹出`*`和`+`后入栈。\n- **快速记忆**：\n- 中缀转后缀：**“操作数直接走，运算符比栈顶，括号配对弹到左”**。\n- 后缀求值：**“操作数压栈，运算符弹二算一”**。\n- **应用场景**：编译器语法分析、计算器实现、数学表达式解析。"
    },
    {
        "id": "kc0333",
        "title": "",
        "chapter_id": "03",
        "description": "栈在递归中的应用\n递归是一种重要的程序设计方法。简单地说，若在一个函数、过程或数据结构的定义中又应\n用了它自身，则这个函数、过程或数据结构称为是递归定义的，简称递归。\n递归通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解，递\n归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码\n量。但在通常情况下，它的效率并不是太高。\n以斐波那契数列为例，其定义为\n[F(n-1)+F(n-2),n>1\nF(n)={1,\nn=1\n[o,\nn=0\n这就是递归的一个典型例子，用程序实现时如下：\nint F(int n)(\n//斐波那契数列的实现\nif (n==0)\nreturn0;\n//边界条件\nelse if（n==1)\nreturn1;\n/边界条件\nelse\nreturn F(n-1)+F(n-2);\n//递归表达式\n必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：\n·递归表达式（递归体）。\n·边界条件（递归出口）。\n递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。\n命题追踪栈在函数调用中的作用和工作原理（2015、2017）\n在递归调用的过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来\n进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很\n\n第3章栈、队列和数组\n93\n多重复的计算。下面以n=5为例，列出递归调用执行过程，如图3.16所示。\nF(5)\nE(4)\nF(3)\nE(3）\nF(2)\nF(2）\nF(1）\nF(1)\nF(1)\nF(0)\nF(1)\nF（O)\nF（1)\nF（O)\n图3.16F（5）的递归执行过程\n显然，在递归调用的过程中，F(3)被计算2次，F(2)被计算3次。F(1)被调用5次，F(0)\n被调用3次。所以，递归的效率低下，但优点是代码简单，容易理解。在第5章的树中利用了递\n归的思想，代码变得十分简单。通常情况下，初学者很难理解递归的调用过程，若读者想具体了\n解递归是如何实现的，可以参阅编译原理教材中的相关内容。\n可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0313",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0331",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ],
        "summry": "**栈在递归中的应用**\n- **定义**：递归是通过函数调用自身解决问题的编程方法，依赖**系统栈**保存每层调用的返回地址、局部变量和参数。\n- **工作原理**：\n- **递归工作栈**：每次递归调用压入一帧（包含返回点、变量等），返回时弹出栈顶帧恢复上下文。\n- **栈溢出风险**：递归深度过大（如未收敛的递归）会导致栈空间耗尽。\n- **关键条件**：\n- **递归体**：问题分解规则（如斐波那契数列的`F(n)=F(n-1)+F(n-2)`）。\n- **递归出口**：终止条件（如`n=0`或`n=1`时直接返回结果）。\n- **效率问题**：\n- **重复计算**：如斐波那契递归中`F(3)`多次计算，时间复杂度**O(2^n)**。\n- **优化方法**：改用迭代或记忆化（缓存中间结果）。\n- **非递归转换**：\n- **显式栈模拟**：手动维护栈结构替代系统栈，按顺序压入待处理子问题（如DFS的非递归实现）。\n- **应用场景**：\n- 树/图的遍历（如二叉树先序递归≈隐式栈）。\n- 分治算法（如汉诺塔、快速排序）。\n- **记忆提示**：\n- **递归≈系统栈**，**栈溢出≈深度过大**，**优化≈迭代/记忆化**。\n- 斐波那契递归的调用树呈指数增长，可用`f(n-1)+f(n-2)`快速验证逻辑。\n> 注：递归代码简洁但效率低，实际开发中需权衡可读性与性能，栈结构是理解递归执行流程的核心。"
    },
    {
        "id": "kc0334",
        "title": "队列在层次遍历中的应用",
        "chapter_id": "03",
        "description": "在信息处理中有一大类问题需要逐层或逐行处理。这类问题的解决方法往往是在处理当前层\n或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，\n就可以处理下一层或下一行。使用队列是为了保存下一步的处理顺序。下面用二叉树（见图3.17）\n层次遍历的例子，说明队列的应用。表3.3显示了层次遍历二叉树的过程。\nB\nC\nD\n?\n?\nG\n图3.17\n二叉树\n表3.3层次遍历二叉树的过程\n序\n说\n明\n队内\n队\n外\n1\nA入\nA\n2\nA出，BC入\nBC\nA\n3\nB出，D入\nCD\nAB\n4\nC出，EF入\nDEF\nABC\n5\nD出，G入\nEFG\nABCD\n6\nE出，HI入\nFGHI\nABCDE\n7\nF出\nGHI\nABCDEF\n8\nGHI出\nABCDEFGHI\n该过程的简单描述如下：\n①根结点入队。\n②若队空（所有结点都已处理完毕），则结束遍历：否则重复③操作。\n\n94\n2026年数据结构考研复习指导\n③队列中第一个结点出队，并访问之。若其有左孩子，则将左孩子入队；若其有右孩子，则将右\n孩子入队，返回②。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0323",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0324",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0335",
                "relation_type": "related"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ],
        "summry": "**队列在层次遍历中的应用**\n- **定义**：利用队列的**先进先出（FIFO）**特性，按层级顺序处理树或图的节点，确保每一层的节点按从左到右的顺序访问。\n- **核心原理**：\n- **初始化**：根节点入队。\n- **迭代过程**：\n1. 队首节点出队并访问。\n2. 将其非空左子节点、右子节点依次入队。\n3. 重复上述步骤直到队列为空。\n- **时间复杂度**：**O(n)**（每个节点入队、出队各一次）。\n- **关键特性**：\n- **层级保持**：队列中同一时刻仅包含相邻两层的节点（当前层和下一层）。\n- **顺序控制**：左子节点优先入队，保证同层从左到右的访问顺序。\n- **应用场景**：\n- 二叉树层次遍历（如示例）。\n- 多叉树的广度优先搜索（BFS）。\n- 图的最短路径问题（未加权图）。\n- **实现要点**：\n- 使用循环或递归（需显式维护队列）。\n- 需处理空树/空节点的边界条件。\n- **记忆提示**：\n- **“队列≈层级接力”**：当前层节点出队时，下一层节点接力入队。\n- **“BFS模板”**：初始化队列→处理队首→子节点入队→循环至空。\n- **示例流程**（对应表3.3）：\n```plaintext\n1. A入队 → 队列[A]\n2. A出队，B、C入队 → 队列[B,C], 访问A\n3. B出队，D入队 → 队列[C,D], 访问B\n4. C出队，E、F入队 → 队列[D,E,F], 访问C\n...（直至队列为空）\n```"
    },
    {
        "id": "kc0335",
        "title": "队列在计算机系统中的应用",
        "chapter_id": "03",
        "description": "队列在计算机系统中的应用非常广泛，以下仅从两个方面来阐述：第一个方面是解决主机与\n外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。\n命题追踪缓冲区的逻辑结构（2009）\n对于第一个方面，仅以主机和打印机之间速度不匹配的问题为例做简要说明。主机输出数据\n给打印机打印，输出数据的速度比打印数据的速度要快得多，因为速度不匹配，若直接把输出的\n数据送给打印机打印，则显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印\n输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中\n按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓\n冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数\n据缓冲区中所存储的数据就是一个队列。\n命题追踪多队列出队/入队操作的应用（2016）\n对于第二个方面，CPU（中央处理器，它包括运算器和控制器）资源的竞争就是一个典型的\n例子。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自已的程序，它们分别\n序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用\n完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个\n用户的请求，又使CPU能够正常运行。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q033002",
            "q033004",
            "q033005",
            "q033006",
            "q033007",
            "q033008",
            "q033010",
            "q033012",
            "q033013",
            "q033014",
            "q033015"
        ],
        "summry": "**队列在计算机系统中的应用**\n- **定义**：队列是一种**先进先出（FIFO）**的线性数据结构，支持在队尾插入（`enqueue`）、队首删除（`dequeue`）。\n- **应用场景1：解决速度不匹配问题**\n- **原理**：通过缓冲区队列协调高速设备（如主机）与低速设备（如打印机）的数据传输。\n- 主机将数据**顺序写入**缓冲区队列，写满后暂停输出。\n- 打印机按**FIFO**原则从队列中取出数据打印，完成后通知主机继续写入。\n- **关键点**：\n- 避免数据丢失或阻塞，提升主机效率（**O(1)** 入队/出队）。\n- 典型场景：打印任务调度、磁盘I/O缓冲。\n- **应用场景2：解决资源竞争问题**\n- **原理**：使用队列管理多用户/进程对共享资源（如CPU）的请求。\n- 用户请求按到达顺序**入队**，CPU按**FIFO**分配队首任务。\n- 任务完成后**出队**，CPU分配给下一队首任务。\n- **关键点**：\n- 公平性：确保所有用户请求依次处理（避免饥饿）。\n- 典型场景：多任务调度、网络请求排队。\n- **记忆提示**：\n- 速度不匹配→缓冲队列（如“打印机排队打印”）。\n- 资源竞争→任务队列（如“CPU轮流服务用户”）。\n- **扩展**：\n- **优先级队列**：紧急任务可插队（如操作系统中断处理）。\n- **循环队列**：优化固定缓冲区空间利用率（如生产者-消费者模型）。"
    },
    {
        "id": "kc0391",
        "title": ",6.7。若期望驶出的次序依次为1~9，则n至少是（）。",
        "chapter_id": "03",
        "description": "m\n：\n入口\n出口\n轨道\nA.2\nB.3\nC.4\nD.5\n17.【2017统考真题】下列关于栈的叙述中，错误的是（）。\n1.采用非递归方式重写递归程序时必须使用栈\nI1.函数调用时，系统要用栈保存必要的信息\nIII.只要确定了入栈次序，即可确定出栈次序\nIV.栈是一种受限的线性表，允许在其两端进行操作\nA.仅I\nB.仅I、ⅡI、III\nC.仅I、III、IV\nD.仅II、III、IV\n18.【2018统考真题】若栈S1中保存整数，栈S2中保存运算符，函数F（）依次执行下述各\n步操作：\n1）从S1中依次弹出两个操作数a和b。\n2）从S2中弹出一个运算符op。\n3）执行相应的运算bop a。\n4）将运算结果压入S1中。\n假定S1中的操作数依次是5，8，3,2（2在栈顶），S2中的运算符依次是*、一、+（+在\n栈顶）。调用3次F（）后，S1栈顶保存的值是（）。\nA.-15\nB.15\nC. -20\nD. 20\n19.【2024统考真题】与表达式x+y*（=-u)/v等价的后缀表达式是（）。\nA.xy=u-*v/+\nB.xy=u-v/*+\nC.+x/*y-=uv\nD.+x*y/-=uv\n二、综合应用题\n01.假设一个算术表达式中包含圆括号、方括号和花括号3种类型的括号，编写一个算法来\n判别表达式中的括号是否配对，以字符“0”作为算术表达式的结束符。",
        "related_points": [],
        "questions": [],
        "summry": "**栈的应用与特性**\n- **定义**：受限线性表，仅允许在**栈顶**进行插入（`push`）和删除（`pop`），遵循**LIFO**（后进先出）原则。\n- **核心特性**：\n- **函数调用**：系统用栈保存返回地址、局部变量等（如题17-II）。\n- **递归转非递归**：通常需用栈模拟调用过程（但非绝对，如尾递归可优化，题17-I错误）。\n- **括号匹配**：左括号入栈，右括号与栈顶匹配（综合应用题01）。\n- **表达式求值**：中缀转后缀需运算符栈，求值需操作数栈（如题18、19）。\n**关键问题解析**\n1. **题6.7（轨道问题）**：\n- **场景**：模拟栈的入栈（驶入轨道）和出栈（驶出）序列。\n- **解法**：若出栈序列为1~9，至少需要**3**个轨道（选项B），通过交替入栈/出栈实现。\n2. **题17（栈的叙述）**：\n- **错误项**：\n- I：非递归不一定用栈（如迭代法）。\n- III：出栈次序受入栈和中间弹出操作影响（如ABC入栈可能有BAC出栈）。\n- IV：栈仅允许一端操作（双端操作是队列的特性）。\n- **答案**：C（I、III、IV错误）。\n3. **题18（栈求值）**：\n- **步骤**：\n1. 第一次F()：2（top）和3弹出，`+`运算→5压入S1（栈：5,8,5）。\n2. 第二次F()：5和8弹出，`-`运算→3压入（栈：5,3）。\n3. 第三次F()：3和5弹出，`*`运算→15压入（栈：15）。\n- **答案**：B（15）。\n4. **题19（后缀表达式）**：\n- **规则**：运算符紧跟操作数，括号去除。\n- **转换**：`x+y*(z-u)/v` → `xyzu-*v/+`（选项A）。\n**快速记忆**\n- **括号匹配**：左括号全入栈，遇右括号必匹配栈顶。\n- **表达式求值**：中缀→后缀时，运算符按优先级出栈；求值时，操作数栈存中间结果。\n- **栈操作**：`push`≈叠盘子，`pop`≈取最上层盘子。\n**代码提示（括号匹配）**\n```c\nbool isMatched(char* expr) {\nStack S; initStack(&S);\nfor (int i = 0; expr[i] != '0'; i++) {\nif (expr[i] == '(' || expr[i] == '[' || expr[i] == '{') push(&S, expr[i]);\nelse if (expr[i] == ')' && pop(&S) != '(') return false;\n// 同理处理 ] 和 }\n}\nreturn isEmpty(S);\n}\n```"
    },
    {
        "id": "kc0341",
        "title": "数组的定义",
        "chapter_id": "03",
        "description": "数组是由n（n≥1）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元\n素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。\n数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为\n其元素是定长数组的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除\n结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "extension"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0342",
                "relation_type": "extension"
            },
            {
                "id": "kc0343",
                "relation_type": "extension"
            },
            {
                "id": "kc0344",
                "relation_type": "extension"
            },
            {
                "id": "kc0413",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0751",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ],
        "summry": "**数组**\n- **定义**：由**n（n≥1）**个相同类型数据元素构成的有限序列，元素通过**下标**（序号）访问，下标范围由**维界**确定。\n- **与线性表关系**：\n- 一维数组 ≈ 线性表。\n- 多维数组 ≈ 元素为定长数组的线性表（如二维数组即“线性表的线性表”）。\n- **特性**：\n- **静态结构**：维数、维界定义后不可变（仅支持初始化、销毁、存取、修改操作）。\n- **随机访问**：通过下标直接定位元素，时间复杂度**O(1)**。\n- **关键点**：\n- 元素类型必须一致，内存连续分配（支持高效遍历）。\n- 多维数组按行/列优先顺序存储（影响缓存性能）。\n- **应用**：矩阵运算、哈希表桶实现、静态数据存储。\n- **记忆提示**：数组≈编号的储物柜，按下标开箱即取。"
    },
    {
        "id": "kc0342",
        "title": "数组的存储结构",
        "chapter_id": "03",
        "description": "大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可采用计算机语言中的数组数\n据类型进行存储，一个数组的所有元素在内存中占用一段连续的存储空间。\n\n第3章栈、队列和数组\n101\n以一维数组A[0.n-1]为例，其存储结构关系式为\nLOC(a,)= LOC(a)+ix L (O≤i<n)\n其中，L是每个数组元素所占的存储单元。\n命题追踪）二维数组按行优先存储的下标对应关系（2021）\n对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的\n基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组\n的行下标与列下标的范围分别为[0,h]与[0,h2]，则存储结构关系式为\nLOC(a,;)= LOC(ao)+[ix(h, +1)+ j]x L\n例如，对于数组A[2I[3]，它按行优先方式在内存中的存储形式如图3.18所示。\nlalloln Illol lollol\nIillolp\nIallolp\nA|21131=\n]\n第1行\n第2行\n图3.18\n二维数组按行优先顺序存放\n当以列优先方式存储时，得出存储结构关系式为\nLOC(a,)= LOC(ao.0) +[jx(h, +1)+i]xL\n例如，对于数组A[23，它按列优先方式在内存中的存储形式如图3.19 所示。\n[aa0121\nlollolp\nlillolp\nA|21131=\n第1列\n第2列\n第3列\n图3.19\n二维数组按列优先顺序存放",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0235",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0343",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0344",
                "relation_type": "extension"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ],
        "summry": "**数组的存储结构**\n- **定义**：数组在内存中占用**连续存储空间**，元素通过下标直接访问，逻辑结构映射为物理线性序列。\n- **一维数组寻址**：\n- 关系式：`LOC(a_i) = LOC(a_0) + i × L`（`L`为元素占用的存储单元，`0 ≤ i < n`）。\n- **特性**：随机访问时间复杂度为**O(1)**（通过首地址+偏移量直接计算）。\n- **多维数组映射方法**：\n- **按行优先**：先行后列，行下标优先递增。\n- 二维数组关系式：`LOC(a_{i,j}) = LOC(a_{0,0}) + [i×(h_2+1) + j]×L`（`h_1`、`h_2`为行列最大下标）。\n- **示例**：`A[2][3]`存储顺序为`a00, a01, a02, a10, a11, a12`（如图3.18）。\n- **按列优先**：先列后行，列下标优先递增。\n- 二维数组关系式：`LOC(a_{i,j}) = LOC(a_{0,0}) + [j×(h_1+1) + i]×L`。\n- **示例**：`A[2][3]`存储顺序为`a00, a10, a01, a11, a02, a12`（如图3.19）。\n- **关键对比**：\n- **行优先**：C/C++、Java等语言默认方式，缓存利用率高（局部性原理）。\n- **列优先**：Fortran等语言使用，适用于列操作频繁的场景。\n- **记忆提示**：\n- 一维数组：**首地址+下标×单元大小**。\n- 二维数组：行优先→**“行号×总列数+列号”**；列优先→**“列号×总行数+行号”**。\n- **应用场景**：矩阵运算、图像处理（需注意存储顺序对性能的影响）。"
    },
    {
        "id": "kc0343",
        "title": "特殊矩阵的压缩存储",
        "chapter_id": "03",
        "description": "压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配空间。\n特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一\n定规律性的矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。\n特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律\n性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。\n1．对称矩阵\n命题追踪对称矩阵压缩存储的下标对应关系（2018、2020）\n若对一个n阶矩阵 A中的任意一个元素ai,y都有aj=aj（1≤i,j≤n），则称其为对称矩阵。\n其中的元素可以划分为3个部分，即上三角区、主对角线和下三角区，如图3.20所示。\na2.\nC2.1\n<j上三角区\nCn.\nan.2\ni>j下三角区\ni=j主对角线\n图3.20n阶矩阵的划分\n\n102\n2026年数据结构考研复习指导\n对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存\n放，则会浪费几乎一半的空间，为此将n阶对称矩阵A存放在一维数组B[n（n+1）/2］中，即元\n素ai存放在b中。比如只存放下三角部分（含主对角线）的元素。\n在数组B中，位于元素aj（i≥j）前面的元素个数为\n第1行：1个元素（a1.1）。\n第2行：2个元素（a2.1,a2.2）。\n第i-1行：i-1个元素（a-1.1,a-1.2,*…,a-1,i-1）。\n第i行：j-1个元素（a.1,a,2.…,aij-1）。\n因此，元素aiy在数组B中的下标k=1+2+…+(i-1)+j-1=i(i-1)/2+j-1（数组下标从0\n开始）。因此，元素下标之间的对应关系如下：\ni(i-1)\n+j-1,\ni≥j（下三角区和主对角线元素)\n2\nj(j-1)\n+i-1,\ni<j（上三角区元素a,=a）\n2\n当数组下标从1开始时，可以采用同样的推导方法，请读者自行思考。\n注意\n二维数组A[n][n]和A[0...n-1][0...n-1]的写法是等价的。若数组写成A[1..n][1..n]，则表示\n指定了下标是从1开始的。二维数组元素写为a[i][j]，注意数组元素下标i和j通常是从0开始的\n矩阵元素通常写为a主，j，行号i和列号j通常是从1开始的。\n2.三角矩阵\n下三角矩阵[见图3.22（a)]中，上三角区的所有元素均为同一常量。其存储思想与对称矩阵\n类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一\n次，所以可以将n阶下三角矩阵A压缩存储在B[n（n+1）/2+1]中。\n元素下标之间的对应关系为\ni(i-1)\n+i-1.\ni≥j(下三角区和主对角线元素)\n2\nK=\nn(n+1)\ni<j（上三角区元素）\n2\n下三角矩阵在内存中的压缩存储形式如图3.21所示。\na2,1\na2.2\n3.2\n3.3\nan,1\n第1行第2行\n第3行\n第n行\n常数项\n图3.21\n下三角矩阵的压缩存储\n命题追踪上三角矩阵采用行优先存储的应用（2011）\n上三角矩阵［见图3.22（b)】中，下三角区的所有元素均为同一常量。只需存储主对角线、上三\n角区上的元素和下三角区的常量一次，可将其压缩存储在B[n（n+1）/2+1]中。\n\n第3章栈、队列和数组\n103\na1\na1,1a12\n2.1\nd2.2\nd2.2\na2.n\nan.1dn2\nann\nann\n(a）下三角矩阵\n(b)上三角矩阵\n图3.22\n2三角矩阵\n在数组B中，位于元素aij（i≤j）前面的元素个数为\n第1行：n个元素\n第2行：n-1个元素\n第i-1行：n-i+2个元素\n第i行：j-i个元素\n因此，元素ay在数组B中的下标\nk=n+(n-1)+…+(n-i+2)+(j-i+1)-1=(i-1)(2n-i +2)/2+(j-i)\n因此，元素下标之间的对应关系如下：\n(i-1)(2n-i+2)\n+(i-i),\ni≤j（上三角区和主对角线元素）\n2\nK\nn(n+1)\ni>j(下三角区元素)\n2\n上三角矩阵在内存中的压缩存储形式如图3.23所示。\n0\nn(n+1)/2\na1.aa1aa2.2a2.3a2.\n….anc\n第1行\n第2行\n第n行常数项\n图3.23上三角矩阵的压缩存储\n以上推导均假设数组的下标从0开始，若题设有具体要求，则应该灵活应对。\n3.三对角矩阵\n公众号：小兔网盘免费分享无水印PDF\n对角矩阵也称带状矩阵。对n阶矩阵A中的任意一个元素aij，当li-川>1时，若有aij=0\n（1≤i,j≤n），则称为三对角矩阵，如图3.24所示。在三对角矩阵中，所有非零元素都集中在以主\n对角线为中心的3条对角线的区域，其他区域的元素都为零。\naa1.2\na2.1\na22a2.3\nd32\na3.3\n3.4\nan-1n-2an-1n-1an-1n\nann-1\nan.n]\n图3.24三对角矩阵A\n三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B\n中，且a11存放于B[0]中，其存储形式如图3.25所示。\naaa2\na2.2\na2.3\n...\nan-1.nann-1\nann\n图3.25三对角矩阵的压缩存储\n口\n公众号：小兔网盘\n免费网课+无水印PDF\n\n104\n2026年数据结构考研复习指导\n命题追踪三对角矩阵压缩存储的下标对应关系（2016）\n由此可以计算矩阵A中3条对角线上的元素a，（1≤i,j≤n,li-≤1）在一维数组B中存放\n的下标为k=2i+j-3。\n反之，若已知三对角矩阵中的某个元素a，存放在一维数组B的第k个位置，则有i=L（k+1)/3+1]，\nj=k-2i+3。例如，当k=0时，i=L(0+1)/3+1」=1，j=0-2x1+3=1，存放的是ai1；当k=\n2时，i=L（2+1）3+1]=2，j=2-2×2+3=1，存放的是a2.1；当k=4时，i=L（4+1)/3+1]=2，\nj=4-2×2+3=3，存放的是α2.3",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "extension"
            },
            {
                "id": "kc0344",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ],
        "summry": "**特殊矩阵的压缩存储**\n- **定义**：\n- **压缩存储**：对规律性分布的元素（如相同值或零元素）仅分配单一存储空间，节省内存。\n- **特殊矩阵**：元素分布具有规律性（如对称、三角、对角矩阵），含大量重复或零元素。\n- **核心方法**：\n根据元素分布规律，将规律性重复的元素映射到一维数组的特定位置。\n---\n### **1. 对称矩阵**\n- **特性**：\n- 满足 \\(a_{i,j} = a_{j,i}\\)（\\(1 \\leq i,j \\leq n\\)），仅需存储**下三角区+主对角线**。\n- 压缩后数组大小：\\(B[n(n+1)/2]\\)。\n- **下标映射**（从0开始）：\n- **下三角区**（\\(i \\geq j\\)）：\\(k = \\frac{i(i-1)}{2} + j - 1\\)\n- **上三角区**（\\(i < j\\)）：利用对称性 \\(a_{i,j} = a_{j,i}\\)，复用下三角公式。\n- **记忆提示**：\n- 前\\(i-1\\)行元素总数 = 等差数列求和 \\(\\frac{i(i-1)}{2}\\)。\n---\n### **2. 三角矩阵**\n#### **下三角矩阵**\n- **特性**：上三角区为常量，仅存储下三角区+常量。\n- **压缩数组**：\\(B[n(n+1)/2 + 1]\\)（末尾存常量）。\n- **下标映射**（从0开始）：\n- **下三角区**（\\(i \\geq j\\)）：\\(k = \\frac{i(i-1)}{2} + j - 1\\)\n- **上三角区**（\\(i < j\\)）：\\(k = \\frac{n(n+1)}{2}\\)（常量位置）。\n#### **上三角矩阵**\n- **特性**：下三角区为常量，仅存储上三角区+常量。\n- **下标映射**（从0开始）：\n- **上三角区**（\\(i \\leq j\\)）：\\(k = \\frac{(i-1)(2n-i+2)}{2} + (j-i)\\)\n- **下三角区**（\\(i > j\\)）：\\(k = \\frac{n(n+1)}{2}\\)（常量位置）。\n---\n### **3. 三对角矩阵**\n- **特性**：非零元素集中在主对角线及其相邻两条对角线（\\(|i-j| \\leq 1\\)）。\n- **压缩数组**：\\(B[3n-2]\\)（每行至多3元素）。\n- **下标映射**（从0开始）：\n- **元素→下标**：\\(k = 2i + j - 3\\)\n- **下标→元素**：\\(i = \\lfloor (k+1)/3 \\rfloor + 1\\)，\\(j = k - 2i + 3\\)。\n---\n### **关键注意**\n- **数组下标**：公式默认从0开始，若题目指定从1开始需调整（如对称矩阵\\(k = \\frac{i(i-1)}{2} + j\\)）。\n- **节省空间**：对称矩阵节省~50%，三角矩阵节省~50%+1常量位。\n**应用场景**：数值计算（如有限元分析）、稀疏矩阵处理。"
    },
    {
        "id": "kc0344",
        "title": "稀疏矩阵",
        "chapter_id": "03",
        "description": "矩阵中非零元素的个数1，相对矩阵元素的个数s来说非常少，即s》1的矩阵称为稀疏矩阵。\n例如，一个矩阵的阶为100×100，该矩阵中只有少于100个非零元素。\n命题追踪存储稀疏矩阵需要保存的信息（2023）\n若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零\n元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将\n非零元素及其相应的行和列构成一个三元组（行标i，列标j，值au），如图3.26所示。然后按照\n某种规律存储这些三元组线性表。稀疏矩阵压缩存储后便失去了随机存取特性。\nj\naij\n4000\n0\n0\n4\n0060\n对应的三元组\nM=\n1\n6\n0900\n2\n9\n[0 23 0 0]\n3\n1\n23\n图3.26稀疏矩阵及其对应的三元组\n命题追踪适合稀疏矩阵压缩存储的存储结构（2017）\n稀疏矩阵的三元组表既可以采用数组存储，又可以采用十字链表存储（见6.2节）。当存储稀\n疏矩阵时，不仅要保存三元组表，而且要保存稀疏矩阵的行数、列数和非零元素的个数。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0343",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q034001",
            "q034002",
            "q034003",
            "q034004",
            "q034005",
            "q034006",
            "q034007",
            "q034008",
            "q034009",
            "q034011",
            "q034012",
            "q034013",
            "q034014",
            "q034015",
            "q034016"
        ],
        "summry": "**稀疏矩阵**\n- **定义**：矩阵中非零元素数量远少于总元素数量（`s ≫ 1`），例如100×100矩阵中非零元素少于100个。\n- **存储需求**：\n- 常规存储浪费空间，仅需保存非零元素的**行标**、**列标**和**值**，构成三元组（`(i, j, aij)`）。\n- 附加存储矩阵的**行数**、**列数**和**非零元素个数**。\n- **压缩存储方法**：\n- **三元组数组**：按行/列顺序存储三元组，失去随机存取特性。\n- **十字链表**（见6.2节）：动态结构适合频繁插入/删除操作。\n- **特性**：\n- 压缩后无法直接通过行列下标访问，需遍历三元组表。\n- 典型应用：科学计算（如有限元分析）、图像处理中的稀疏数据。\n- **记忆提示**：\n- 三元组 = （行, 列, 值） + 矩阵元信息（行数, 列数, 非零数）。\n- 数组存储适合静态操作，十字链表适合动态修改。"
    },
    {
        "id": "kc0411",
        "title": "串的定义",
        "chapter_id": "04",
        "description": "串（string）是由零个或多个字符组成的有限序列。一般记为\nS='aa..·a(n≥0)\n其中，S是串名，单引号括起来的字符序列是中的值；a可以是字母、数字或其他字符：串中字\n符的个数n称为串的长度。n=0时的串称为空串（用表示）。\n串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。某个字\n①本节不在统考大纲范围，仅供学习参考。\n\n110\n2026年数据结构考研复习指导\n符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第1个字符在主串中\n的位置来表示。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。\n例如，有串A='China Beijing'，B='Beijing'，C='China'，则它们的长度分别为\n13、7和5。B和C是A的子串，B在A中的位置是7，C在A中的位置是1。\n长度为串中空格字符的个数。\n串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，\n串和线性表有很大差别。线性表的基本操作主要以单个元素作为操作对象，如查找、插入或删除\n某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等。",
        "related_points": [
            {
                "id": "kc0412",
                "relation_type": "extension"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**串（String）**\n- **定义**：由零个或多个字符组成的有限序列，记作 `S='a₁a₂...aₙ'`（`n≥0`），`n=0` 时称为**空串**（用 `∅` 表示）。\n- **关键概念**：\n- **长度**：字符个数 `n`（空格也计入）。\n- **子串**：主串中任意连续的字符子序列（如 `'Beijing'` 是 `'China Beijing'` 的子串）。\n- **位置**：字符/子串的序号（从1开始计数，子串位置以其首字符位置表示）。\n- **相等条件**：长度相同且对应字符完全一致。\n- **与线性表的区别**：\n- **数据对象**：串限定为字符集，线性表可为任意类型。\n- **操作单位**：串以子串为操作对象（如替换子串），线性表以单个元素为主（如插入结点）。\n- **应用场景**：文本处理、模式匹配（如KMP算法）、数据压缩等。\n- **记忆提示**：\n- 空串 `∅` ≠ 含空格串 `' '`（后者长度为1）。\n- 子串定位类似“查单词在文章中的起始页码”。"
    },
    {
        "id": "kc0412",
        "title": "串的基本操作",
        "chapter_id": "04",
        "description": "·StrAssign（&T，chars）：赋值操作。把中T赋值为chars。\n·StrCopy（&T，S）：复制操作。由串s复制得到串T。\n·StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。\n·StrCompare(S,T)：比较操作。若 S>T，则返回值>O；若S=T，则返回值=O；若 S<T，\n则返回值<0。\n·StrLength（S）：求串长。返回串s的元素个数。\n·SubString（&Sub,S,pos，len)：求子串。用 Sub 返回串 s 的第 pos 个字符起长度为\nlen的子串。\n·Concat（&T,S1,S2）：串联接。用T返回由 S1和 S2联接而成的新串。\n·Index（S，T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中\n第一次出现的位置：否则函数值为0。\n·ClearString（&S）：清空操作。将s清为空串。\n·DestroyString(&S）：销毁串。将串 s销毁。\n不同的高级语言对串的基本操作集可以有不同的定义方法。在上述定义的操作中，串赋值\nStrAssign、串比较StrCompare、求串长StrLength、串联接Concat及求子串 SubString\n五种操作构成串类型的最小操作子集，即这些操作不可能利用其他串操作来实现；反之，其他串\n操作（除中清除ClearString和串销毁DestroyString外）均可在该最小操作子集上实现。",
        "related_points": [
            {
                "id": "kc0411",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "extension"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**串的基本操作**\n- **定义**：串（字符串）的线性存储结构及其核心操作集合，支持文本处理的基础功能。\n- **核心操作**：\n- **赋值**（`StrAssign(&T, chars)`）：将字符序列`chars`赋值给串`T`。\n- **复制**（`StrCopy(&T, S)`）：将串`S`复制到`T`。\n- **判空**（`StrEmpty(S)`）：返回`TRUE`当`S`为空串，否则`FALSE`。\n- **比较**（`StrCompare(S, T)`）：按字典序比较，返回`>0`（`S>T`）、`=0`（`S=T`）、`<0`（`S<T`）。\n- **求长度**（`StrLength(S)`）：返回串`S`的字符数。\n- **求子串**（`SubString(&Sub, S, pos, len)`）：提取`S`从`pos`起始、长度为`len`的子串到`Sub`。\n- **连接**（`Concat(&T, S1, S2)`）：将`S1`和`S2`拼接为新串`T`。\n- **定位**（`Index(S, T)`）：返回`T`在`S`中首次出现的位置（无则返回`0`）。\n- **清空/销毁**（`ClearString(&S)`/`DestroyString(&S)`）：清空内容或释放内存。\n- **最小操作子集**：\n- 包含`StrAssign`、`StrCompare`、`StrLength`、`Concat`、`SubString`，其他操作（除清空/销毁外）均可基于它们实现。\n- **应用场景**：文本编辑、模式匹配（如`Index`实现子串搜索）、数据解析等。\n- **记忆提示**：\n- **比较≈字典序**，**连接≈字符串加法**，**子串≈切片操作**。\n- 最小子集类似“基本运算”，其他操作可通过组合完成。"
    },
    {
        "id": "kc0413",
        "title": "串的存储结构",
        "chapter_id": "04",
        "description": "1.定长顺序存储表示\n类似于线性表的顺序存储结构，用一组地址连续的存储单元来存储串值的字符序列。在中的\n定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。\n#define MAXLEN 255\n//预定义最大串长为255\ntypedef struct{\nchar ch[MAXLEN];\n/每个分量存储一个字符\nint length;\n/串的实际长度\n)sString;\n串的实际长度只能小于或等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。串长\n有两种表示方法：一是如上述定义描述的那样，用一个额外的变量1en来存放串的长度；二是在\n串值后面加一个不计入串长的结束标记字符“\\0”，此时的串长为隐含值。\n在一些串的操作（如插入、联接等）中，若串值序列的长度超过上界MAXLEN，约定用“截\n\n第4章串\n111\n断”法处理，要克服这种端，只能不限定串长的最大长度，即采用动态分配的方式。\n2.堆分配存储表示\n堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是\n在程序执行过程中动态分配得到的。\ntypedef struct{\nchar *ch;\n/按串长分配存储区，ch指向串的基地址\nint length;\n//串的长度\n)HString;\n在C语言中，存在一个称为堆的自由存储区，并用malloc（）和free（）函数来完成动态存\n储管理。利用malloc（）为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则\n返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来指示；若分配失败，则返\n回NULL。已分配的空间可用free（）释放掉。\n上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。\n3.块链存储表示\n类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只\n有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点\n称为块，整个链表称为块链结构。图4.1(a)是结点大小为4（每个结点存放4个字符）的链表，最\n后一个结点占不满时通常用“#”补上：图4.1(b)是结点大小为1的链表。\nnead\nABCDEFGH>I###A\n（a）结点大小为4的链表\nB→\n（b）结点大小为1的链表\n图4.1串值的链式存储方式\n4.2串的模式匹配",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "extension"
            },
            {
                "id": "kc0411",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0412",
                "relation_type": "extension"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**串的存储结构**\n1. **定长顺序存储表示**\n- **定义**：使用连续存储单元（定长数组）存储字符序列，长度固定。\n- **实现**：\n```c\n#define MAXLEN 255\ntypedef struct {\nchar ch[MAXLEN];  // 存储字符\nint length;       // 实际长度\n} SString;\n```\n- **特点**：\n- 串长≤`MAXLEN`，超长部分截断。\n- 长度表示：显式（`length`变量）或隐式（以`\\0`结尾）。\n- **缺点**：操作（如插入、联接）可能因长度限制需截断，灵活性差。\n2. **堆分配存储表示**\n- **定义**：动态分配连续存储空间，按需调整。\n- **实现**：\n```c\ntypedef struct {\nchar *ch;    // 动态分配基地址\nint length;  // 串长\n} HString;\n```\n- **特点**：\n- 使用`malloc()`/`free()`管理内存，避免截断问题。\n- 空间利用率高，但需手动释放内存。\n3. **块链存储表示**\n- **定义**：链式存储，每个结点（块）含多个字符。\n- **特点**：\n- 结点大小可自定义（如1字符或4字符）。\n- 未满块用填充符（如`#`）补全。\n- **优缺点**：\n- 灵活支持动态操作，但存储密度低（指针开销）。\n**快速对比**\n- **定长顺序**：简单但固定大小，适合已知最大长度的场景。\n- **堆分配**：动态灵活，需手动管理内存。\n- **块链**：适用于频繁插入/删除，但空间效率低。\n**附：模式匹配提示**\n- 定长/堆分配适合**KMP算法**（连续存储）；块链需遍历结点，效率较低。"
    },
    {
        "id": "kc0421",
        "title": "简单的模式匹配算法",
        "chapter_id": "04",
        "description": "模式匹配是指在主串中找到与模式串（想要搜索的某个字符串）相同的子串，并返回其所在\n的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。\nint Index(SString S,SString T){\nint i=1,j=1;\nwhile(i<=s.length&&j<=T.length)(\nif(S.ch[i]==T.ch[j]){\n++i;++j;\n1//继续比较后继字符\nelser\ni=i-j+2;j=1;\n//指针后退重新开始匹配\n）\nif(j>T.length)return i-T.length;\nelse return 0;\n在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前待比较的字符位置。\n\n112\n2026年数据结构考研复习指导\n算法思想是：从主串S的第一个字符起，与模式串T的第一个字符比较，若相等，则继续逐个比\n较后续字符；否则从主串的下一个字符起，再重新和模式串T的字符比较；以此类推，直至模式\n串T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为与模式\n串T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，函数值为零。\n图4.2展示了模式串T='abcac'和主串s的匹配过程。\n1=3\n第一趟匹配\nab\nap\nab\n↑j=3\ni=2\n第二趟匹配\nab\ni=7\n第三趟匹配\nabc\ni=4\n第四趟匹配ab\ni=5\n第五趟匹配aba\n=\n图4.2简单模式匹配算法举例\n在简单模式匹配算法中，设主串和模式串的长度分别为n和m（n》m），则最多需要进行n-m+1\n趟匹配，每趟最多需要进行m次比较，最坏时间复杂度为O（nm）。例如，当模式串为+0000001+而\n主中为：0000000000000000000000000000000000000000000001·时，由于模式串中的前6\n个字符均为＇0＇，主串中的前45个字符均为+0＇，每趟匹配都是比较到模式串中的最后一个字符时才\n发现不等，整个匹配过程中指针i需要回溯39次，总比较次数为40x7=280次。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0411",
                "relation_type": "extension"
            },
            {
                "id": "kc0412",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "extension"
            },
            {
                "id": "kc0422",
                "relation_type": "extension"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ],
        "summry": "**简单的模式匹配算法（暴力匹配/Brute-Force）**\n- **定义**：在主串 `S` 中逐字符检查与模式串 `T` 完全匹配的子串，返回首次匹配的起始位置（失败返回0）。\n- **核心逻辑**：\n- 初始化指针 `i`（主串）、`j`（模式串）为1。\n- **匹配成功**：`S[i] == T[j]` 时，同步后移 `i++`, `j++`。\n- **匹配失败**：`i` 回溯至 `i-j+2`（下一趟起始点），`j` 重置为1。\n- **终止条件**：`j > T.length`（成功）或 `i > S.length`（失败）。\n- **时间复杂度**：\n- **最坏**：**O(n×m)**（如主串全0，模式串为000...1）。\n- **平均**：**O(n+m)**（实际场景中通常优于最坏情况）。\n- **特点**：\n- **优点**：实现简单，无需预处理。\n- **缺点**：效率低（主串指针 `i` 频繁回溯）。\n- **示例**：\n```c\n// 匹配失败时指针回溯逻辑\ni = i - j + 2;  // 主串回溯到下一趟起始位置\nj = 1;          // 模式串重置\n```\n- **记忆提示**：\n- \"逐字符比对，失败即回溯\"\n- 适用场景：短模式串或对效率要求不高的场景。\n- **优化方向**：KMP算法通过避免指针回溯将时间复杂度优化至 **O(n+m)**。"
    },
    {
        "id": "kc0422",
        "title": "串的模式匹配算法一一KMP算法",
        "chapter_id": "04",
        "description": "在图4.2的第三趟匹配过程中，i=7、j=5 的字符比较，结果不等，于是又从i=4、j=1重新\n开始比较。然而，仔细观察会发现，i=4和j=1、i=5和j=1以及i=6和j=1这三次比较都是不\n必进行的。从第三趟部分匹配的结果可知，主串的第4个、第5介、第6个字符是'b'、'c'、'a\"\n（模式串的第2、第3、第4个字符），因为模式串的第1个字符是+a＇，所以再和这三个字符进行比\n较纯属多余，而只需将模式串向右滑动三个字符的位置，再进行i=7、j=2的比较即可。\n在简单模式匹配算法中，每趟匹配失败都是模式串向右滑动一位后从头开始比较的。而某趟\n已匹配相等的字符序列是模式串的某个前缀，因此可从分析模式串本身的结构着手，若已匹配相\n等的前缀序列中有某个后缀正好是模式串的前缀，则可将模式中向右滑动到与这些相等字符对齐\n\n第4章串\n113\n的位置（也是后面手算next数组的依据），主串指针i无须回溯，并从该位置开始继续比较。\n而模式串向右滑动位数的计算仅与模式串本身的结构有关，与主串无关。\n1.KMP算法的原理\n要了解模式串的结构，首先要弄清楚几个概念：前缀、后缀和部分匹配值。前缀是指除最后\n个字符外，字符串的所有头部子串；后缀是指除第一个字符外，字符串的所有尾部子中：部分\n匹配值则是指字符串的前缀和后缀的最长相等前后缀长度。下面以+ababa+为例进行说明：\n·+a+的前缀和后缀都为空集，最长相等前后缀长度为0。\n·'ab'的前缀为{a}，后缀为{b}，{a}n{b}=，最长相等前后缀长度为0。\n'aba'的前缀为{a，ab}，后缀为{a,ba}，{a，ab}n{a，ba}={a}，最长相等前后缀长\n度为1。\n'abab'的前缀{a,ab，aba}n后缀{b，ab，bab}={ab}，最长相等前后缀长度为2。\n'ababa'的前缀{a，ab，aba，abab}n后缀{a，ba，aba，baba}={a,aba)，公共元素有\n两个，最长相等前后缀长度为3。\n因此，模式串'ababa'的部分匹配值为00123。\n这个部分匹配值有什么作用呢？\n回到最初的问题，主串为'ababcabcacbab'，模式串为'abcac'。\n式，就得到了部分匹配值（PartialMatch，PM）的表。\n编号\nS\nPM\n下面用PM表来进行字符串匹配：\n主串\na\nb\na\n模式串\nb\n第一趟匹配过程：\n发现c与a不匹配，前面的2个字符+ab+是匹配的，查表可知，最后一个匹配字符b对应\n的部分匹配值为0，因此按照下面的公式算出模式串需要的右滑位数：\n右滑位数=已匹配的字符数－对应的部分匹配值\n因为2-0=2，所以将模式串向右滑动2位如下，进行第二趟匹配：\n主串\n模式串\n第二趟匹配过程：\n发现c与b不匹配，前面的4个字符！abca'是匹配的，查表可知，最后一个匹配字符a对\n应的部分匹配值为1，4-1=3，将模式串向右滑动3位如下，进行第三趟匹配：\n主串\n模式串\n第三趟匹配过程：\n模式串全部比较完成，匹配成功。整个匹配过程中，主串始终没有回退，所以KMP算法可\n在O(n+m)的时间数量级上完成串的模式匹配操作，大大提高了匹配效率。\n\n114\n2026年数据结构考研复习指导\n某趟发生失配时，若已匹配相等的序列中没有相等的前后缀，则对应的部分匹配值为0，此\n时滑动的位数最大，直接将模式串首字符向右滑动到主串当前位置进行下一趟比较；若已匹配相\n等的序列中存在最大相等前后缀（可理解为首尾重合），则将模式串向右滑动到和主中中该相等\n后缀对齐（这些重合的字符下一趟显然无需再比较），然后从主串当前位置进行下一趟比较。两\n还有一种特例，在上述举例中并未出现，当某趟第一个字符比较就失配时，应如何处理呢？\n此时，应让模式串向右滑动一位，再从主串当前位置的下一位开始比较。\n2.next数组的手算方法\n在实际的匹配过程中，模式串在内存中是不会滑动的，发生变化的是指针，前面的举例只\n是手动模拟KMP算法的过程，也是为了让读者更为形象地进行理解。\n命题追踪KMP算法中指针变化、比较次数的分析（2015、2019）\n每趟匹配失败时，只有模式串指针i在变化，主串指针j不会回溯，为此可以定义一个next\n数组，next[j］的含义是当模式中的第j个字符失配时，跳到next[j]位置继续比较。\n下面给出一种求next数组的手算方法，仍以模式中'abcac'为例。\n位置与主串当前位置的下一位置进行比较（注意，图中的下标为模式中编号）。\n匹配失败，说明此元素不是a\n主串\n回\n回\n模式串\na1\nb2\nC3\na4\nC5\n第2个字符失配时，令next[2]=1，模式串的下次比较位置为1，相当于向右滑动1位。\n注，模式串的next[1]=0、next[2]=1都是固定不变的。\n匹配失败，说明此元素不是b\n主串\n回\n回\n?\n?\na\n模式串\na1\nb2\nC3\na4\nC5\n右滑\na1\nb2\nC3\na4\nC5\n在后面的手算过程中，在不匹配的位置前画一条分界线，模式串一步一步往后退，直到分\n界线之前能对上（首尾重合），或模式串完全跨过分界线为止。\n第3个字符失配时，模式串的下次比较位置为1，即next[3]=1，相当于向右滑动2位。\n匹配失败，说明此元素不是c\n主串\nb\n回\n模式串\nai\nb2\nC3\na4\nC5\n右滑\na1\nb2\nC3\na4\nC5\n第4个字符失配时，模式串的下次比较位置为1，即next[4]=1，相当于向右滑动3位。\n匹配失败，说明此元素不是a\n主串\n回\nb\n模式串\nb2\nC3\na4\nC5\n右滑\na1\nC3\na4\n\n第4章串\n115\n第5个字符失配时，模式串的下次比较位置为2，即next[5]=2，相当于向右滑动3位。\n匹配失败，说明此元素不是c\n主串\nh\n模式串\na1\nb2\nC3\na\nC5\n右滑\na\nb2\nnext数组和PM表的关系是怎样的?\n通过上述举例，可以推理出next数组和PM表之间的关系：\nnext[j］=j-右滑位数=j-(已匹配的字符数-对应的部分匹配值)\n=j-[(j-1）-PM[j-1]]\n=PM[j-1]+1\n根据上述结论，将模式串，abcac+的PM表右移一位，并整体加1，就得到了模式串+abcac\n对应的next数组，通过与前面手算的结果比较，可以验证上述结论。\n编号\n1\n2\n3\n4\nS\na\nb\nC\na\nnext\n0\n1\n1\n2\n我们注意到：\n1）第一个元素右滑以后空缺的用0来填充，因为若是第一个元素匹配失败，则需要将主串\n指针和模式串指针同步右移一位，从而不需要计算模式串指针移动的位数。\n2）最后一个元素在右滑的过程中溢出，因为原来的模式串中，最后一个元素的部分匹配值\n是其下一个元素使用的，但显然已没有下一个元素，所以可以舍去。\n注\n意\n上述KMP算法的举例中，都假设串的编号是从1开始的；若串的编号是从0开始的，则next数\n组需要整体减1。\n*3.next数组的推理公式\n第1个字符与模式串的第个字符失配时，应让主串当前位置与模式串的哪个字符进行比较？\n假设此时应与模式串的第k（k<j）个字符进行比较，则模式串的前k-1个字符的子串必须\n满足下列条件，且不可能存在k'>k满足下列条件：\n'p1p2.pk-1'='pj-k+1Pj-k+2..·pj-1'\n若存在满足如上条件的子串，则发生失配时，仅需将模式串的第k个字符和主串的第i个字\n符对齐，此时模式串的前k-1个字符的子串必定与主串的第i个字符之前长度为k-1的子串相\n等，因此，只需从模式串的第k个字符与主串的第i个字符进行比较即可，如图4.3所示。\n主串\nS1\nSi-k+1\nSi-1\n#\nS\n子串\nP1\npk-1\nPj-k+1\nPj-1\nPm\n右滑\nP1\n...\nPk-1pk\nPm\n图4.3模式串右滑到合适位置（阴影对齐部分表示上下字符相等）\n①注意，当模式串匹配到位置j失配时，已匹配成功的字符数为j-1。\n\n116\n2026年数据结构考研复习指导\n当模式串已匹配相等序列中不存在满足上述条件的子串时（可视为k=1），显然应让主串的\n第i个字符和模式串的第1个字符进行比较。\n当模式串的第1个字符（j=1）与主串的第i个字符发生失配时，规定next[1]=0。\n通过上述分析可以得出next函数的公式：\n0，\nj=1\nnext[j]=\nmax{k|1<k<j且'p*Px-=P-x+\"P-+），当此集合不为空时\n[1,\n其他情况\n要用代码来实现，难度貌似还不小，下面来尝试推理求解的科学步骤。\n首先由公式可知\nnext[1]=0\n设next[j]=k，此时k应满足的条件在上文中已描述。\n此时next[j+1]=？可能有两种情况：\n（1）若pk=P，则表明在模式串中\np1...pk-ipk'=pj-k+1·.pj-iPj\n且不可能存在k'>k满足上述条件，此时 next[j+1]=k+1，即\nnext[j+l]=next[j]+1\n（2）若pk≠P，则表明在模式串中\ndt-d...+x-d.d-d...d\n匹配，当 pk≠pg 时，应将 pi\".pk 向右滑动至用第 next [k]个字符与 p;进行比较，若 Pnext[k]\n与 pg 仍不匹配，则需要寻找长度更短的相等前后缀，下一步继续用 Pnext[next[kj)与 p 进行较，\n以此类推，直到找到某个更小的k'=next[next…·[k]]（1<k'<k<j)，满足条件\n'p1..pk='pj-k+1..·pj'\n则next[j+1]=k'+1。\n也可能不存在任何k'满足上述条件，即不存在长度更短的相等前后缀，令next[j+1]=1\n理解起来有点儿费劲？下面举一个简单的例子。\n图4.4 的模式串中已求得6个字符的 next 值,现求 next[7],因为 next[6]=3,又 po≠p3,\n所以需要比较p6和p（因next[3]=1），p6≠p1，而next[1]=0，因此next[7]=1;求next[8]，\n因为p=P1，所以next[8]=next[7]+1=2；求next[9]，因为p=p2，所以next[9]=3。\n1\n2\n34\n5\n模式串\nal\nb\nnext[j]\n0112232\n图4.4求模式串的next值\n*4.KMP算法的实现\n通过上述分析写出求next值的程序如下：\nvoid get_next(sString T,int next[]){\ninti=1,j=0;\nnext[1]=0;\nwhile(i<T.length){\nif（j==011T.ch[i]==T.ch[j]){\n++i;++j；\nnext[i]=j;//若p=pj，则 next[j+1]=next[j]+1\n\n第4章串\n117\nelse\nj=next[j]；//否则令j=next[j]，循环继续\n计算机执行起来效率很高，但需要手工计算时，仍然采用前面的方法。\n与next数组的求解相比，KMP的匹配算法相对要简单很多，它在形式上与简单的模式匹配\n算法很相似。不同之处仅在于当匹配过程产生失配时，指针i不变，指针j退回到next[j］的\n位置并重新进行比较，且当指针j为0时，指针i和j同时加1。也就是说，若主串的第i个位\nint Index_KMP(SString S,SString T,int next[]){\ninti=1,j=1;\nwhile(i<=s.length&&j<=T.length)(\nif（j==0l|S.ch[i]==T.ch[j]）{\n++i;++j;\n//继续比较后继字符\nelse\nj=next[j];\n//模式串向右滑动\nif(j>T.length)\nreturn i-T.length;\n//匹配成功\nelse\nreturn 0;\n况下，普通模式匹配的实际执行时间复杂度近似为O（m+n)，因此至今仍被采用。KMP算法仅在\n主串与子串有很多“部分匹配”时才显得比普通算法快，其主要优点是主串不回溯。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0411",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0412",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0423",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ],
        "summry": "**KMP算法**\n- **定义**：改进的串模式匹配算法，通过预处理模式串构建**next数组**，避免主串指针回溯，将时间复杂度优化至**O(n+m)**。\n- **核心思想**：\n- **部分匹配值（PM）**：模式串前缀与后缀的最长公共长度（如`'ababa'`的PM值为`[0,0,1,2,3]`）。\n- **next数组**：`next[j]`表示模式串第`j`个字符失配时，下一次匹配的起始位置（`next[j] = PM[j-1] + 1`）。\n- **滑动规则**：失配时，模式串右滑位数 = 已匹配字符数 - 对应PM值（如已匹配4字符且PM=1，则右滑3位）。\n- **手算next数组步骤**：\n1. `next[1] = 0`（固定）；\n2. 对每个位置`j>1`，向前找最长前缀`'p₁...pₖ'`与后缀`'p_{j-k+1}...p_{j-1}'`相等，则`next[j] = k`；\n3. 若无匹配前缀，则`next[j] = 1`。\n- **示例**：模式串`'abcac'`的next数组为`[0,1,1,1,2]`。\n- **算法实现**：\n- **预处理next数组**：\n```c\nvoid get_next(String T, int next[]) {\nint i = 1, j = 0;\nnext[1] = 0;\nwhile (i < T.length) {\nif (j == 0 || T.ch[i] == T.ch[j]) {\n++i; ++j; next[i] = j;\n} else j = next[j];\n}\n}\n```\n- **匹配过程**：主串指针`i`不回溯，模式串指针`j`根据`next[j]`回退。\n- **关键点**：\n- **优势**：主串无回溯，适合处理大文本和频繁部分匹配的场景。\n- **记忆提示**：\n- \"已匹配部分的首尾重合决定滑动距离\"；\n- \"next数组即模式串的自我匹配表\"。\n- **应用场景**：文本编辑器查找、DNA序列比对等需高效匹配的场景。"
    },
    {
        "id": "kc0423",
        "title": "KMP算法的进一步优化",
        "chapter_id": "04",
        "description": "前面定义的next数组在某些情况下尚有缺陷，还可以进一步优化。如图4.5所示，模式中\n主串\n模式串\nj\nnext[j]\nnextval[j]\n0\n图4.5KMP算法进一步优化示例\n当i=4、j=4 时，s4跟p4（b≠a）失配，若用之前的 next 数组，则还需要进行 s4与p3、S4\n与 p2、S4与 p1这 3次比较。事实上，因为 Pnext[4]=3=P4=a、Pnext[3]=2=P3=a、Pnext[2]=1=P2=a,\n显然后面3次用一个和p4相同的字符跟s4比较毫无意义，必然失配。那么问题出在哪里呢？\n问题在于不应该出现 pj=Pnext[ij]。理由是：当 p;≠s时，下次匹配必然是 Pnext[j]跟 s比较，\n若 p=Pnext[j]，则相当于拿一个和pg 相等的字符跟 s比较，这必然导致继续失配，这样的比较毫\n无意义。若出现p=Pnext[j]，则如何处理呢？\n等为止，更新后的数组命名为nextval。计算next数组修正值的算法如下，此时匹配算法不变。\nvoid get_nextval(sstring T,int nextval[]){\n\n118\n2026年数据结构考研复习指导\nint i=1，j=0;\nnextval[1]=0;\nwhile(i<T.length){\nif(j==01|T.ch[i]==T.ch[j]){\n++i;++j;\nif(T.ch[i]!=T.ch[j])\nnextval[i]=j;\nelsenextval[i]=nextval[j];\nelse\nj=nextval[j];\nKMP算法对于初学者来说可能不太容易掌握，建议读者结合王道课程来理解。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0324",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0344",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0411",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0412",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0413",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0421",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0422",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q042001",
            "q042002",
            "q042003",
            "q042004",
            "q042005",
            "q042006",
            "q042007",
            "q042008",
            "q042009",
            "q042010",
            "q042011"
        ],
        "summry": "**KMP算法的进一步优化（nextval数组）**\n- **优化背景**：\n- **缺陷**：原`next`数组在`p[j] == p[next[j]]`时（如图4.5中`p4=a`且`p[next[4]]=a`），会导致多次无意义的重复比较。\n- **核心问题**：若失配字符`p[j]`与回溯后的字符`p[next[j]]`相同，则后续比较必然继续失配。\n- **优化原理**：\n- **nextval数组**：在计算`next`数组时，若`p[i] == p[j]`，则直接跳过冗余比较，令`nextval[i] = nextval[j]`（即继承更早的有效回溯位置）。\n- **递归修正**：通过递归检查`next`链，避免相同字符的重复回溯。\n- **算法实现**：\n```c\nvoid get_nextval(SString T, int nextval[]) {\nint i = 1, j = 0;\nnextval[1] = 0;\nwhile (i < T.length) {\nif (j == 0 || T.ch[i] == T.ch[j]) {\n++i; ++j;\nif (T.ch[i] != T.ch[j]) nextval[i] = j;\nelse nextval[i] = nextval[j]; // 关键优化：避免相同字符回溯\n} else {\nj = nextval[j];\n}\n}\n}\n```\n- **时间复杂度**：\n- 预处理：**O(m)**（模式串长度），与原`next`数组相同。\n- 匹配阶段：**O(n)**（主串长度），但实际比较次数减少。\n- **应用场景**：\n- 模式串含大量重复字符（如`aaaaab`），优化后显著减少比较次数。\n- **记忆提示**：\n- **“同字符跳nextval”**：当`p[i] == p[j]`时，直接继承`nextval[j]`的值，跳过无效回溯。\n- **对比原next**：`nextval`是`next`的“去重版”，解决连续相同字符导致的冗余比较。\n- **示例**：\n- 模式串`ababaa`的`next`为`[0,1,1,2,3,4]`，优化后`nextval`为`[0,1,0,1,0,4]`，避免`a`与`a`的重复比较。"
    },
    {
        "id": "kc0511",
        "title": "树的定义",
        "chapter_id": "05",
        "description": "树是n（n≥0）个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：\n1）有且仅有一个特定的称为根的结点。\n\n第5章树与二叉树\n125\n2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T，T2,·\"，Tm，其中每个集\n合本身又是一棵树，并且称为根的子树。\n显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树\n作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：\n1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。\n2）树中所有结点都可以有零个或多个后继。\n树适用于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个\n结点（其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边。\n而树中每个结点与其下一层的零个或多个结点（其孩子结点）都有直接关系。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0512",
                "relation_type": "extension"
            },
            {
                "id": "kc0513",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q051001"
        ],
        "summry": "**树的定义**\n- **核心概念**：\n- 由**n（n≥0）个结点**组成的有限集合，**n=0**时称为**空树**。\n- 非空树满足：\n1. **唯一根结点**：有且仅有一个无前驱的根。\n2. **递归子树**：其余结点划分为**m（m>0）个互不相交的子集**，每个子集本身是一棵树（子树）。\n- **特性**：\n- **递归结构**：定义中嵌套子树，体现自相似性。\n- **分层逻辑**：\n1. 根无前驱，其他结点有**唯一前驱（父结点）**。\n2. 任意结点可有**零个或多个后继（子结点）**。\n- **边数关系**：n个结点的树必有**n-1条边**（每个非根结点唯一父边）。\n- **应用场景**：\n- 表示**层次化数据**（如文件系统、组织架构）。\n- 作为其他树形结构（二叉树、B树等）的基础。\n- **关键记忆点**：\n- **“根独无前驱，子集递归分”**：强调根的唯一性和子树的递归定义。\n- **“结点数=边数+1”**：快速推导树中边与结点的关系。"
    },
    {
        "id": "kc0512",
        "title": "基本术语",
        "chapter_id": "05",
        "description": "下面结合图5.1中的树来说明一些基本术语和概念。\n第1层\n第2层\n高度为4\n第3层\n第4层\n图5.1树的树形表示\n1）祖先、子孙、双亲、孩子、兄弟和堂兄弟。\n考虑结点K，从根A到结点K的唯一路径上的所有其他结点，称为结点K的祖先。如结\n点B是结点K的祖先，而K是B的子孙，结点B的子孙包括E，F，K，L。路径上最接近\n结点K的结点E称为K的双亲，而K为E的孩子。根A是树中唯一没有双亲的结点。有\n相同双亲的结点称为兄弟，如结点K和结点L有相同的双亲E，即K和L为兄弟。双亲\n在同一层的结点互为堂兄弟，结点G与E，F,H,I,J互为堂兄弟。\n2）结点的层次、深度和高度。\n结点的层次从树根开始定义，根结点为第1层，它的孩子为第2层，以此类推。结点的\n深度就是结点所在的层次。树的高度（或深度）是树中结点的最大层数。结点的高度是\n以该结点为根的子树的高度。图5.1中树的高度为4。\n3）结点的度和树的度。\n树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点B\n的度为2，结点D的度为3，树的度为3。\n4）分支结点和叶结点。\n度大于0的结点称为分支结点（也称非终端结点）：度为0（没有孩子结点）的结点称为\n叶结点（也称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。\n5）有序树和无序树。\n树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。\n假设图5.1为有序树，若将子结点位置互换，则变成一棵不同的树。\n6）路径和路径长度。\n树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是\n路径上所经过的边的个数。\n\n126\n2026年数据结构考研复习指导\n注意\n因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩\n子之间不存在路径。\n7）森林。\n命题追踪森林中树的数量、边数和结点数的关系（2016）\n森林是m（m≥0）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要\n把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵\n树作为该结点的子树，则森林就变成了树。\n注意\n上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题\n目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。",
        "related_points": [
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q051001"
        ],
        "summry": "**基本术语（树结构）**\n1. **结点关系**\n- **祖先/子孙**：根到某结点路径上的所有结点为其祖先（如B是K的祖先），反之为其子孙（K是B的子孙）。\n- **双亲/孩子**：路径上最近的祖先为双亲（E是K的双亲），直接下级为孩子（K是E的孩子）。\n- **兄弟/堂兄弟**：同双亲的结点为兄弟（K和L）；双亲同层的结点为堂兄弟（G与E、F等）。\n2. **层次与高度**\n- **层次**：根为第1层，逐层递增。\n- **深度**=结点层次（如第3层结点深度为3）。\n- **高度**：子树的最大层数（树的高度=4，结点E的高度=2）。\n3. **度**\n- **结点度**：孩子个数（B的度=2，D的度=3）。\n- **树的度**：所有结点的最大度数（树的度=3）。\n4. **结点分类**\n- **分支结点**：度>0（如B、D）。\n- **叶结点**：度=0（如K、L）。\n5. **树类型**\n- **有序树**：子树顺序不可互换（互换则视为不同树）。\n- **无序树**：子树顺序无关。\n6. **路径**\n- **路径**：两结点间的结点序列（方向必须从上向下）。\n- **路径长度**：路径上的边数（如A→K路径长度为3）。\n7. **森林**\n- 由m（m≥0）棵互不相交的树组成。\n- **与树的关系**：删除根结点→森林；添加根结点合并子树→森林变树。\n**记忆提示**\n- 祖先≈家族谱系，深度≈楼层号，高度≈子树层数。\n- 路径方向固定（双亲→孩子），兄弟需同父，堂兄弟需同“爷”。"
    },
    {
        "id": "kc0513",
        "title": "树的性质",
        "chapter_id": "05",
        "description": "树具有如下最基本的性质：\n命题追踪树中结点数和度数的关系的应用（2010、2016）\n1）树的结点数n等于所有结点的度数之和加1。\n结点的度是指该结点的孩子数量，每个结点与其每个孩子都由唯一的边相连，因此树中\n所有结点的度数之和等于树中的边数之和。树中的结点（除根外）都有唯一的双亲，因\n此结点数n等于边数之和加1，即所有结点的度数之和加1。\n2）度为m的树中第i层上至多有m-1个结点（i≥1）。\n第1层至多有1个结点（根结点），第2层至多有m个结点，第3层至多有m²个结点，\n以此类推。使用数学归纳法可推出第i层至多有㎡-!个结点。\n3）高度为h的m叉树至多有（m-1）/（m-1)个结点。\n当各层结点数达到最大时，树中至多有1+m+㎡²+…+m-1=（m-1)/（m-1)个结点。\n命题追踪指定结点数的三叉树的最小高度分析（2022）\n4）度为m、具有n个结点的树的最小高度h为[logm(n(m-1)+ 1)]。\n为使树的高度最小，在前h-1层中，每层的结点数都要达到最大，前h-1层最多有\n(m-1-1)/(m-1)个结点，前h层最多有(m²-1)/(m-1)个结点。因此（m²--1)/(m-1)<n≤\n(m-1) /(m-1)，即h-1 <logm(n(m-1)+ 1)≤h，解得hmin=[1ogm(n(m-1)+ 1)]。\n5）度为m、具有n个结点的树的最大高度h为n-m+1。\n树的度为m，因此至少有一个结点有㎡个孩子，它们处于同一层。为使树的高度最大，\n其他层可仅有一个结点，因此最大高度（层数）为n-m+1。由此，也可逆推出高度为h、\n度为m的树至少有h+m-1个结点。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "extension"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q051001"
        ],
        "summry": "**树的性质**\n- **定义**：描述树结构（无环连通图）中结点、度数、高度之间的数学关系。\n- **核心性质**：\n1. **结点数与度数的关系**：\n- 树中结点数 `n = 所有结点度数之和 + 1`（度数=孩子数，边数=度数总和，根无父边）。\n- *记忆提示*：边数=结点数-1，度数总和=边数。\n2. **第i层最大结点数**：\n- 度为 `m` 的树中，第 `i` 层至多有 `m^(i-1)` 个结点（根为第1层）。\n3. **最大结点总数**：\n- 高度为 `h` 的 `m` 叉树至多有 `(m^h - 1)/(m - 1)` 个结点（等比数列求和）。\n4. **最小高度公式**：\n- `n` 个结点的 `m` 叉树最小高度 `h = ⌈logₘ(n(m-1) + 1)⌉`（前 `h-1` 层填满）。\n- *应用*：优化树结构以减少查找路径（如B树）。\n5. **最大高度公式**：\n- `n` 个结点的 `m` 叉树最大高度 `h = n - m + 1`（除一层外每层仅1结点）。\n- *推论*：高度为 `h` 的 `m` 叉树至少需 `h + m - 1` 个结点。\n- **应用场景**：\n- 分析树结构的存储效率（如满二叉树、B树）。\n- 设计算法时评估时间复杂度（如树遍历的层数影响）。\n- **记忆技巧**：\n- 最小高度≈对数增长，最大高度≈线性退化。\n- 结点数公式类比等比数列求和（满树时 `m^0 + m^1 + ... + m^(h-1)`）。"
    },
    {
        "id": "kc0521",
        "title": "二叉树的定义及其主要特性",
        "chapter_id": "05",
        "description": "1.二叉树的定义\n二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（二叉树中不存在度大\n于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。\n与树相似，二叉树也以递归的形式定义。二叉树是n（n≥0）个结点的有限集合：\n①或者为空二叉树，即n=0。\n②或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树\n又分别是一棵二叉树。\n二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有\n一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图5.2所示。\n(a)空二义树(b)只有根结点\n(c)只有左子树\n(d)左右子树都有\n(e)只有右子树\n图5.2二叉树的5种基本形态\n二叉树与度为2的有序树的区别：\n①度为2的树至少有3个结点，而二叉树可以为空。\n②度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩\n子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左\n右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。\n2.几种特殊的二叉树\n1）满二叉树。一棵高度为h，且有2\"-1个结点的二叉树称为满二叉树，即二叉树中的每层\n都含有最多的结点，如图5.3（a）所示。满二叉树的叶结点都集中在二叉树的最下一层，并\n且除叶结点之外的每个结点度数均为2。\n可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左\n向右。这样，每个结点对应一个编号，对于编号为i的结点，若有双亲，则其双亲为i/2」，\n若有左孩子，则左孩子为2i；若有右孩子，则右孩子为2i+1。\n\n第5章树与二叉树\n131\n命题追踪完全二叉树中结点数和叶结点数的关系（2009、2011、2018）\n2）完全二叉树。高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的\n满二叉树中编号为1～n的结点一一对应时，称为完全二叉树，如图5.3（b)所示。\n(a)满二叉树\n(b)完全二叉树\n图5.3两种特殊形态的二叉树\n3）二叉排序树。左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的\n关键字均大于根结点的关键字：左子树和右子树又各是一棵二叉排序树。\n4）平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。关于二\n叉排序树和平衡二叉树的详细介绍，见本书中的7.3节。\n命题追踪正则k叉树树高和结点数的关系的应用（2016）\n5）正则二叉树。树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。\n3.二叉树的性质\n1）非空二叉树上的叶结点数等于度为2的结点数加1，即no=n2+1。\n证明：设度为0,1和2的结点个数分别为no,n和n2，结点总数n=no+n+n2。\n再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设B为分支总数，\n则n=B+1。这些分支是由度为1或2的结点射出的，因此又有B=n+2n2。\n于是得no+n+n2=n+2n+1，则no=n2+1。\n注意\n该性质经常在选择题中涉及，希望读者牢记并灵活应用。\n2）非空二叉树的第k层最多有2k-1个结点（k≥1)。\n第1层最多有2-1=1个结点（根），第2层最多有22-1=2个结点，以此类推，可以证明\n其为一个公比为2的等比数列21。\n3）高度为h的二叉树至多有2-1个结点（h≥1）。\n该性质利用性质2求前h项的和，即等比数列求和的结果。\n注意\n性质2和性质3还可以拓展到m叉树的情况，即m叉树的第k层最多有m个个结点，高度为h的m\n叉树至多有（m-1）/（m-1）个结点。\n4）对完全二叉树按从上到下、从左到右的顺序依次编号1,2,,n，则有以下关系：\n①最后一个分支结点的编号为[n/2]，若i≤Ln/2]，则结点i为分支结点，否则为叶结点。\n①完全二叉树可视为从满二叉树中删去若干最底层、最右边的一些连续叶结点后所得到的二叉树。\n\n132\n2026年数据结构考研复习指导\n②叶结点只可能在最后两层上出现（相当于在相同高度的满二叉树的最底层、最右边减\n③若有度为1的结点，则最多只可能有一个，且该结点只有左孩子而无右孩子（度为1\n的分支结点只可能是最后一个分支结点，其结点编号为[n/2」）。\n④按层序编号后，一旦出现某结点（如编号i）为叶结点或只有左孩子的情况，则编号\n大于i的结点均为叶结点（与结论①和结论③是相通的）。\n若n为奇数，则每个分支结点都有左、右孩子：若n为偶数，则编号最大的分支结点\n（编号为n/2）只有左孩子，没有右孩子，其余分支结点都有左、右孩子。\n当i>1时，结点i的双亲结点的编号为i/2]。\n若结点i有左、右孩子，则左孩子编号为2i，右孩子编号为2i+1。\n⑧结点i所在层次（深度）为[log2i+1。\n5）具有n个（n>0）结点的完全二叉树的高度为「log2（n+1)]或Llog2n」+1。\n设高度为h，根据性质3和完全二叉树的定义有\n2\"-l-1<n≤2-1或者2\"-1≤n<2h\n得21<n+ 1≤2\"，即h-1<log2(n+1)≤h，因为h为正整数，所以h=[log2(n+ 1)]，\n或者得h-1≤log2n<h，所以h=Llog2n」+1。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "extension"
            },
            {
                "id": "kc0513",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q052002",
            "q052003",
            "q052005",
            "q052006",
            "q052008",
            "q052009",
            "q052011",
            "q052012",
            "q052013",
            "q052014",
            "q052015",
            "q052017",
            "q052019",
            "q052021",
            "q052022",
            "q052023",
            "q052025",
            "q052026",
            "q052027",
            "q052028",
            "q052029"
        ],
        "summry": "**二叉树**\n- **定义**：\n- 每个结点至多有两棵子树（度≤2），子树分**左子树**和**右子树**且次序不可颠倒。\n- 递归定义：空树（`n=0`）或由根结点+两个互不相交的左右子树（均为二叉树）构成。\n- **有序性**：即使只有一个子树，也需区分左右，颠倒左右会生成不同二叉树。\n- **与度为2的有序树区别**：\n1. 二叉树可为空；度为2的树至少需3个结点。\n2. 二叉树结点的左右次序是绝对的，与兄弟结点无关。\n- **特殊二叉树**：\n1. **满二叉树**：\n- 高度`h`，结点数`2^h -1`，每层结点数最大化。\n- 叶结点全在最底层，非叶结点度均为2。\n- **编号规则**：根为1，左孩子`2i`，右孩子`2i+1`。\n2. **完全二叉树**：\n- 结点编号与同高度满二叉树的`1~n`号一一对应。\n- 叶结点仅出现在最后两层，且最右连续缺失。\n3. **二叉排序树**：左子树关键字<根<右子树关键字（递归定义）。\n4. **平衡二叉树**：任意结点左右子树高度差绝对值≤1。\n5. **正则二叉树**：所有分支结点度均为2（无度为1的结点）。\n- **性质**：\n1. 叶结点数`n0 = n2 + 1`（`n2`为度为2的结点数）。\n2. 第`k`层最多`2^(k-1)`个结点。\n3. 高度`h`的二叉树最多`2^h -1`个结点。\n4. **完全二叉树特有性质**：\n- 分支结点编号≤`⌊n/2⌋`，最后一个分支结点可能只有左孩子。\n- 结点`i`的双亲为`⌊i/2⌋`，左孩子`2i`，右孩子`2i+1`。\n- 高度`h = ⌈log₂(n+1)⌉`或`⌊log₂n⌋ +1`。\n- **记忆提示**：\n- 满二叉树≈完美金字塔；完全二叉树≈满二叉树从右下角开始删除。\n- 完全二叉树编号规律：父子关系可通过乘除2快速定位。"
    },
    {
        "id": "kc0522",
        "title": "二叉树的存储结构",
        "chapter_id": "05",
        "description": "1.顺序存储结构\n二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的\n结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中。\n依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯\n地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值\n确定结点在二叉树中的位置，以及结点之间的关系。\n命题追踪特定条件下二叉树树形及占用存储空间的分析（2020）\n但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些\n并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量\n中。然而，在最坏情况下，一个高度为h且只有h个结点的单支树却需要占据近2\"-1个存储单\n元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。\n123456789\n[9 0l0 s 0 + 0 e1\n(a)完全二叉树的顺序存储结构\n(b)一般二叉树的顺序存储结构\n图5.4二叉树的顺序存储结构\n注意\n建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。\n\n第5章树与二叉树\n133\n2.链式存储结构\n顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉\n树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含\n3个域：数据域data、左指针域1child和右指针域rchild，如图5.5所示。\nlchild\ndata\nrchild\n图5.5\n二叉树链式存储的结点结构\n图5.6所示为一棵二叉树及其对应的二叉链表。而实际上在不同的应用中，还可以增加某些\n指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。\n4\n图5.6\n二叉链表的存储结构\n二叉树的链式存储结构描述如下：\ntypedef struct BiTNodet\nElemType data;\n//数据域\nstruct BiTNode\n*1child,*rchild;\nⅡ/左、右孩子指针\n)BiTNode,*BiTree;\n使用不同的存储结构时，实现二叉树操作的算法也会不同，因此要根据实际应用场合（二叉\n树的形态和需要进行的运算）来选择合适的存储结构。\n容易验证，在含有n个结点的二叉链表中，含有n+1个空链域（重要结论，经常出现在选\n择题中）。在下一节中，我们将利用这些空链域来组成另一种链表结构一一线索链表。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q052002",
            "q052003",
            "q052005",
            "q052006",
            "q052008",
            "q052009",
            "q052011",
            "q052012",
            "q052013",
            "q052014",
            "q052015",
            "q052017",
            "q052019",
            "q052021",
            "q052022",
            "q052023",
            "q052025",
            "q052026",
            "q052027",
            "q052028",
            "q052029"
        ],
        "summry": "**二叉树的存储结构**\n1. **顺序存储结构**\n- **定义**：用连续数组存储完全二叉树的结点，下标`i-1`对应编号`i`的结点（建议下标从1开始以对齐编号）。\n- **适用场景**：**完全二叉树**/**满二叉树**（数组下标直接反映逻辑关系，空间高效）。\n- **缺点**：\n- 一般二叉树需填充空结点（标记为0）以匹配完全二叉树结构，最坏情况（单支树）空间浪费达**O(2^h-1)**。\n- **关键点**：\n- 命题常考空间利用率分析（如2020年题）。\n- 图示对比完全二叉树（紧凑）与一般二叉树（稀疏填充）。\n2. **链式存储结构**\n- **定义**：通过结点指针动态链接，常用**二叉链表**（`data`、`lchild`、`rchild`）或**三叉链表**（增加`parent`指针）。\n- **优点**：\n- 灵活适应任意树形，无空间浪费。\n- **特性**：\n- n个结点的二叉链表含**n+1个空链域**（重要结论，用于后续线索二叉树构造）。\n- **代码表示**：\n```c\ntypedef struct BiTNode {\nElemType data;          // 数据域\nstruct BiTNode *lchild, *rchild; // 左右孩子指针\n} BiTNode, *BiTree;\n```\n**选择建议**：\n- **顺序存储**：仅推荐完全二叉树/满二叉树，或对空间不敏感且需快速定位父/子结点（计算下标）。\n- **链式存储**：通用选择，尤其适合频繁动态修改或非完全二叉树场景。\n**记忆技巧**：\n- 顺序存储≈完全二叉树“数组填满”，链式存储≈“指针灵活串结点”。\n- 空链域数 = n+1（联想：n结点有2n指针，实际用n-1条边，剩余n+1）。"
    },
    {
        "id": "kc0531",
        "title": "二叉树的遍历",
        "chapter_id": "05",
        "description": "二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅\n被访问一次。二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，\n以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。\n命题追踪二叉树遍历方式的分析（2009、2011、2012）\n命题追踪（算法题）二叉树遍历的相关应用（2014、2017、2022）\n由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访\n问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）\n和后序（LRN）三种遍历算法，其中序指的是根结点在何时被访问。\n\n第5章树与二叉树\n141\n1．先序遍历（PreOrder）\n若二叉树为空，则什么也不做：否则，公众号：小兔网盘免费分享无水印PDF\n1）访问根结点；\n2）先序遍历左子树：\n3）先序遍历右子树。\n图5.7中的虚线表示对该二叉树进行先序遍历的路径，得到先序遍历序列为124635。\n开始\n图5.7二叉树的先序遍历\n对应的递归算法如下：\nvoid PreOrder(BiTreeT){\nif(T!=NULL）{\nvisit(T);\n/访问根结点\nPreOrder(T->lchild);\n//递归遍历左子树\nPreOrder(T->rchild);\n//递归遍历右子树\n2.中序遍历（InOrder）\n若二叉树为空，则什么也不做；否则，\n1）中序遍历左子树；\n2）访问根结点；\n3）中序遍历右子树。\n命题追踪\n中序序列中结点关系的分析（2017、2024）\n图5.8中的虚线表示对该二叉树进行中序遍历的路径，得到中序遍历序列为264135。\n开始（\n结束\n图5.8二叉树的中序遍历\n对应的递归算法如下：\nvoid InOrder(BiTree T){\nif（T!=NULL）{\nInOrder(T->lchild);\n/递归遍历左子树\n\n142\n2026年数据结构考研复习指导\nvisit(T);\n/访问根结点\nInOrder(T->rchild);\n/递归遍历右子树\n3.后序遍历（PostOrder）\n若二叉树为空，则什么也不做：否则，\n1）后序遍历左子树；\n2）后序遍历右子树；\n3）访问根结点。\n图5.9中的虚线表示对该二叉树进行后序遍历的路径，得到后序遍历序列为642531。\n结束\n开始\n图5.9二叉树的后序遍历\n对应的递归算法如下：\nvoid PostOrder(BiTree T){\nif（T!=NULL){\nPostOrder(T->lchild);\n/递归遍历左子树\nPostOrder(T->rchild);\n/递归遍历右子树\nvisit(T);\n/访问根结点\n上述三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。\n不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度都是O(n)。在递归\n遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为\nn的单支树，遍历算法的空间复杂度为O（n)。\n4.层次遍历\n图5.10所示为二叉树的层次遍历，即按照箭头所指方向，按照1,2，3，4的层次顺序，自上而\n下、从左至右对二叉树中的各个结点进行逐层访问。\n图5.10二叉树的层次遍历\n进行层次遍历时，需要借助一个队列。层次遍历的思想如下：①首先将根结点入队。②若队\n\n第5章树与二叉树\n143\n列非空，则队头结点出队，访问该结点，若它有左孩子，则将其左孩子入队；若它有右孩子，则\n将其右孩子入队。③重复步骤②，直至队列为空。\n二叉树的层次遍历算法如下：\nvoid LevelOrder(BiTree T){\nInitQueue(Q);\n//初始化辅助队列\nBiTree p;\nEnQueue(Q,T);\n/将根结点入队\nwhile(!IsEmpty(Q))(\n/队列不空则循环\nDeQueue(Q,p);\n/队头结点出队\nvisit(p);\n/访问出队结点\nif(p->lchild!=NULL)\nEnQueue(Q,p->lchild);\n//若左孩子不空，则左孩子入队\nif(p->rchild!=NULL)\nEnQueue(Q,p->rchild);\n//若右孩子不空，则右孩子入队\n在复习过程中，读者应将上述二叉树层次遍历的算法作为一个模板，熟练掌握其执行过程，\n并达到熟练手写的程度。\n注意\n遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树\n的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此\n必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。\n5.由遍历序列构造二叉树\n命题追踪\n先序序列对应的不同二叉树的分析（2015）\n对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是确定的。然而，\n只给出四种遍历序列中的任意一种，却不能唯一地确定一棵二叉树。若已知中序序列，再给出其\n他三种遍历序列中的任意一种，就可以唯一地确定一棵二叉树。\n（1）由先序序列和中序序列构造二叉树\n命题追踪先序序列和中序序列相同时确定的二叉树（2017）\n命题追踪由先序序列和中序序列构造一棵二叉树（2020、2021）\n在先序序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序\n列分割成两个子序列，前一个子序列是根的左子树的中序序列，后一个子序列是根的右子树的中\n序序列。左子树的中序序列和先序序列的长度是相等的，右子树的中序序列和先序序列的长度是\n相等的。根据这两个子序列，可以在先序序列中找到左子树的先序序列和右子树的先序序列，如\n图5.11所示。如此递归地分解下去，便能唯一地确定这棵二叉树。\n先序序列\n根\n（左子树的先序序列\n【右子树的先序序列\n左子树\n右子树\n中序序列\n【左子树的中序序列\n根\n【右子树的中序序列\n图5.11由先序序列和中序序列构造二叉树\n\n144\n2026年数据结构考研复习指导\n例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。首先，由\n先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列，EDGHFI为\n右子树的中序序列。然后，由先序序列可知B是左子树的根结点，D是右子树的根结点。以此类\n推，就能将剩下的结点继续分解下去，最后得到的二叉树如图5.12（c）所示。\n(a)\n(b)\n(c)\n图5.12\n2一棵二叉树的构造过程\n（2）由后序序列和中序序列构造二叉树\n命题追踪由后序序列和树形构造一棵二叉树（2017、2023）\n同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后\n一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，如图5.13所示，然\n后采用类似的方法递归地进行分解，进而唯一地确定这棵二叉树。\n后序序列\n左子树的后序序列\n右子树的后序序列\n根\n1/\n左子树\n右子树\n中序序列\n左子树的中序序列\n右子树的中序序列\n图5.13由后序序列和中序序列构造二叉树\n请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。\n（3）由层序序列和中序序列构造二叉树\n在层序遍历中，第一个结点一定是二叉树的根结点，这样就将中序序列分割成了左子树的中\n序序列和右子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可进\n步划分左子树；若存在右子树，则层序序列中紧接着的下一个结点一定是右子树的根，可进一\n步划分右子树，如图5.14所示。采用这种方法继续分解，就能唯一确定这棵二叉树。\n层序序列\n根\n【左子树的根】[右子树的根】\n左子树\n右子树\n中序序列\n左子树的中序序列\n右子树的中序序列\n图5.14由层序序列和中序序列构造二叉树\n请读者分析层序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。\n注意，先序序列、后序序列和层序序列的两两组合，无法唯一确定一棵二叉树。例如，图5.15\n所示的两棵二叉树的先序序列都为AB，后序序列都为BA，层序序列都为AB。\n\n第5章\n树与二叉树\n145\n(a)\n(b)\n图5.15两棵不同的二叉树",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "extension"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "extension"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0532",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0542",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0551",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q053001",
            "q053002",
            "q053003",
            "q053004",
            "q053005",
            "q053006",
            "q053007",
            "q053008",
            "q053011",
            "q053012",
            "q053013",
            "q053014",
            "q053015",
            "q053016",
            "q053017",
            "q053018",
            "q053020",
            "q053021",
            "q053022",
            "q053023",
            "q053024",
            "q053025",
            "q053026",
            "q053027",
            "q053028",
            "q053029",
            "q053030",
            "q053032",
            "q053034",
            "q053035",
            "q053036"
        ],
        "summry": "**二叉树的遍历**\n- **定义**：按特定顺序访问二叉树中所有结点，确保每个结点被访问一次且仅一次。非线性结构通过遍历转为线性序列。\n- **核心遍历方式**：\n1. **先序遍历（NLR）**：\n- **步骤**：根 → 左子树 → 右子树。\n- **递归实现**：\n```c\nvoid PreOrder(BiTree T) {\nif (T != NULL) {\nvisit(T);\nPreOrder(T->lchild);\nPreOrder(T->rchild);\n}\n}\n```\n- **示例序列**：124635（图5.7）。\n2. **中序遍历（LNR）**：\n- **步骤**：左子树 → 根 → 右子树。\n- **递归实现**：\n```c\nvoid InOrder(BiTree T) {\nif (T != NULL) {\nInOrder(T->lchild);\nvisit(T);\nInOrder(T->rchild);\n}\n}\n```\n- **应用**：二叉搜索树中获取有序序列（如264135）。\n3. **后序遍历（LRN）**：\n- **步骤**：左子树 → 右子树 → 根。\n- **递归实现**：\n```c\nvoid PostOrder(BiTree T) {\nif (T != NULL) {\nPostOrder(T->lchild);\nPostOrder(T->rchild);\nvisit(T);\n}\n}\n```\n- **示例序列**：642531（图5.9）。\n4. **层次遍历**：\n- **步骤**：按层从上到下、从左到右访问，借助队列实现。\n- **算法**：\n```c\nvoid LevelOrder(BiTree T) {\nInitQueue(Q);\nEnQueue(Q, T);\nwhile (!IsEmpty(Q)) {\nDeQueue(Q, p);\nvisit(p);\nif (p->lchild) EnQueue(Q, p->lchild);\nif (p->rchild) EnQueue(Q, p->rchild);\n}\n}\n```\n- **关键点**：队列辅助，空间复杂度**O(n)**。\n- **时间复杂度**：所有遍历均为**O(n)**（每个结点访问一次）。\n- **空间复杂度**：递归遍历为**O(h)**（h为树高，最坏**O(n)**）；层次遍历为**O(n)**。\n- **构造二叉树**：\n- **唯一性条件**：需中序序列 + 先序/后序/层序之一。\n- **先序+中序**：先序首元素为根，划分中序左右子树。\n- **后序+中序**：后序末元素为根，划分中序左右子树。\n- **层序+中序**：层序首元素为根，递归处理左右子树。\n- **反例**：仅先序+后序/层序无法唯一确定（如图5.15两树序列相同）。\n- **应用**：求深度、叶结点数、判断树相同等操作均依赖遍历。\n**快速记忆**：\n- **递归遍历**：NLR（先序）、LNR（中序）、LRN（后序）。\n- **层次遍历**：队列辅助，类似BFS。\n- **构造树**：中序是“分割线”，先序/后序/层序提供根节点位置。"
    },
    {
        "id": "kc0532",
        "title": "线索二叉树",
        "chapter_id": "05",
        "description": "1.线索二叉树的基本概念\n遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序\n列，使得该序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。\n命题追踪线索二叉树的定义（2010）\n传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提\n到，在含n个结点的二叉树中，有n+1个空指针。这是因为每个叶结点都有2个空指针，每个度为1\n的结点都有1个空指针，空指针总数为2ng+n，又no=n+1，所以空指针总数为ng+n+n+1=n+1。\n由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地\n遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。\n规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。\n如图5.16所示，还需增加两个标志域，以标识指针域指向左（右）孩子或前驱（后继）。\nlchild\nltag\ndata\nrtag\nrchild\n图5.16线索二叉树的结点结构\n其中，标志域的含义如下：\n[0,\nlchild域指示结点的左孩子\nltag\n[1,\nlchild域指示结点的前驱\n[0,\nrchild域指示结点的右孩子\n[1，\nrchild域指示结点的后继\n线索二叉树的存储结构描述如下：\ntypedef struct ThreadNode{\nElemType data;\n//数据元素\nstruct ThreadNode *lchild,*rchild;\n//左、右孩子指针\nint ltag,rtag;\n//左、右线索标志\n)ThreadNode,*ThreadTree;\n以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱\n和后继的指针称为线索。加上线索的二叉树称为线索二叉树。\n2.中序线索二叉树的构造\n二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息\n只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。\n命题追踪\n中序线索二叉树中线索的指向（2014）\n以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针p指向正在访\n问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就\n将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如图5.17所示。\n\n146\n2026年数据结构考研复习指导\n|1Di]\n1EL\n图5.17中序线索二叉树及其二叉链表示\n通过中序遍历对二叉树线索化的递归算法如下：\nvoid InThread(ThreadTree &p,ThreadTree&pre)(\nif（p!=NULL){\nInThread(p->lchild,pre);\n/递归，线索化左子树\nif (p->lchild==NULL){\n//当前结点的左子树为空\np->lchild=pre;\n/建立当前结点的前驱线索\np->ltag=l;\nif（pre!=NULL&&pre->rchild==NULL）（//前驱结点非空且其右子树为空\npre->rchild=p;\n/建立前驱结点的后继线索\npre->rtag=l;\npre=p;\n/标记当前结点成为刚刚访问过的结点\nInThread(p->rchild,pre);\n//递归，线索化右子树\n通过中序遍历建立中序线索二叉树的主过程算法如下：\nvoid CreateInThread(ThreadTree T)(\nThreadTree pre=NULL;\nif（T!=NULL){\n/非空二叉树，线索化\nInThread(T,pre);\n//线索化二叉树\npre->rchild=NULL;\nⅡ/处理遍历的最后一个结点\npre->rtag=1;\n为方便起见，可在二叉树的线索链表上也添加一个头结点，令其1child域的指针指向二叉\n树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点：令二叉树中序序列中的\n第一个结点的1child域指针和最后一个结点的rchild域指针均指向头结点。这好比为二叉树\n建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如图5.18所示。\nHead\nD\nE\n图5.18带头结点的中序线索二叉树\n\n第5章树与二叉树\n147\n3.中序线索二叉树的遍历\n中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先\n找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结\n点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访\n问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。\n1）求中序线索二叉树的中序序列下的第一个结点：\nThreadNode *Firstnode(ThreadNode *p){\nwhile（p->ltag==0）p=p->lchild;//最左下结点（不一定是叶结点）\nreturn p;\n2）求中序线索二叉树中结点p在中序序列下的后继：\nThreadNode*Nextnode(ThreadNode*p)(\nif(p->rtag==0）return Firstnode(p->rchild）；//右子树中最左下结点\nelse return p->rchild;\nl//若rtag==1则直接返回后继线索\n请读者自行分析并完成求中序线索二叉树的最后一个结点和结点p前驱的运算?。\n3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法：\nvoid Inorder(ThreadNode *T){\nfor（ThreadNode*p=Firstnode（T);p!=NULL;p=Nextnode(p))\nvisit(p);\n4.先序线索二叉树和后序线索二叉树\n上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码\n类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。\n以图5.19(a)的二叉树为例给出手工求先序线索二叉树的过程：先序序列为ABCDF，然后依\n次判断每个结点的左右链域，若为空，则将其改造为线索。结点A，B均有左右孩子；结点C无左\n孩子，将左链域指向前驱B，无右孩子，将右链域指向后继D：结点D无左孩子，将左链域指向\n前驱C，无右孩子，将右链域指向后继F；结点F无左孩子，将左链域指向前驱D，无右孩子，\n也无后继，所以置空，得到的先序线索二叉树如图5.19（b)所示。求后序线索二叉树的过程：后序\n序列为CDBFA，结点C无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继D；结\n点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B；结点F无左孩子，将左\n链域指向前驱B，无右孩子，将右链域指向后继A，得到的后序线索二叉树如图5.19（c）所示。\n小兔网盘\n免费网课+无水印PDF\n(a)一颗二叉树\n(b)先序线索二叉树\n(c)后序线索二叉树\n图5.19先序线索二叉树和后序线索二叉树\n如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但\n有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。\nltag和1child，此外调用函数改为求左了树的中序线索二叉树的最后个结点，即求中序线索二叉树中结点p的前驱。\n\n148\n2026年数据结构考研复习指导\n命题追踪后序线索二叉树中线索的指向（2013）\n在后序线索二叉树中找结点的后继较为复杂，可分三种情况：①若结点x是二叉树的根，则\n其后继为空：②若结点x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后\n继即双亲：③若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后\n序遍历列出的第一个结点。图5.19（c)中找结点B的后继无法通过链域找到，可见在后序线索二叉\n树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0542",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q053001",
            "q053002",
            "q053003",
            "q053004",
            "q053005",
            "q053006",
            "q053007",
            "q053008",
            "q053011",
            "q053012",
            "q053013",
            "q053014",
            "q053015",
            "q053016",
            "q053017",
            "q053018",
            "q053020",
            "q053021",
            "q053022",
            "q053023",
            "q053024",
            "q053025",
            "q053026",
            "q053027",
            "q053028",
            "q053029",
            "q053030",
            "q053032",
            "q053034",
            "q053035",
            "q053036"
        ],
        "summry": "**线索二叉树**\n- **定义**：通过利用二叉树中的空指针域存储前驱/后继指针，将二叉树线性化的存储结构。\n- **核心思想**：\n- 空指针利用：含n个结点的二叉树有**n+1**个空指针（叶结点2个/度1结点1个），将其改为线索（前驱/后继）。\n- **结点结构**：\n```c\ntypedef struct ThreadNode {\nElemType data;\nstruct ThreadNode *lchild, *rchild; // 左右孩子指针\nint ltag, rtag;                     // 标志位（0=孩子，1=线索）\n} ThreadNode, *ThreadTree;\n```\n- **线索化类型**：\n1. **中序线索化**：\n- **过程**：中序遍历时，若左/右子树为空，则指向`pre`（前驱）或`p`（后继）。\n- **关键代码**：\n```c\nvoid InThread(ThreadTree &p, ThreadTree &pre) {\nif (p != NULL) {\nInThread(p->lchild, pre);  // 线索化左子树\nif (p->lchild == NULL) { p->lchild = pre; p->ltag = 1; } // 前驱线索\nif (pre != NULL && pre->rchild == NULL) { pre->rchild = p; pre->rtag = 1; } // 后继线索\npre = p;\nInThread(p->rchild, pre);  // 线索化右子树\n}\n}\n```\n2. **先序线索化**：调整线索化代码与递归顺序（先处理当前结点，再左右子树）。\n3. **后序线索化**：需处理双亲关系，通常需三叉链表存储。\n- **遍历操作**（以中序为例）：\n- **找第一个结点**：沿左子树至最左下（`ltag=0`终止）。\n- **找后继**：\n- 若`rtag=1`，直接返回`rchild`（线索）；\n- 若`rtag=0`，返回右子树的最左下结点。\n- **遍历算法**：\n```c\nvoid Inorder(ThreadNode *T) {\nfor (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p))\nvisit(p);\n}\n```\n- **应用场景**：\n- 加速遍历：无需递归/栈即可实现**O(1)**时间查找前驱/后继。\n- 内存优化：利用空指针减少存储浪费。\n- **记忆技巧**：\n- **中序线索**：左→根→右，线索化时`pre`跟踪前驱。\n- **先序后继**：左孩子优先，无左则右，叶结点直接线索。\n- **后序后继**：需双亲信息，分根/右孩子/左孩子三种情况处理。\n- **图示类比**：\n- 线索链表≈双向链表，头结点（如有）连接首尾形成环。\n- 空指针利用≈“废弃车道改造成捷径”。"
    },
    {
        "id": "kc0541",
        "title": "树的存储结构",
        "chapter_id": "05",
        "description": "树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存\n储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。\n1.双亲表示法\n这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示\n其双亲结点在数组中的位置。如图5.20所示，根结点下标为0，其伪指针域为-1。\n双亲表示法的存储结构描述如下：\n#define MAX_TREE_SIZE 100\n/树中最多结点数\n//树的结点定义\ntypedef struct{\nElemType data;\n//数据元素\nint parent;\n//双亲位置域\n)PTNode;\ntypedef struct{\n//树的类型定义\nPTNode nodes[MAX_TREE_SIZE];\nI/双亲表示\nint n;\n//结点数\n)PTree;\ndata\nparent\nR\n-1\nA\n0\n2\nB\n0\nC\n0\nD\nE\n1\nF\n6\nH\n6\nK\n6\n(a)一棵树\n（b）双亲表示\n(c)双亲指针图示\n图5.20树的双亲表示法\n双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点\n的双亲结点，但求结点的孩子时则需要遍历整个结构\n\n172\n2026年数据结构考研复习指导\n注意\n区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编\n号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点\n的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构\n来存储，但树却不都能用二叉树的存储结构来存储。\n2.孩子表示法\n找，可采用顺序存储结构。图5.21（a)是图5.20（a)中的树的孩子表示法。\n3\nR\nB\nE\nD\nM\n(a）孩子表示法\n（b）孩子兄弟表示法\n图5.21树的孩子表示法和孩子兄弟表示法\n与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历n\n个结点中孩子链表指针域所指向的n个孩子链表。\n3.孩子兄弟表示法\n孩子兄弟表示法也称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每\n个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结\n点的指针（沿此域可以找到结点的所有兄弟结点），如图5.21(b）所示。\n孩子兄弟表示法的存储结构描述如下：\ntypedef struct CsNodet\nElemType data;\n/数据域\nstruct CSNode\n*firstchild,*nextsibling;\n/第一个孩子和右兄弟指针\n)CSNode,*CSTree;\n孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查\n找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent\n域指向其父结点，则查找结点的父结点也很方便。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0235",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0344",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0542",
                "relation_type": "extension"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            },
            {
                "id": "kc0552",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ],
        "summry": "**树的存储结构**\n1. **双亲表示法**\n- **定义**：用连续数组存储结点，每个结点包含数据域和指向双亲位置的伪指针（根节点的伪指针为-1）。\n- **实现**：\n```c\ntypedef struct {\nElemType data;  // 数据元素\nint parent;     // 双亲位置域\n} PTNode;\ntypedef struct {\nPTNode nodes[MAX_TREE_SIZE];  // 存储数组\nint n;                        // 结点数\n} PTree;\n```\n- **特性**：\n- **优点**：快速查找双亲结点（**O(1)**）。\n- **缺点**：查找孩子需遍历整个数组（**O(n)**）。\n- **注意**：与二叉树顺序存储不同，树的顺序存储仅通过数组下标表示编号，内容表示逻辑关系。\n2. **孩子表示法**\n- **定义**：每个结点的孩子用链表存储，通常结合顺序存储（数组存结点）和链式存储（链表存孩子指针）。\n- **特性**：\n- **优点**：查找孩子高效（直接访问链表）。\n- **缺点**：查找双亲需遍历所有孩子链表（**O(n)**）。\n- **图示**：数组结点指向孩子链表头节点（图5.21a）。\n3. **孩子兄弟表示法（二叉树表示法）**\n- **定义**：二叉链表结构，结点包含数据域、指向第一个孩子的指针（`firstchild`）和指向下一个兄弟的指针（`nextsibling`）。\n- **实现**：\n```c\ntypedef struct CSNode {\nElemType data;                   // 数据域\nstruct CSNode *firstchild, *nextsibling;  // 孩子及兄弟指针\n} CSNode, *CSTree;\n```\n- **特性**：\n- **优点**：\n- 易于实现树转二叉树（左孩子右兄弟）。\n- 查找孩子方便（通过`firstchild`和`nextsibling`遍历）。\n- **缺点**：查找双亲需额外`parent`指针（否则需遍历）。\n- **应用**：常用于树的二叉树形态处理（如森林转换）。\n**对比总结**\n| 方法           | 找双亲效率 | 找孩子效率 | 额外空间 | 适用场景               |\n|----------------|------------|------------|----------|------------------------|\n| **双亲表示法** | **O(1)**   | O(n)       | 低       | 频繁查父操作           |\n| **孩子表示法** | O(n)       | **O(1)**   | 中       | 频繁查子操作           |\n| **孩子兄弟法** | O(1)*      | **O(1)**   | 高       | 树与二叉树互转、遍历   |\n> *需附加`parent`指针，否则效率降低。"
    },
    {
        "id": "kc0542",
        "title": "树、森林与二叉树的转换",
        "chapter_id": "05",
        "description": "二叉树和树都可以用二叉链表作为存储结构。从物理结构上看，树的孩子兄弟表示法与二叉\n树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。\n\n第5章树与二叉树\n173\n1.树转换为二叉树\n命题追踪树和二叉树的转换及相关性质的推理（2009、2011）\n树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相\n邻右兄弟，这个规则也称左孩子右兄弟。根结点没有兄弟，因此树转换得到的二叉树没有右子树，\n如图5.22所示。\nG\n图5.22树与二叉树的对应关系\n树转换为二叉树的画法：\n1）在兄弟结点之间加一连线：\n2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；\n3）以树根为轴心，顺时针旋转45°。\n2.森林转换为二叉树\n命题追踪）森林和二叉树的转换及相关性质的推理（2014）\n将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树\n对应的二叉树的右子树必空，森林中各棵树的根也可视为兄弟关系，将第二棵树对应的二叉树当\n作第一棵二叉树根的右子树…·以此类推，就可以将森林转换为二叉树。\n森林转换为二叉树的画法：\n1）将森林中的每棵树转换成相应的二叉树；\n2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；\n3）以第一棵树的根为轴心顺时针旋转45°。\n或者先在森林中每棵树的根之间加一根连线，然后再采用树转换为二叉树的方法。\n3.二叉树转换为森林\n命题追踪由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）\n二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形\n式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉\n树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换\n\n174\n2026年数据结构考研复习指导\n成树，就得到了原森林，如图5.23所示。二叉树转换为树或森林是唯一的。\n森林与\n叉树对应\n叉树对应\nH\n树根相连并旋转\n图5.23森林与二叉树的对应关系",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ],
        "summry": "**树、森林与二叉树的转换**\n### **1. 树 → 二叉树**\n- **规则**：\n- **左孩子右兄弟**：每个结点的左指针指向**第一个孩子**，右指针指向**相邻右兄弟**。\n- 根结点无兄弟，转换后二叉树的右子树必为空。\n- **画法步骤**：\n1. 在兄弟结点间加连线；\n2. 仅保留每个结点与第一个孩子的连线，删除其他孩子连线；\n3. 以树根为轴心，顺时针旋转45°。\n- **关键性质**：转换后的二叉树形态唯一，且树中父子关系对应二叉树的左子树，兄弟关系对应右子树。\n---\n### **2. 森林 → 二叉树**\n- **规则**：\n1. 将森林中每棵树按**树→二叉树**规则转换；\n2. 将每棵二叉树的根视为兄弟，依次将第二棵树作为第一棵树根的右子树，第三棵树作为第二棵树根的右子树，依此类推。\n- **画法步骤**：\n1. 每棵树单独转换为二叉树；\n2. 在每棵树的根结点间加连线（视为兄弟）；\n3. 以第一棵树的根为轴心，顺时针旋转45°。\n- **替代方法**：\n1. 先在森林中所有树的根结点间加连线；\n2. 按**树→二叉树**规则整体转换。\n---\n### **3. 二叉树 → 森林**\n- **规则**：\n1. 断开根的右链，根的左子树为第一棵树的二叉树形式；\n2. 根的右子树递归处理，直到剩余二叉树无右子树；\n3. 将每棵二叉树按**二叉树→树**规则还原为树。\n- **唯一性**：转换结果唯一，且原森林的树数量等于二叉树右链上的结点数+1。\n---\n### **记忆技巧**\n- **树→二叉树**：左孩子（第一个孩子），右兄弟（相邻兄弟）。\n- **森林→二叉树**：多棵树转换后，根结点右链串联。\n- **逆转换**：断右链，递归处理右子树。\n**图示类比**：\n- 树转换后≈二叉树左斜（无右子树）；\n- 森林转换后≈二叉树右链延伸（每棵树对应右子树）。"
    },
    {
        "id": "kc0543",
        "title": "树和森林的遍历",
        "chapter_id": "05",
        "description": "1.树的遍历\n命题追踪树与二叉树遍历方法的对应关系（2019）\n树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式：\n1）先根遍历。若树非空，则按如下规则遍历：\n·先访问根结点。\n·再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。\n其遍历序列与这棵树相应二叉树的先序序列相同。\n2）后根遍历。若树非空，则按如下规则遍历：\n·先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则。\n·再访问根结点。\n其遍历序列与这棵树相应二叉树的中序序列相同。\n图5.22的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。\n另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。\n2.森林的遍历\n按照森林和树相互递归的定义，可得到森林的两种遍历方法。\n1）先序遍历森林。若森林为非空，则按如下规则遍历：\n·访问森林中第一棵树的根结点。\n）先序遍历第一棵树中根结点的子树森林。\n·先序遍历除去第一棵树之后剩余的树构成的森林。\n2）中序遍历森林。森林为非空时，按如下规则遍历：\n·中序遍历森林中第一棵树的根结点的子树森林。\n·访问第一棵树的根结点。\n·中序遍历除去第一棵树之后剩余的树构成的森林。\n图5.23的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。\n命题追踪森林与二叉树遍历方法的对应关系（2020）\n当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，\n\n第5章树与二叉树\n175\n可知森林的先序和中序遍历即其对应二叉树的先序和中序遍历。\n树和森林的遍历与二叉树的遍历关系见表5.1。\n表5.1树和森林的遍历与二叉树遍历的对应关系\n树\n森\n林\n二叉树\n先根遍历\n先序遍历\n先序遍历\n后根遍历\n中序遍历\n中序遍历\n注意\n森林的遍历方法的命名按照严蔚敏老师的经典教材。有些教材也将森林的中序遍历称为后序遍历，\n称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0323",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0532",
                "relation_type": "extension"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0542",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ],
        "summry": "**树和森林的遍历**\n### **1. 树的遍历**\n- **定义**：按特定顺序访问树中每个结点且仅访问一次。\n- **方法**：\n1. **先根遍历**（对应二叉树的**先序遍历**）：\n- 访问根结点 → 递归遍历每棵子树（先根顺序）。\n- *示例*：图5.22的树先根序列为 `ABEFCDG`。\n2. **后根遍历**（对应二叉树的**中序遍历**）：\n- 递归遍历每棵子树（后根顺序） → 访问根结点。\n- *示例*：图5.22的树后根序列为 `EFBCGDA`。\n3. **层次遍历**：按层从上到下、从左到右访问结点（同二叉树层次遍历）。\n- **记忆提示**：\n- 树→二叉树转换后，先根遍历=二叉树的先序，后根遍历=二叉树的中序。\n### **2. 森林的遍历**\n- **定义**：对多棵树的集合进行遍历，基于树与二叉树的递归关系。\n- **方法**：\n1. **先序遍历森林**（对应二叉树的**先序遍历**）：\n- 访问第一棵树的根 → 先序遍历其子树森林 → 先序遍历剩余森林。\n- *示例*：图5.23的森林先序序列为 `ABCDEFGHI`。\n2. **中序遍历森林**（对应二叉树的**中序遍历**）：\n- 中序遍历第一棵树的子树森林 → 访问其根 → 中序遍历剩余森林。\n- *示例*：图5.23的森林中序序列为 `BCDAFEHIG`。\n- **关键关系**：\n- 森林→二叉树转换后：\n- 先序遍历森林 ≡ 二叉树的先序遍历。\n- 中序遍历森林 ≡ 二叉树的中序遍历。\n### **3. 对比总结**\n| **结构** | **遍历方法**   | **对应二叉树遍历** |\n|----------|----------------|--------------------|\n| 树       | 先根遍历       | 先序遍历           |\n| 树       | 后根遍历       | 中序遍历           |\n| 森林     | 先序遍历森林   | 先序遍历           |\n| 森林     | 中序遍历森林   | 中序遍历           |\n- **注意**：部分教材称森林的中序遍历为“后序遍历”（因根最后访问），但严蔚敏教材采用“中序”以对应二叉树。\n### **快速记忆**\n- **树**：先根=先序，后根=中序。\n- **森林**：先序/中序直接对应二叉树的先序/中序。"
    },
    {
        "id": "kc0551",
        "title": "哈夫曼树和哈夫曼编码",
        "chapter_id": "05",
        "description": "1.哈夫曼树的定义\n在介绍哈夫曼树之前，先介绍几个相关的概念：\n在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。\n从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。\n树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为\nWPL=\ni=1\n式中，w是第i个叶结点所带的权值，1是该叶结点到根结点的路径长度。\n在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，\n也称最优二叉树。例如，图5.24中的3棵二叉树都有4个叶结点α,b,c,d，分别带权7，5，2,4，\n它们的带权路径长度分别为\n\n184\n2026年数据结构考研复习指导\n(a)\n(b)\n(C)\n图5.24具有不同带权长度的二叉树\n(a)WPL=7×2+5×2+2×2+4×2=36。\n(b）WPL=4×2+7×3+5×3+2×1=46。\n(c)WPL=7×1+5×2+2×3+4×3=35。\n其中，图5.24(c)树的WPL最小。可以验证，它恰好为哈夫曼树。\n2.哈夫曼树的构造\n给定n个权值分别为w,W2,\",W,的结点，构造哈夫曼树的算法描述如下：\n1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。\n命题追踪分析哈夫曼树的路径上权值序列的合法性（2010）\n2）构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且\n将新结点的权值置为左、右子树上根结点的权值之和。公众号：小兔网盘免费分享无水印PDF\n3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n4）重复步骤2）和3），直至F中只剩下一棵树为止。\n命题追踪哈夫曼树的性质（2010、2019）\n从上述构造过程中可以看出哈夫曼树具有如下特点：\n1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。\n2）构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。\n3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。\n例如，权值7.5,2,4的哈夫曼树的构造过程如图5.25所示。\n(a)\n(b)\n(c)\n(P\n图5.25哈夫曼树的构造过程\n3.哈夫曼编码\n在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。\n若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码\n比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较\n长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。\n\n第5章树与二叉树\n185\n命题追踪根据哈夫曼编码对编码序列进行译码（2017）\n若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B\n和C对应的编码0，10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他\n编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码中执行同样的解码操作。\n例如，码串0010110可被唯一地翻译为A，A，B和C。另举反例：若再将字符D的编码设计为11，\n此时11是110的前缀，则上述码串的后三位就无法唯一翻译。\n命题追踪哈夫曼树的构造及相关的分析（2012、2018、2021、2023）\n命题追踪前缀编码的分析及应用（2014、2020）\n可以利用二叉树来设计二进制前缀编码。假设为A，B，C，D四个字符设计前缀编码，可以用\n图5.26所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示\n1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到\n的必为前缀编码。由图5.26得到字符A，B,C，D的前缀编码分别为0,10,110，111。\n编码A(0)\nB(10)\nC(110)\nD(I11)\n图5.26前缀编码示例\n命题追踪哈夫曼编码和定长编码的差异（2022）\n哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。\n首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫\n曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.27所示为一个\n由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。\n各字符编码为\na:0\nb:101\nc:100\nd:111\ne:1101\nf:1100\n图5.27由哈夫曼树构造哈夫曼编码\n这棵哈夫曼树的WPL为\nWPL=1×45+3×（13+12+16)+4×(5+9）=224\n此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则\n得到的二进制编码长度为300位，因此哈夫曼编码共压缩了25%的数据。利用哈夫曼树可以设计\n出总长度最短的二进制前缀编码。\n\n186\n2026年数据结构考研复习指导\n注意\n左分支和右分支究竟是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈\n夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可\n能不同，但WPL必然相同且为最优。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q055001",
            "q055002",
            "q055003",
            "q055004",
            "q055005",
            "q055006",
            "q055007",
            "q055009",
            "q055010",
            "q055011",
            "q055012",
            "q055013",
            "q055014",
            "q055015",
            "q055016",
            "q055017",
            "q055018"
        ],
        "summry": "**哈夫曼树和哈夫曼编码**\n- **定义**\n- **哈夫曼树**（最优二叉树）：含n个**带权叶结点**的二叉树中，**带权路径长度（WPL）**最小的树。\n- **WPL公式**：Σ(叶结点权值 × 路径长度)。\n- **示例**：叶结点权值{7,5,2,4}时，最小WPL=35（路径短→权值高，路径长→权值低）。\n- **构造算法**\n1. 初始化：n个单结点树构成森林F。\n2. 循环合并：每次选F中**权值最小**的两棵树作为左右子树，生成新结点（权值=左右子树权值和），新树加入F。\n3. 终止条件：F只剩一棵树即为哈夫曼树。\n- **特点**：\n- 结点总数=2n-1（新建n-1个内部结点）。\n- 无度为1的结点，权值越小路径越长。\n- **哈夫曼编码**\n- **前缀编码**：无任何编码是其他编码的前缀（解码唯一，如0/10/110）。\n- **构造方法**：\n1. 字符频度作为权值建哈夫曼树。\n2. 左分支标0，右分支标1，根到叶路径即为编码。\n- **优势**：高频字符短编码，**压缩数据**（WPL=编码总长度最优）。\n- **示例**：频度{45,13,12,16,5,9}时，哈夫曼编码比定长编码节省25%。\n- **关键注意**\n- 哈夫曼树不唯一（左右分支01可互换，相同权值结点顺序可变），但**WPL相同且最优**。\n- **快速记忆**：\n- 构造哈夫曼树≈“贪心合并最小权值对”。\n- 编码应用≈“高频字符靠近根，路径短”。"
    },
    {
        "id": "kc0552",
        "title": "并查集",
        "chapter_id": "05",
        "description": "1.并查集的概念\n并查集是一种简单的集合表示，它支持以下3种操作：\n1）Initial（S）：将集合s中的每个元素都初始化为只有一个单元素的子集合。\n2）Union（S,Root1,Root2）：把集合s中的子集合Root2并入子集合Rootl。要求Root1\n和Root2互不相交，否则不执行合并。\n3）Find（S，x）：查找集合S中单元素x所在的子集合，并返回该子集合的根结点。\n2.并查集的存储结构\n树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根\n结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。\n例如，若设有一个全集合为S={0,1,2,3,4,5,6,7,8,9}，初始化时每个元素自成一个单元素\n子集合，每个子集合的数组值为-1，如图5.28所示。\n(a)全集合S初始化时形成一个森林\n01234567\n|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|\n(b)初始化时形成的(森林)双亲表示\n图5.28并查集的初始化\nS={2.3,5}，此时并查集的树形和存储结构如图5.29所示。\n集合的树形表示\n2\n-3|-31211|210|\n(b)集合S、S和S的（森林）双亲表示\n图5.29用树表示并查集\n为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结\n点。因此，SUS可以具有如图5.30所示的表示。\n0101\n图5.30SUS可能的表示方法\n\n第5章树与二叉树\n187\n在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。\n其中SIZE是最大元素的个数。\n3.并查集的基本实现\n并查集的结构定义如下：\n#define SIZE 100\nint\nUFSets[SIZE];\n//集合元素数组（双亲指针数组）\n下面是并查集主要运算的实现。\n（1）并查集的初始化操作\nvoid Initial(int S[]){\nI/s即并查集\nfor（int i=0;i<SIzE;i++)\n//每个自成单元素集合\nS[i]=-1;\n（2）并查集的Find操作\n在并查集s中查找并返回包含元素×的树的根。\nint Find(int S[],int x）{\n//循环寻找×的根\nwhile(S[x]>=0)\nx=S[x];\nreturn x;\n/根的S[]小于0\n判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。\n（3）并查集的Union操作\n求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个\n元素的根，再令一棵子集树的根指向另一棵子集树的根。\nvoid Union(int S[l,int Rootl,int Root2){\nif(Root1==Root2) return;\n//要求Root1与Root2是不同的集合\nS[Root2]=Rootl;\n/将根Root2连接到另一根Root1下面\nFind操作和Union操作的时间复杂度分别为O（d和O（1)，其中d为树的深度。\n4.并查集实现的优化\n在极端情况下，n个元素构成的集合树的深度为n，则Find操作的最坏时间复杂度为O(n)。\n改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成\n员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。\n（1）改进的 Union 操作\nvoid Union(int S[],int Rootl,int Root2){\nif(Rootl==Root2) return;\nif(S[Root2]>S[Root1]){\n//Root2结点数更少\nS[Root1]+=S[Root2];\n//累加集合树的结点总数\nS[Root2]=Root1;\n//小树合并到大树\n1\nelset\n//Root1结点数更少\nS[Root2]+=S[Root1];\n//累加结点总数\nS[Root1]=Root2;\n//小树合并到大树\n采用这种方法构造得到的集合树，其深度不超过log2n」+1。\n随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还\n可进一步对上述Find操作进行优化，当所查元素×不在树的第二层时，在算法中增加一个压缩\n\n188\n2026年数据结构考研复习指导\n路径的功能，即将从根到元素×路径上的所有元素都变成根的孩子。\n（2）改进的Find操作\nint Find(int S[],int x）{\nint root=x;\nwhile(s[root]>=0)\n//循环找到根\nroot=s[root];\nwhile(x!=root){\n/压缩路径\nint t=S[x];\n//t指向x的父结点\nS[x]=root;\n/lx直接挂到根结点下面\nx=t;\nreturn root;\n//返回根结点编号\n通过Find操作的压缩路径优化后，可使集合树的深度不超过O（α（n))，其中α（n)是一个增长\n极其缓慢的函数，对于常见的正整数n，通常α(n)≤4。\n并查集应用的相关举例见本书配套课程。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q055001",
            "q055002",
            "q055003",
            "q055004",
            "q055005",
            "q055006",
            "q055007",
            "q055009",
            "q055010",
            "q055011",
            "q055012",
            "q055013",
            "q055014",
            "q055015",
            "q055016",
            "q055017",
            "q055018"
        ],
        "summry": "**并查集**\n- **定义**：一种支持动态集合合并与查询的树形数据结构，核心操作为**合并（Union）**与**查找（Find）**。\n- **核心操作**：\n- **Initial(S)**：初始化每个元素为独立子集（双亲数组值为`-1`）。\n- **Union(S, Root1, Root2)**：合并两子集（需保证不相交）。\n- **Find(S, x)**：返回元素`x`所在子集的根节点。\n- **存储结构**：\n- 使用**双亲表示数组**，下标代表元素，根节点存储负值（通常为集合大小的相反数）。\n- 示例：`S={0,1,2}`初始化后数组为`[-1, -1, -1]`。\n- **时间复杂度**：\n- 基础实现：`Find`为**O(d)**（d为树深），`Union`为**O(1)**。\n- 优化后：`Find`接近**O(α(n))**（α为反阿克曼函数，极慢增长）。\n- **优化策略**：\n- **按秩合并（Union by Size）**：小树合并到大树，控制树深≤**log₂n**。\n- **路径压缩（Find Path Compression）**：将查询路径上的节点直接挂到根节点，进一步降低树深。\n- **应用场景**：\n- 动态连通性问题（如网络节点连接状态）。\n- 最小生成树（Kruskal算法中的环检测）。\n- **记忆提示**：\n- **\"合并看大小，查找压路径\"**：优化时优先考虑集合大小，查找时压缩路径。\n- **双亲数组三用途**：存父节点、根存负大小、下标即元素。\n**代码片段**：\n```c\n// 路径压缩的Find\nint Find(int S[], int x) {\nif (S[x] < 0) return x;\nreturn S[x] = Find(S, S[x]); // 递归压缩路径\n}\n```"
    },
    {
        "id": "kc0611",
        "title": "图的定义",
        "chapter_id": "06",
        "description": "图G由顶点集V和边集E组成，记为G=（V，E)，其中V(G)表示图G中顶点的有限非空\n集；E(G)表示图G中顶点之间的关系（边）集合。若V={v，V2,，v)，则用IV表示图G中顶\n点的个数，E={（u,v)|ueV，veV}，用lE表示图G中边的条数。\n\n第6章图\n199\n注意\n线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图\n的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。\n下面是图的一些基本概念及术语。\n1.有向图\n若E是有向边（也称弧）的有限集合，则图G为有向图。弧是顶点的有序对，记为<v，w>，\n其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从v到w的弧，也称v邻接到w。\n图6.1(a)所示的有向图G,可表示为\nG=(V, El)\nV={1,2,3}\nE={<1,2>，<2,1>，<2,3>}\n2.无向图\n若E是无向边（简称边）的有限集合，则图G为无向图。边是顶点的无序对，记为（v，w）或\n(w,v)。可以说w和v互为邻接点。边(v,w)依附于w和v，或称边(v,w)和v,w相关联。\n图6.1（b)所示的无向图G2可表示为\nG2 = (V2, E2)\nV2={1,2,3,4}\nE2={(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)}\n(a)有向图G\n(b)无向图G2\n(c)有向完全图G\n图6.1图的示例\n3.简单图、多重图\n一个图G若满足：①不存在重复边；②不存在顶点到自身的边，则称图G为简单图。图6.1\n中G和G2均为简单图。若图G中某两个顶点之间的边数大于1条，又允许顶点通过一条边和\n自身关联，则称图G为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。\n4.顶点的度、入度和出度\n命题追踪无向图中顶点和边的关系（2009、2017）\n在无向图中，顶点v的度是指依附于顶点v的边的条数，记为TD(v)。在图6.1(b)中，每个\n顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。\n在有向图中，顶点的度分为入度和出度，入度是以顶点为终点的有向边的数目，记为\nID(v)：而出度是以顶点v为起点的有向边的数目，记为OD(v)。在图6.1(a)中，顶点2的出度为\n2、入度为1。顶点v的度等于其入度与出度之和，即TD（v)=ID(v)+OD（v)。有向图的全部顶点\n的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。\n\n200\n2026年数据结构考研复习指导\n5.路径、路径长度和回路\n顶点v,到顶点vg之间的一条路径是指顶点序列v,VV\",VV，当然关联的边也可理解\n为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径\n称为回路或环。若一个图有n个顶点，且有大于n-1条边，则此图一定有环。\n6．简单路径、简单回路\n命题追踪路径、回路、简单路径、简单回路的定义（2011）\n在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，\n其余顶点不重复出现的回路称为简单回路。\n7.距离\n从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到\nv根本不存在路径，则记该距离为无穷（∞）。\n8.子图\n设有两个图G=（V,E)和G'=（V，E')，若V是V的子集，且E是E的子集，则称G'是G的\n子图。若有满足V(G')=V(G)的子图G'，则称其为G的生成子图。图6.1中G为G的子图。\n注意\n并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即E的子集中的某些边\n关联的顶点可能不在这个V的子集中。\nl\n9.连通、连通图和连通分量\n命题追踪）图的连通性与边和顶点的关系（2010、2022）\n在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。若图G中任意两个\n顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通\n分量，在图6.2（a)中，图G4有3个连通分量如图6.2（b）所示。假设一个图有n个顶点，若边数小\n于n-1，则此图必是非连通图；思考，若该图是非连通图，则最多可以有多少条边？①\nB\n4\nB\n(a）无向图G\n(b)G的三个连通分量\n图6.2无向图及其连通分量\n10.强连通图、强连通分量\n在有向图中，若有一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点\n①非连通情况下边最多的情况：由n-1个顶点构成一个完全图，此时再加入一个顶点则变成非连通图。\n\n第6章图\n201\n是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连\n个顶点，若该图是强连通图，则最少需要有多少条边？①\n注意\n在无向图中讨论连通性，在有向图中讨论强连通性。\n11.生成树、生成森林\n连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成\n树含有n-1条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成\n树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通\n图中，连通分量的生成树构成了非连通图的生成森林。图G2的一个生成树如图6.4所示。\n图6.3图G的强连通分量\n图6.4图G2的一个生成树\n注意\n区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和\n边；极小连通子图是既要保持子图连通又要使得边数最少的子图。\n12.边的权、网和带权路径长度\n在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上\n带有权值的图称为带权图，也称网。路径上所有边的权值之和，称为该路径的带权路径长度。\n13.完全图（也称简单完全图）\n对于无向图，[E的取值范围为0到n(n-1)/2，有n（n-1)/2条边的无向图称为完全图，在完\n全图中任意两个顶点之间都存在边。对于有向图，E的取值范围为0到n（n-1)，有n（n-1)条弧\n的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1\n中G2为无向完全图，而G为有向完全图。\n14.稠密图、稀疏图\n边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠\n密图常常是相对而言的。一般当图G满足[E<IVlog2IV时，可以将G视为稀疏图。\n15.有向树\n一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            },
            {
                "id": "kc0624",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0643",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q061001",
            "q061002",
            "q061003",
            "q061004",
            "q061005",
            "q061006",
            "q061007",
            "q061008",
            "q061009",
            "q061010",
            "q061011",
            "q061012",
            "q061013"
        ],
        "summry": "**图的定义与基本概念**\n- **定义**：图 \\( G \\) 由**顶点集 \\( V \\)**（非空有限集）和**边集 \\( E \\)**（顶点间关系的集合）组成，记为 \\( G=(V,E) \\)。\n- **注意**：顶点集不可为空（至少一个顶点），边集可为空。\n- **分类**：\n1. **有向图**：边为有序对（弧），记为 \\( \\langle v,w \\rangle \\)，\\( v \\) 为弧尾，\\( w \\) 为弧头。\n2. **无向图**：边为无序对，记为 \\( (v,w) \\)，\\( v \\) 和 \\( w \\) 互为邻接点。\n- **简单图与多重图**：\n- **简单图**：无重复边且无自环（顶点到自身的边）。\n- **多重图**：允许重复边和自环（本书默认讨论简单图）。\n- **顶点的度**：\n- **无向图**：顶点 \\( v \\) 的度 \\( TD(v) \\) 为依附于 \\( v \\) 的边数。全部顶点度之和 \\( =2|E| \\)。\n- **有向图**：\n- 入度 \\( ID(v) \\)：以 \\( v \\) 为终点的边数。\n- 出度 \\( OD(v) \\)：以 \\( v \\) 为起点的边数。\n- 总度 \\( TD(v) = ID(v) + OD(v) \\)。全部顶点入度之和 \\( = \\) 出度之和 \\( = |E| \\)。\n- **路径与回路**：\n- **路径**：顶点序列 \\( v_1, v_2, \\dots, v_k \\)，边数为路径长度。\n- **回路**：首尾顶点相同的路径（环）。\n- **简单路径/回路**：顶点不重复（回路允许首尾重复）。\n- **距离**：两顶点间最短路径的长度，无路径时为 \\( \\infty \\)。\n- **子图与生成子图**：\n- **子图**：\\( G'=(V',E') \\) 满足 \\( V' \\subseteq V \\) 且 \\( E' \\subseteq E \\)。\n- **生成子图**：\\( V'=V \\) 的子图（保留所有顶点）。\n- **连通性**：\n- **无向图**：\n- **连通图**：任意两顶点间有路径。\n- **连通分量**：极大连通子图。\n- **非连通图**：边数 \\( < n-1 \\)（\\( n \\) 为顶点数）。\n- **有向图**：\n- **强连通图**：任意两顶点双向可达。\n- **强连通分量**：极大强连通子图。\n- **生成树与生成森林**：\n- **生成树**：连通图的极小连通子图（\\( n-1 \\) 条边）。\n- **生成森林**：非连通图中各连通分量的生成树的集合。\n- **带权图（网）**：边附有权值，路径的**带权路径长度**为边权之和。\n- **完全图**：\n- **无向完全图**：边数 \\( = \\frac{n(n-1)}{2} \\)（任意两顶点间有边）。\n- **有向完全图**：边数 \\( = n(n-1) \\)（任意两顶点间有双向弧）。\n- **稠密图与稀疏图**：\n- **稀疏图**：边数 \\( |E| < |V|\\log_2|V| \\)（相对概念）。\n- **有向树**：一个顶点入度为 0（根），其余顶点入度为 1。\n**记忆提示**：\n- 无向图度之和 \\( =2|E| \\)，有向图入度 \\( = \\) 出度 \\( = |E| \\)。\n- 连通图边数 \\( \\geq n-1 \\)，强连通图至少需 \\( n \\) 条边（环状结构）。"
    },
    {
        "id": "kc0621",
        "title": "邻接矩阵法",
        "chapter_id": "06",
        "description": "所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中\n边的信息（各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。\n顶点数为n的图G=(V,E)的邻接矩阵A是nxn的，将G的顶点编号为v,V2\",V，则\n[1,\n(v,v,)或<v,v,>是E(G)中的边\nA[]U]=\n10,\n(v,v,)或<v,v,>不是E(G)中的边\n命题追踪图的邻接矩阵存储及相互转换（2011、2015、2018）\n对带权图而言，若顶点v，和v之间有边相连，则邻接矩阵中对应项存放着该边对应的权\n值，若顶点V和V不相连，则通常用0或∞来代表这两个顶点之间不存在边：\nW'ij,\n(v,v,)或<v,v>是E(G)中的边\nA[]U]=\n0或∞，（v,v)或<v,v>不是E(G)中的边\n有向图、无向图和网对应的邻接矩阵示例如图6.5所示。\n②\n011\n0000\n000\n1000\n01100\n(a)有向图G及其邻接矩阵\n(b)无向图G及其邻接矩阵\n(c)网及其邻接矩阵（对角线元素也经常用0表示）\n图6.5有向图、无向图及网的邻接矩阵\n命题追踪（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）\n图的邻接矩阵存储结构定义如下：\n#define MaxVertexNum 100\n//顶点数目的最大值\ntypedef char VertexType;\n/顶点对应的数据类型\ntypedef int EdgeType;\n//边对应的数据类型\ntypedef struct{\nVertexType vex[MaxVertexNum];\n//顶点表\nEdgeType edge[MaxVertexNum] [MaxVertexNum];//邻接矩阵，边表\n\n第6章图\n207\nint vexnum,arcnum;\n//图的当前顶点数和边数\n)MGraph;\n注意\n①在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。\n②当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。\n③无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。\n④邻接矩阵表示法的空间复杂度为O(n²)，其中n为图的顶点数1]。\n命题追踪邻接矩阵的遍历的时间复杂度（2021）\n图的邻接矩阵存储表示法具有以下特点：\n①无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需\n存储上（或下）三角矩阵的元素。\n命题追踪基于邻接矩阵的顶点的度的计算（2013、2021、2023）\n②对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非元素）的个数正好是顶点\ni的度TD(v)。\n③对于有向图，邻接矩阵的第i行非零元素（或非元素）的个数正好是顶点1的出度\nOD（vi)：第i列非零元素（或非o元素）的个数正好是顶点i的入度ID（v)。\n④用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图\n中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n③稠密图（边数较多的图）适合采用邻接矩阵的存储表示。\n命题追踪计算A并说明A\"[小V]的含义（2015）\n③设图G的邻接矩阵为A，A\"的元素A\"[]U]等于由顶点i到顶点j的长度为n的路径的数\n目。该结论了解即可，证明方法可参考离散数学教材。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "extension"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q062001",
            "q062002",
            "q062003",
            "q062004",
            "q062005",
            "q062006",
            "q062007",
            "q062008",
            "q062009",
            "q062010",
            "q062011",
            "q062012",
            "q062014",
            "q062015",
            "q062016",
            "q062017",
            "q062018",
            "q062019"
        ],
        "summry": "**邻接矩阵法**\n- **定义**：用一维数组存储顶点信息，二维数组（邻接矩阵）存储顶点间的邻接关系。\n- **结构表示**：\n```c\ntypedef struct {\nVertexType vex[MaxVertexNum];    // 顶点表\nEdgeType edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵\nint vexnum, arcnum;              // 顶点数和边数\n} MGraph;\n```\n- **矩阵规则**：\n- 无权图：`A[i][j] = 1`（存在边）或 `0`（无边）。\n- 带权图：`A[i][j] = 权值`（存在边）或 `0/∞`（无边）。\n- **特性**：\n- **空间复杂度**：**O(n²)**（n为顶点数）。\n- **无向图**：邻接矩阵对称，可压缩存储上/下三角。\n- **顶点度计算**：\n- 无向图：第i行非零元素个数=顶点i的度。\n- 有向图：第i行非零元素数=出度，第i列非零元素数=入度。\n- **路径统计**：`A^n[i][j]`表示顶点i到j的长度为n的路径数（需离散数学证明）。\n- **优缺点**：\n- **优点**：快速判断两顶点是否邻接（**O(1)**），适合稠密图。\n- **缺点**：边数统计需遍历全矩阵（**O(n²)**），稀疏图空间浪费大。\n- **应用场景**：稠密图存储、需要频繁查询顶点关系的场景（如路径计算）。\n**快速记忆**\n- 无向图对称，有向图非对称；行出度，列入度。\n- 邻接矩阵≈城市直达航班表（1通航，0不通）。"
    },
    {
        "id": "kc0622",
        "title": "邻接表法",
        "chapter_id": "06",
        "description": "当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合\n了顺序存储和链式存储方法，大大减少了这种不必要的浪费。\n所谓邻接表，是指对图G中的每个顶点v建立一个单链表，第i个单链表中的结点表示依\n附于顶点v的边（对于有向图则是以顶点v为尾的弧），这个单链表就称为顶点v的边表（对于\n有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻\n接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。\n顶点域\n边表头指针\n邻接点域\n指针域\ndata\nfirstarc\nadjvex\nnextarc\n顶点表结点\n边表结点\n图6.6顶点表和边表结点结构\n顶点表结点由两个域组成：顶点域（data）存储顶点v的相关信息，边表头指针域\n（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存\n储与头结点顶点v，邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。\n\n208\n2026年数据结构考研复习指导\n命题追踪\n图的邻接表存储的应用（2014）\n无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。\n3\n4/\n(a）无向图G\n(b)无向图G的邻接表的表示\n图6.7无向图邻接表表示法实例\n41/\n(a)有向图G\n(b)有向图G的邻接表的表示\n图6.8有向图邻接表表示法实例\n图的邻接表存储结构定义如下：\n#define MaxVertexNum 100\n//图中顶点数目的最大值\ntypedef struct ArcNode\n//边表结点\nint adjvex;\n//该弧所指向的顶点的位置\nstruct ArcNode *nextarc;\n/指向下一条弧的指针\nI/InfoType info;\n//网的边权值\n)ArcNode;\ntypedef struct VNode\n//顶点表结点\nVertexType data;\n//顶点信息\nArcNode *firstarc;\n//指向第一条依附该顶点的弧的指针\n)VNode,AdjList[MaxVertexNum];\ntypedef struct{\nAdjList vertices;\n//邻接表\nint vexnum,arcnum;\n//图的顶点数和弧数\n)ALGraph;\nI/ALGraph是以邻接表存储的图类型\n图的邻接表存储方法具有以下特点：\n①若G为无向图，则所需的存储空间为O(IV+2|E)：若G为有向图，则所需的存储空间为\nO(IV+|E)。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。\n命题追踪邻接矩阵法和邻接表法的适用性差异（2011）\n②对于稀疏图（边数较少的图），采用邻接表表示将极大地节省存储空间。\n③在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接\n表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定\n给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在\n相应结点对应的边表中查找另一结点，效率较低。\n\n第6章图\n209\n④在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图\n的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点x\n的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为x的边表结点个数。\n③图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是\n任意的，它取决于建立邻接表的算法及边的输入次序。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0344",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            },
            {
                "id": "kc0624",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q062001",
            "q062002",
            "q062003",
            "q062004",
            "q062005",
            "q062006",
            "q062007",
            "q062008",
            "q062009",
            "q062010",
            "q062011",
            "q062012",
            "q062014",
            "q062015",
            "q062016",
            "q062017",
            "q062018",
            "q062019"
        ],
        "summry": "**邻接表法**\n- **定义**：图的链式存储结构，通过**顶点表**（顺序存储）和**边表**（链式存储）表示顶点与边的关系。\n- **结构**：\n- **顶点表结点**：包含顶点数据域（`data`）和指向第一条边的指针域（`firstarc`）。\n- **边表结点**：包含邻接顶点编号（`adjvex`）、指向下一条边的指针域（`nextarc`），可选边权值域（`info`）。\n- **特点**：\n- **空间效率**：无向图存储空间为 **O(|V|+2|E|)**，有向图为 **O(|V|+|E|)**（无向边存储两次）。\n- **稀疏图优化**：相比邻接矩阵，显著节省存储空间。\n- **操作效率**：\n- 查找某顶点所有邻边：**O(1)**（直接访问边表）。\n- 判断两顶点是否邻接：**O(deg(v))**（需遍历边表）。\n- 求无向图顶点度：边表结点数；有向图出度同，入度需遍历全图。\n- **应用**：稀疏图存储、需频繁查询邻接边的场景（如社交网络关系）。\n- **注意**：\n- 邻接表表示**不唯一**，边表结点顺序依赖输入或算法。\n- **对比邻接矩阵**：邻接表适合边少、查邻接多的场景；邻接矩阵适合边密、频繁判邻接的场景。\n**快速记忆**：\n- 顶点表（顺序） + 边表（链式） = 邻接表。\n- 无向图边存两次，有向图边存一次。\n- 查邻边快（直接读边表），判邻接慢（遍历边表）。"
    },
    {
        "id": "kc0623",
        "title": "十字链表",
        "chapter_id": "06",
        "description": "十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧\n结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。\n弧结点\n顶点结点\ntailvexheadvexhlinktlink（info)\ndatafirstinfirstout\n弧结点中有5个域：tailvex域和headvex域分别存放弧尾和弧头这两个顶点的编号；\n头链域hlink指向弧头相同的下一条弧：尾链域tlink指向弧尾相同的下一条弧：info域存\n放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。\n顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以\n该顶点为弧头的第一条弧：firstout域指向以该顶点为弧尾的第一条弧。\n图6.9为有向图的十字链表表示法。\n012\n20\n23\n303132\n(a)\n(b)\n图6.9有向图的十字链表表示（弧结点省略info域）\n注意，顶点结点之间是顺序存储的，弧结点省略了info域。\n在十字链表中，既容易找到V为尾的弧，也容易找到V为头的弧，因而容易求得顶点的出\n度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0344",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0624",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q062001",
            "q062002",
            "q062003",
            "q062004",
            "q062005",
            "q062006",
            "q062007",
            "q062008",
            "q062009",
            "q062010",
            "q062011",
            "q062012",
            "q062014",
            "q062015",
            "q062016",
            "q062017",
            "q062018",
            "q062019"
        ],
        "summry": "**十字链表**\n- **定义**：有向图的链式存储结构，通过**顶点结点**和**弧结点**两类节点表示图的结构。\n- **结点结构**：\n- **弧结点**：\n- `tailvex`/`headvex`：弧尾/弧头的顶点编号。\n- `hlink`：指向**弧头相同**的下一条弧。\n- `tlink`：指向**弧尾相同**的下一条弧。\n- `info`（可选）：弧的附加信息（如权重）。\n- **顶点结点**：\n- `data`：顶点数据（如名称）。\n- `firstin`：以该顶点为**弧头**的第一条弧。\n- `firstout`：以该顶点为**弧尾**的第一条弧。\n- **特性**：\n- 顶点结点**顺序存储**，弧结点通过链表动态连接。\n- 支持快速查询顶点的**出度**（`firstout`链表长度）和**入度**（`firstin`链表长度）。\n- 表示不唯一，但能唯一确定一个图。\n- **优点**：\n- 高效计算入度/出度（**O(1)** 访问头尾链）。\n- 空间利用率高（仅存储必要关联）。\n- **缺点**：\n- 结构复杂，维护成本较高（需同步更新多条链）。\n- **应用**：稀疏有向图的存储（如依赖关系、网络拓扑）。\n- **记忆提示**：\n- “十字”指弧结点同时链接**头相同**和**尾相同**的弧。\n- `firstin`≈入边链头，`firstout`≈出边链头。"
    },
    {
        "id": "kc0624",
        "title": "邻接多重表",
        "chapter_id": "06",
        "description": "邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，\n但求两个顶点之间是否存在边而执行删除边等操作时，需要分别在两个顶点的边表中遍历，效\n率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。\nivex\nilink\njvex\njlink\n(info)\n其中，ivex域和jvex域存放该边依附的两个顶点的编号：ilink域指向依附于顶点ivex的\n下一条边；jlink域指向依附于顶点jvex的下一条边，info域存放该边的相关信息。\n每个顶点也用一个结点表示，它由如下所示的两个域组成。\ndata\nfirstedge\n\n210\n2026年数据结构考研复习指导\n其中，data域存放该顶点的相关信息，firstedge域指向依附于该顶点的第一条边。\n在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶\n点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅\n在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。\n命题追踪图的邻接多重表表示的分析（2024）\n图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。\n0\n3\n图6.10无向图的邻接多重表表示（边结点省略info域）\n图的四种存储方式的总结如表6.1所示。\n表6.1图的四种存储方式的总结\n邻接矩阵\n邻接表\n十字链表\n邻接多重表\n无向图：O（I+2|E)\n空问复杂度\nO(V)\nO(N+[E)\nO(IN+|E)\n有向图：O(IV+[E)\n遍历对应行或列的时间\n找有向图的入度必须遍历\n找相邻边\n很方便\n很方便\n复杂度为O(I)\n整个邻接表\n删除边很方便，删除顶\n无向图中删除边或顶点都\n删除边或顶点\n很方便\n很方便\n点需要大量移动数据\n不方便\n适用于\n稠密图\n稀疏图和其他\n只能存有向图\n只能存无向图\n表示方式\n唯\n不唯\n不唯\n不唯",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0623",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q062001",
            "q062002",
            "q062003",
            "q062004",
            "q062005",
            "q062006",
            "q062007",
            "q062008",
            "q062009",
            "q062010",
            "q062011",
            "q062012",
            "q062014",
            "q062015",
            "q062016",
            "q062017",
            "q062018",
            "q062019"
        ],
        "summry": "**邻接多重表**\n- **定义**：无向图的链式存储结构，通过共享边结点优化边的查询与操作效率。\n- **结构**：\n- **边结点**：`ivex`/`jvex`（顶点编号）、`ilink`（指向顶点`ivex`的下一条边）、`jlink`（指向顶点`jvex`的下一条边）、`info`（边信息）。\n- **顶点结点**：`data`（顶点信息）、`firstedge`（指向第一条依附边）。\n- **特性**：\n- 每条边仅存储一次（邻接表需存两次），通过`ilink`/`jlink`形成双向链表。\n- **空间复杂度**：**O(|V| + |E|)**，优于邻接表的**O(|V| + 2|E|)**（无向图）。\n- **操作效率**：\n- 删除边/顶点：**O(1)**（直接修改链表指针），邻接表需遍历两个顶点边表（**O(deg(v))**）。\n- 查询两顶点间边：需遍历任一顶点的边链表（与邻接表相同）。\n- **应用场景**：\n- 频繁删除边的无向图（如动态网络拓扑）。\n- 需节省空间且避免边重复存储的场景。\n- **对比总结**：\n- **邻接表**：边冗余存储，删除效率低。\n- **邻接矩阵**：空间开销大（**O(|V|²)**），但查询边存在性快（**O(1)**）。\n- **记忆提示**：\n- “多重表≈共享边结点，删除操作快如风”。\n- 图示类比：边结点像“双头螺栓”，同时链接两个顶点的链条。"
    },
    {
        "id": "kc0625",
        "title": "",
        "chapter_id": "06",
        "description": "图的基本操作\n图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会\n有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。\n图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：\n·Adjacent（G,x,Y)：判断图G是否存在边<x,y>或（x,y）。\n·Neighbors（G，x)：列出图G中与结点x邻接的边。\n·InsertVertex(G,x)：在图G中插入顶点x。\n·DeleteVertex（G，x)：从图G中删除顶点x。\n·AddEdge（G，x，y)：若无向边（x，y）或有向边<x，y>不存在，则向图G中添加该边。\n·RemoveEdge(G,x,Y)：若无向边(x,y)或有向边<x,y>存在，则从图G 中删除该边。\n·FirstNeighbor（G，x)：求图G 中顶点x的第一个邻接点，若有则返回顶点号。若x\n没有邻接点或图中不存在x，则返回-1。\n·NextNeighbor（G，x，y)：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶\n点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。\n\n第6章图\n211\n·Get_edge_value(G,x,y)：获取图G 中边(x,y)或<x,y>对应的权值。\n·Set_edge_value(G,x,y,v)：设置图G 中边(x,y)或<x, y>对应的权值为v。\n此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算\n法包括深度优先遍历和广度优先遍历，具体见下一节的内容。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            },
            {
                "id": "kc0624",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0643",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "extension"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q062001",
            "q062002",
            "q062003",
            "q062004",
            "q062005",
            "q062006",
            "q062007",
            "q062008",
            "q062009",
            "q062010",
            "q062011",
            "q062012",
            "q062014",
            "q062015",
            "q062016",
            "q062017",
            "q062018",
            "q062019"
        ],
        "summry": "**图的基本操作**\n- **定义**：独立于存储结构的通用操作集合，具体实现效率受存储方式（邻接矩阵/邻接表）影响。\n- **核心操作**：\n- **Adjacent(G,x,y)**：检测边存在性（**O(1)**邻接矩阵，**O(V)**邻接表）。\n- **Neighbors(G,x)**：获取顶点邻接边（**O(V)**邻接矩阵，**O(deg(x))**邻接表）。\n- **InsertVertex(G,x)**：添加顶点（需扩展存储结构，可能触发动态扩容）。\n- **DeleteVertex(G,x)**：删除顶点及关联边（需遍历行/列或链表，**O(V+E)**最坏）。\n- **AddEdge/RemoveEdge(G,x,y)**：增删边（注意无向图的对称处理）。\n- **FirstNeighbor/NextNeighbor(G,x,y)**：邻接点迭代（邻接表天然支持顺序访问）。\n- **Get/Set_edge_value(G,x,y,v)**：边权操作（矩阵直接定位，链表需查找）。\n- **应用场景**：\n- 邻接矩阵：频繁`Adjacent`操作、稠密图。\n- 邻接表：频繁`Neighbors`遍历、稀疏图。\n- **记忆提示**：\n- 矩阵“查边快找邻慢”，链表“找邻快查边慢”。\n- 删除顶点时需同步清理关联边（避免“悬挂边”）。"
    },
    {
        "id": "kc0631",
        "title": "广度优先搜索",
        "chapter_id": "06",
        "description": "广度优先搜索（Breadth-First-Search，BFS）类似于树的层序遍历。基本思想是：首先访问起\n始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w，W2,，w，然后依次访问\nWi，W2,\"，w,的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访\n问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选\n图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。\nDijkstra单源最短路径算法和Prim最小生成树算法也应用了类似的思想。\n换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和v有路径相通\n且路径长度为1，2，·的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问\n批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层\n的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。\n广度优先搜索算法的伪代码如下：\nbool visited[MAx_VERTEX_NUM];\n/访问标记数组\nvoid BFsTraverse(Graph G)(\n//对图G进行广度优先遍历\nfor（i=0;i<G.vexnum;++i)\nvisited[i]=FALSE;\n/访问标记数组初始化\nInitQueue(Q);\n//初始化辅助队列Q\nfor（i=0;i<G.vexnum;++i)\n1//从0号顶点开始遍历\nif(!visited[i])\n//对每个连通分量调用一次BFS（）\nBFS(G,i);\n//若v未访问过，从v;开始调用BFS（）\n用邻接表实现广度优先搜索的算法如下：\nvoid BFS(ALGraph G,int i){\n\n220\n2026年数据结构考研复习指导\nvisit(i);\n/访问初始顶点1\nvisited[i]=TRUE;\n/对主做已访问标记\nEnQueue(Q,i);\n/顶点i入队\nwhile(!IsEmpty(Q))(\nDeQueue(Q,v);\n/队首顶点v出队\nfor(p=G.vertices[v] .firstarc;pip=p->nextarc)(//检测v的所有邻接点\nw=p->adjvex;\nif(visited[w]==FALSE){\nvisit(w);\n//w为v的尚未访问的邻接点，访问w\nvisited[w]=TRUE;\n//对w做已访问标记\n//顶点w入队\nEnQueue（Q,w);\n用邻接矩阵实现广度优先搜索的算法如下：\nvoid BFS(MGraph G,int i){\nvisit(i);\n/访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nEnQueue(Q,i）;\n//顶点i入队\nwhile(!IsEmpty(Q)){\nDeQueue(Q,v);\n//队首顶点v出队\nfor（w=0;w<G.vexnum;w++)\n/检测v的所有邻接点\nif(visited[w]==FALSE&&G.edge[v][w]==l){\nvisit(w);\n//w为v的尚未访问的邻接点，访问w\nvisited[w]=TRUE;\n//对w做已访问标记\nEnQueue(Q,w);\n//顶点w入队\n辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程\n中，一旦某个顶点v,被访问，就立即置visited[i]为TRUE，防止它被多次访问。\n命题追踪广度优先遍历的过程（2013）\n下面通过实例演示广度优先搜索的过程，给定图G如图6.11所示。假设从顶点a开始访\n问，a先入队。此时队列非空，取出队头元素α，因为b，c与a邻接且未被访问过，于是依次访\n问b，c，并将b，c依次入队。队列非空，取出队头元素b，依次访问与b邻接且未被访问的顶点\nd,e，并将d，e入队（注意：a与b也邻接，但a已置访问标记，所以不再重复访问）。此时队列\n非空，取出队头元素c，访问与c邻接且未被访问的顶点fg，并将fg入队。此时，取出队头元\n素d，但与d邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素e，将h入\n队列……·最终取出队头元素h后，队列为空，从而循环自动跳出。遍历结果为abcdefgh。\n图6.11\n一个无向图G\n\n第6章图\n221\n从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明\n了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。\n1.BFS算法的性能分析\n无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均\n需入队一次，在最坏的情况下，空间复杂度为O(IV)。\n命题追踪基于邻接表存储的BFS的效率（2012）\n遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结\n构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为O(I)，在搜索每个顶\n点的邻接点时，每条边至少访问一次，时间复杂度为O(E)，总的时间复杂度为O(V+E)。采用\n邻接矩阵存储时，查找每个顶点的邻接点所需的时间为O(IV)，总时间复杂度为O(IV)。\n2.BFS算法求解单源最短路径问题\n若图G=（V,E)为非带权图，定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路\n径中最少的边数；若从u到v没有通路，则d(u,v)=∞∞。\n使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度\n优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。\nBFS算法求解单源最短路径问题的算法如下：\nvoid BFS_MIN_Distance(Graph G,int u)(\nlld[i]表示从u到i结点的最短路径\nfor（i=0;i<G.vexnum;++i)\nd[i]=;\n//初始化路径长度\nvisited[u]=TRUE;d[u]=0;\nEnQueue(Q,u);\nwhile(!isEmpty(Q)){\n//BFS算法主过程\nDeQueue(Q,u);\n/队头元素u出队\nfor(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w))\nif(!visited[w]){\n//w为u的尚未访问的邻接顶点\nvisited[w]=TRUE;\n/设已访问标记\nd[w]=d[u]+1;\n/路径长度加1\nEnQueue (Q, w) ;\n/顶点w入队\n3.广度优先生成树\n在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。\n需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，\n但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。\n图6.12图的广度优先生成树\n\n222\n2026年数据结构考研复习指导",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0321",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0322",
                "relation_type": "extension"
            },
            {
                "id": "kc0323",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0335",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0633",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q063001",
            "q063002",
            "q063003",
            "q063004",
            "q063005",
            "q063006",
            "q063007",
            "q063008",
            "q063009",
            "q063011",
            "q063012",
            "q063013",
            "q063014",
            "q063015",
            "q063016",
            "q063017",
            "q063018"
        ],
        "summry": "**广度优先搜索（BFS）**\n- **定义**：从起始顶点出发，按**由近及远**的顺序逐层访问图中所有顶点的遍历算法，类似树的层序遍历。\n- **核心思想**：\n- 使用**队列**辅助实现，保证先访问的顶点其邻接点优先被访问。\n- 通过**访问标记数组** `visited[]` 避免重复访问，时间复杂度为 **O(V+E)**（邻接表）或 **O(V²)**（邻接矩阵）。\n- **特性**：\n- **非递归算法**，依赖队列的先进先出特性。\n- 生成**广度优先生成树**（邻接矩阵存储时唯一）。\n- 可求解**非带权图的单源最短路径**（路径边数最少）。\n- **应用场景**：\n- 社交网络中的“好友推荐”。\n- Dijkstra算法和Prim算法的底层思想。\n- **实现要点**：\n- **邻接表实现**：遍历邻接链表，未访问顶点入队（空间优化）。\n- **邻接矩阵实现**：遍历所有顶点检查边存在性（时间开销较大）。\n- **伪代码关键步骤**：\n1. 初始化队列和 `visited[]` 数组。\n2. 起始顶点入队并标记。\n3. 循环出队顶点，访问其未标记邻接点并入队。\n**快速记忆**：\n- **BFS ≈ 队列 + 分层扩散**，适合最短路径问题。\n- **对比DFS**：BFS无回溯、非递归，DFS需递归/栈。\n**示例流程**：\n1. 顶点 `a` 入队 → 访问 `b, c` 并入队。\n2. `b` 出队 → 访问 `d, e` 并入队。\n3. `c` 出队 → 访问 `f, g` 并入队，直至队列为空。\n**性能分析**：\n- **空间复杂度**：**O(V)**（队列存储顶点）。\n- **时间复杂度**：\n- 邻接表：**O(V+E)**（每条边和顶点各处理一次）。\n- 邻接矩阵：**O(V²)**（需遍历整个矩阵）。"
    },
    {
        "id": "kc0632",
        "title": "深度优先搜索",
        "chapter_id": "06",
        "description": "与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如\n其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。\n它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访\n问的任意一个顶点w，再访问与w邻接且未被访问的任意一个顶点w重复上述过程。当不\n能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该\n点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。\n一般情况下，其递归形式的算法十分简洁，算法过程如下：\nbool visited[MAX_VERTEX_NUM];\n//访问标记数组\nvoid DFsTraverse(Graph G)(\n//对图G进行深度优先遍历\nfor(i=0;i<G.vexnum;i++)\nvisited[i]=FALSE;\n/初始化已访问标记数组\nfor（i=0;i<G.vexnum;i++)\n//本代码中是从v开始遍历\nif(!visited[i])\n//对尚未访问的顶点调用DFS（）\nDFS(G,i);\n用邻接表实现深度优先搜索的算法如下：\nvoid DFS(ALGraph G,int i）{\nvisit(i);\n//访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nfor(p=G.vertices[i].firstarc;p;p=p->nextarc)(/检测i 的所有邻接点\nj=p->adjvex;\nif(visited[j]==FALSE)\nDFS(G,j);\n//j为i的尚未访问的邻接点，递归访问j\n用邻接矩阵实现深度优先搜索的算法如下：\nvoid DFS（MGraph G,int i){\nvisit(i);\n/访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nfor（j=0;j<G.vexnum;j++）{\n/检测i的所有邻接点\nif(visited[j]==FALSE&&G.edge[i][j]==1)\nDFS(G,j);\nj为i的尚未访问的邻接点，递归访问j\n命题追踪深度优先遍历的过程（2015、2016）\n以图6.11的无向图为例，深度优先搜索的过程：首先访问a，并置a访问标记：然后访问与a\n邻接且未被访问的顶点b，置b访问标记：然后访问与b邻接且未被访问的顶点d，置d访问标\n记。此时d已没有未被访问过的邻接点，所以返回上一个访问的顶点b，访问与其邻接且未被访问\n的顶点e，置e访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。\n注意\n图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因\n此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得\n到的DFS序列和BFS序列是不唯一的。\n\n第6章图\n223\n1.DFS算法的性能分析\nDFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为O（IV)。\n遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相\n同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为O(IV)。\n采用邻接表存储时，总的时间复杂度为O(IV+|E)。\n2.深度优先的生成树和生成森林\n与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，\n即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所\n示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。\n图6.13图的深度优先生成森林",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0311",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0312",
                "relation_type": "extension"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0541",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0543",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0633",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q063001",
            "q063002",
            "q063003",
            "q063004",
            "q063005",
            "q063006",
            "q063007",
            "q063008",
            "q063009",
            "q063011",
            "q063012",
            "q063013",
            "q063014",
            "q063015",
            "q063016",
            "q063017",
            "q063018"
        ],
        "summry": "**深度优先搜索（DFS）**\n- **定义**：一种图遍历算法，优先沿当前路径尽可能深地访问未探索节点，直到无法继续时回溯。\n- **特性**：\n- **递归实现**：天然适合递归（隐式使用调用栈），代码简洁（见下方示例）。\n- **非唯一性**：邻接表输入顺序影响遍历序列（邻接矩阵序列唯一）。\n- **空间复杂度**：**O(|V|)**（递归栈深度最坏为顶点数）。\n- **时间复杂度**：邻接矩阵为 **O(|V|²)**，邻接表为 **O(|V|+|E|)**。\n- **算法流程**：\n1. 标记起始节点为已访问。\n2. 递归访问其未访问的邻接节点（邻接表按链表顺序，邻接矩阵按编号顺序）。\n3. 回溯到最近有未访问邻接节点的顶点，重复上述过程。\n- **实现示例**：\n```c\n// 邻接表实现（核心部分）\nvoid DFS(ALGraph G, int i) {\nvisit(i);\nvisited[i] = TRUE;\nfor (p = G.vertices[i].firstarc; p; p = p->nextarc) {\nj = p->adjvex;\nif (!visited[j]) DFS(G, j);\n}\n}\n```\n- **生成树/森林**：\n- 连通图生成一棵**深度优先生成树**，非连通图生成**森林**（多棵树）。\n- 邻接表实现的生成树不唯一（依赖边输入顺序）。\n- **应用场景**：\n- 拓扑排序、连通分量检测、迷宫求解、回溯算法框架（如八皇后问题）。\n- **记忆提示**：\n- **DFS ≈ 递归 + 栈**（非递归实现需显式栈）。\n- 遍历序列类比**树的先序遍历**（根→左→右）。\n- 示例图遍历序列：`a→b→d→e→h→c→f→g`（邻接表输入顺序依赖）。\n- **对比BFS**：\n- DFS优先深度，BFS优先广度；DFS空间效率高（无队列开销），BFS适合最短路径问题。"
    },
    {
        "id": "kc0633",
        "title": "图的遍历与图的连通性",
        "chapter_id": "06",
        "description": "图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意\n一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个\n顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的\n顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路\n径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。\n因此，在BFSTraverse（）或DFSTraverse（）中添加了第二个for循环，再选取初始点\n继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS（G，i）\n或DFS（G，i）的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图\n分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一\n次调用BFS（G，i）或DFS（G，i）不一定能访问到该子图的所有顶点，如图6.14所示。\n图6.14有向图的非强连通分量",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0641",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "extension"
            },
            {
                "id": "kc0644",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q063001",
            "q063002",
            "q063003",
            "q063004",
            "q063005",
            "q063006",
            "q063007",
            "q063008",
            "q063009",
            "q063011",
            "q063012",
            "q063013",
            "q063014",
            "q063015",
            "q063016",
            "q063017",
            "q063018"
        ],
        "summry": "**图的遍历与连通性**\n- **定义**：通过**BFS**或**DFS**遍历判断图的连通性，遍历次数与连通分量直接相关。\n- **无向图**：\n- **连通图**：任意顶点出发一次遍历可访问所有顶点。\n- **非连通图**：遍历仅访问当前连通分量顶点，需多次遍历（次数=连通分量数）。\n- **有向图**：\n- **强连通图**：任意顶点出发可访问所有顶点（存在双向路径）。\n- **非强连通图**：一次遍历可能无法覆盖所有顶点（需区分强连通分量）。\n- **实现要点**：\n- 在`BFSTraverse()`/`DFSTraverse()`中添加外层循环，确保未访问顶点被重新遍历。\n- 无向图调用次数=连通分量数；有向图不适用此规律（因非强连通分量存在）。\n- **记忆提示**：\n- 无向图连通性≈一次遍历全覆盖；有向图需考虑强连通性。\n- 代码逻辑：外层循环检查未访问顶点，内层调用`BFS(G,i)`或`DFS(G,i)`。"
    },
    {
        "id": "kc0641",
        "title": "最小生成树",
        "chapter_id": "06",
        "description": "一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍\n去一条边，则会使生成树变成非连通图：若增加一条边，则会在图中形成一条回路。\n对于一个带权连通无向图G，生成树不同，每棵树的权（树中所有边的权值之和）也可能\n不同。权值之和最小的那棵生成树称为G的最小生成树（Minimum-Spanning-Tree,MST）。\n命题追踪最小生成树的性质（2012、2017）公众号：小兔网盘免费分享无水印PDF\n不难看出，最小生成树具有如下性质：\n1）若图G中存在权值相同的边，则G的最小生成树可能不唯一，即最小生成树的树形不\n唯一。当图G中的各边权值互不相等时，G的最小生成树是唯一的：若无向连通图G的\n边数比顶点数少1，即G本身是一棵树时，则G的最小生成树就是它本身。\n2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。\n3）最小生成树的边数为顶点数减1。\n命题追踪最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）\n注意\n最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所\n示，最小生成树中A到C的路径长度为5，但图中A到C的最短路径长度为4。\n最小生成树\n\n232\n2026年数据结构考研复习指导\n构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设G=(V,E)\n是一个带权连通无向图，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值的边，其\n中ueU，veV-U，则必存在一棵包含边(u,v)的最小生成树。\n基于该性质的最小生成树算法主要有Prim算法和Kruskal算法，它们都基于贪心算法的策\n略。对这两种算法应主要掌握算法的本质含义和基本思想，并能动手模拟算法的实现步骤。\n下面介绍一个通用的最小生成树算法：\nGENERIC MST(G){\nT=NULL;\nwhileT未形成一棵生成树；\ndo找到一条最小代价边（u,v)并且加入T后不会产生回路；\nT=TU（u,v);\n通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。\n1.Prim算法\nPrim（普里姆）算法的执行非常类似于寻找图的最短路径的Diikstra算法（见下一节）。\n命题追踪Prim算法构造最小生成树的实例（2015、2017、2018）\nPrim算法构造最小生成树的过程如图6.15所示。初始时从图中任取一顶点（如顶点1）加\n入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该\n顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶\n点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。\n图6.15Prim算法构造最小生成树的过程\nPrim算法的步骤如下：\n假设G={V,E}是连通图，其最小生成树T=(U,E)，Er是最小生成树中边的集合。\n初始化：向空树T=(U,E)中添加图G=(V,E)的任意一个顶点uo，使U={uo}，Er=。\n循环（重复下列操作直至U=V)：从图G中选择满足{（u,v)ueU,veV-U}且具有最小权值\n的边(u,v)，加入树 T，置U=UU{v}，Er=ErU{(u,v)}。\nPrim算法的简单实现如下：\nvoid Prim(G,T){\nT=O;\n/初始化空树\nU={w};\n//添加任意一个顶点w\n\n第6章图\n233\nwhile((V-U)!=O){\n若树中不含全部顶点\n设(u,v)是使ueU与v∈(V-U)，且权值最小的边;\nT=TU{（u,v）};\n/边归入树\nU=UU{v};\n/顶点归入树\nPrim算法的时间复杂度为O(IV)，不依赖于|E，因此它适用于求解边稠密的图的最小生成\n树。虽然采用其他方法能改进Prim算法的时间复杂度，但增加了实现的复杂性。\n2.Kruskal算法\n与Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合\n适的边来构造最小生成树的方法。\n命题追踪Kruskal算法构造最小生成树的实例（2015、2018、2020）\n通图T={V，，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取\n当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上（使用并查集\n判断这两个顶点是否属于同一棵集合树），则将此边加入T，否则舍弃此边而选择下一条权值\n最小的边。以此类推，直至T中所有顶点都在一个连通分量上。\nKruskal算法的步骤如下：\n假设G=(V,E)是连通图，其最小生成树T=(U,ET)。\n初始化：U=V,Er=O。即每个顶点构成一棵独立的树，T此时是一个仅含IV个顶点的森林。\n循环（重复直至T是一棵树）：按G的边的权值递增顺序依次从E-Er中选择一条边，\n若这条边加入T后不构成回路，则将其加入Er，否则舍弃，直到Er中含有n-1条边。\nV\nV\nV\n图6.16Kruskal算法构造最小生成树的过程\nKruskal算法的简单实现如下：\nvoid Kruskal(V,T)(\nT=V;\n//初始化树T，仅含顶点\nnumS=n;\n//连通分量数\nwhile(numS>1)(\n//若连通分量数大于1\n从E中取出权值最小的边（v，u）；\nif（v和u属于T中不同的连通分量）（\nT=TU((v,u）};\n//将此边加入生成树中\nnumS--;\n//连通分量数减1\n\n234\n2026年数据结构考研复习指导\n根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是\n连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。\n在Kruskal算法中，最坏情况需要对|E条边各扫描一次。通常采用堆（见第7章）来存放边\n的集合，每次选择最小权值的边需要O(logE)的时间：每次使用并查集来快速判断两个顶点是\n否属于一个集合所需的时间为O(α(IV))，α(IV1)的增长极其缓慢，可视为常数。算法的总时间复\n杂度为O(|Elog2|El)，不依赖于IV，因此Kruskal算法适合于边稀疏而J顶点较多的图。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0552",
                "relation_type": "extension"
            },
            {
                "id": "kc0611",
                "relation_type": "extension"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "extension"
            },
            {
                "id": "kc0631",
                "relation_type": "extension"
            },
            {
                "id": "kc0632",
                "relation_type": "extension"
            },
            {
                "id": "kc0633",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q064001",
            "q064002",
            "q064003",
            "q064004",
            "q064005",
            "q064006",
            "q064008",
            "q064009",
            "q064011",
            "q064012",
            "q064014",
            "q064015",
            "q064016",
            "q064017",
            "q064018",
            "q064019",
            "q064020",
            "q064021",
            "q064022",
            "q064023",
            "q064024",
            "q064025",
            "q064026",
            "q064027",
            "q064028",
            "q064029",
            "q064030",
            "q064031",
            "q064032",
            "q064033",
            "q064034",
            "q064035",
            "q064036"
        ],
        "summry": "**最小生成树 (Minimum Spanning Tree, MST)**\n- **定义**：连通无向图**G**的生成树是包含其所有顶点的极小连通子图（边数=顶点数-1）。若**G**是带权图，则**权值和最小**的生成树称为最小生成树。\n- **性质**：\n- **非唯一性**：当存在权值相同的边时，MST可能不唯一；边权均唯一时，MST唯一。\n- **边数与权值和**：边数恒为**|V|-1**，权值和唯一且最小。\n- **非最短路径**：MST不保证任意两顶点间路径的权值和最小（仅保证全局边权和最小）。\n- **构造性质**：若边**(u,v)**是连接顶点集**U**和**V-U**的最小权边，则必存在一棵包含**(u,v)**的MST。\n---\n### **Prim算法**\n- **核心思想**：贪心策略，从任意顶点开始，逐步扩展**U**（已选顶点集），每次选择**U**到**V-U**的最小权边加入MST。\n- **步骤**：\n1. 初始化：选任意顶点加入**U**，**T=∅**。\n2. 循环直到**U=V**：选择**U**与**V-U**间的最小权边**(u,v)**，将**v**加入**U**，边加入**T**。\n- **时间复杂度**：**O(|V|²)**（邻接矩阵）或**O(|E|log|V|)**（优先队列优化）。\n- **适用场景**：边稠密图（|E|≈|V|²）。\n- **记忆提示**：类似Dijkstra，但优先队列按边权排序而非路径长度。\n---\n### **Kruskal算法**\n- **核心思想**：按边权升序选择，避免成环（使用并查集判断连通性）。\n- **步骤**：\n1. 初始化：每个顶点独立成树，**T=∅**。\n2. 循环直到**T**有**|V|-1**条边：选择最小权边**(u,v)**，若**u**和**v**不连通，则加入**T**并合并集合。\n- **时间复杂度**：**O(|E|log|E|)**（排序边+并查集操作）。\n- **适用场景**：边稀疏图（|E|≪|V|²）。\n- **记忆提示**：边排序+并查集防环，类似构建森林逐步合并。\n---\n### **对比总结**\n| **特性**       | **Prim算法**               | **Kruskal算法**            |\n|----------------|---------------------------|---------------------------|\n| **起点**       | 单顶点扩展                | 全局边排序                |\n| **数据结构**   | 优先队列/邻接矩阵         | 并查集+边排序             |\n| **适用图类型** | 稠密图                    | 稀疏图                    |\n| **时间复杂度** | O(|V|²) 或 O(|E|log|V|)   | O(|E|log|E|)              |\n**注**：两种算法均基于贪心策略，保证MST的全局最优性。"
    },
    {
        "id": "kc0642",
        "title": "最短路径",
        "chapter_id": "06",
        "description": "命题追踪）最短路径的分析与举例以及相关的算法（2009、2023）\n6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个\n顶点vo到图中其余任意一个顶点v，的一条路径所经过边上的权值之和，定义为该路径的带权路\n径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。\n求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他\n顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求\n图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解：二是\n求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。\n1.Dijkstra算法求单源最短路径问题\nDijkstra算法设置一个集合S记录已求得的最短路径的顶点，初始时把源点vo放入S，集合\nS每并入一个新顶点V，都要修改源点vo到集合V-S中顶点当前的最短路径长度值（这里可能\n不太好理解？没关系，继续往下看，相信会逐步理解）。\n在构造的过程中还设置了三个辅助数组：\n·final[]：标记各顶点是否已找到最短路径，即是否归入集合S。\n·dist[]：记录从源点vo到其他各顶点当前的最短路径长度，它的初始值为：若从vo到\nv有弧，则dist[i]为弧上的权值；否则置dist[i]为o。\n·path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。在算法结束时，可\n根据其值追溯得到源点v到顶点v的最短路径。\n假设从顶点0出发，即vo=0，集合S最初只包含顶点O，邻接矩阵arcs表示带权有向\n图，arcs[i][j]表示有向边<i>的权值，若不存在有向边<ij>，则arcs[i][j]为o。\nDijkstra算法的步骤如下（不考虑对path[]的操作）：\n1）初始化：集合S初始为{0]，dist[]的初始值dist[i]=arcs[0][i],i=1,2,\"，n-1。\n的一条从vo出发的最短路径的终点，令S=SU{}。\n3）修改从vo出发到集合V-S上任意一个顶点v可达的最短路径长度：若dist[j]+\narcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]。\n4）重复2）～3）操作共n-1次，直到所有的顶点都包含在集合S中。\n步骤3）也就是开头留下的疑问，每当一个顶点加入集合S后，可能需要修改源点vo到集\n合V-S中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为Vo，初\n始时S={vo}，dist[1]=3，dist[2]=7，当将v并入集合S后，dist[2]需要更新为4。\n\n第6章图\n235\n思考：Diikstra算法与Prim算法有何异同之处？\n命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）\n例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如\n表6.2所示。算法执行过程的说明如下。\n每轮得到的最短路径如下：\n第1轮：1→5，路径距离为5\n第2轮：1→5→4，路径距离为7\n第3轮：1→5→2，路径距离为8\n第4轮：1→5→2→3，路径距离为9\n图6.17应用Dijkstra算法图\n表6.2从v到各终点的dist值和最短路径的求解过程\n顶点\n第1轮\n第2轮\n第3轮\n第4轮\n10\n8\n8\n2\nv→V2\nV→V5→V2\nV→Vs→V2\n14\n13\n9\n3\n8\nV1-→V5-V3\nV1-Vs-→V4-→V3\nvI-Vs-→V2-→V3\n7\n4\n8\nV→V5→V4\n5\n5\nV-Vs\n集合S\n(1.5)\n(1,5,4)\n{1,5,4,2}\n{1,5,4,2,3}\n初始化：集合S初始为{v}，V可达v2和V，V不可达v和v4，因此dist[]数组各元素的\n初始值依次设置为dist[2]=10，dist[3]=∞，dist[4]=∞，dist[5]=5。\n第1轮：选出最小值dist[5]，将顶点vs并入集合S，即此时已找到v到v的最短路径。当\nvs加入S后，从v到集合V-S中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]\n数组。vs可达v2，因v→v5→v2的距离8比dist[2]=10小，更新dist[2]=8；vs可达v3，\nvi→V5→>V的距离 14，更新 dist[3]=14；vs可达v4，Vi→Vs→V4的距离 7，更新 dist[4]=7。\n第2轮：选出最小值 dist[4］，将顶点v4并入集合S。继续更新 dist[]数组。v4不可达\nV2，dist[2]不变；v4可达v3，V→v5→V4→v的距离13比dist[3]小，故更新dist[3]=13。\n第3轮：选出最小值dist[2]，将顶点v2并入集合S。继续更新 dist[]数组。v2可达v3,\nv→v5→v2→v的距离9比dist[3]小，更新dist[3]=9。\n第4轮：选出唯一最小值dist[3]，将顶点v并入集合S，此时全部顶点都已包含在S中。\n显然，Dijkstra算法也是基于贪心策略的。\n①Dijkstra算法的流程、操作与Prim算法的都很相似，都基于贪心策略。区别在于，i.目的不同：Dijkstra 算法的目的是构建单\n源点的最短路径树：Prim算法的目的是构建最小生成树。ii.算法思路略有不同：Prim算法从一个点开始，每次选择权值最小\n的边，将其连接到已构建的生成树上，直至所有顶点都已加入：而Dijkstra算法每次找出到源点距离最近且未归入集合的\n点，并把它归入集合，同时以这个点为基础更新从源点到其他所有顶点的距离。ii.适用的图不同：Pri算法只能用于带权无\n向图：Dijkstra算法可用于带权有向图或带权无向图。\n\n236\n2026年数据结构考研复习指导\n使用邻接矩阵表示时，时间复杂度为O(IV²)。使用带权的邻接表表示时，虽然修改dist[]\n的时间可以减少，但因为在dist[]中选择最小分量的时间不变，所以时间复杂度仍为O（(IV)。\n人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所\n有顶点的最短路径一样复杂，时间复杂度也为O(IVF)。\n注意，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与集合S\n（已求得最短路径的顶点集，归入S内的顶点的最短路径不再变更）内某顶点（记为a）以负边\n相连的顶点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于a\n原先确定的最短路径长度，而此时a在Dijkstra算法下是无法更新的。例如，对于图6.18所示的\n带权有向图，利用Dijkstra算法不一定能得到正确的结果。\n(b)\n图6.18边上带有负权值的有向带权图\n2.Floyd算法求各顶点之间最短路径问题\n求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对\n任意两个顶点v≠v，要求求出v与v之间的最短路径和最短路径长度。\nFloyd算法的基本思想是：递推产生一个n阶方阵序列A(-)，,A,.…，A\",…，A\"-I)，其中\nA[U]表示从顶点v到顶点v的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任\n意两个顶点v和v，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它\n们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶\n点k（k=0，1,，n-1）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少\n了，则以此新路径代替原路径。算法描述如下：\n定义一个n阶方阵序列A(-!),A.…,A(\"-1，其中，\nA(-[i]U] = arcs[i]U]\n[u.I 0 = []( +[(-) [)} =[(\n式中，A[]U]是从顶点v,到v、中间顶点是v的最短路径的长度，A*[i]U]是从顶点v,到v、中\n间顶点的序号不大于k的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从v\n到v的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的A\"-\"[ilU]就是v到v的最\n短路径长度，即方阵A\"-1中就保存了任意一对顶点之间的最短路径长度。\n图6.19所示为带权有向图G及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长\n度的过程如表6.3所示。算法执行过程的说明如下。\n10\n(a)有向图G\n(b)G的邻接矩阵\n图6.19带权有向图G及其邻接矩阵\n\n第6章图\n237\n初始化：方阵A(-[i]U]=arcs[i]U]。\n第1轮：将v作为中间顶点，对于所有顶点对{ij}，若有A\"[i]>A[i[0]+A[0]，则将\nA\"[]U]更新为A[][0]+A[0]U]。有A[2][1]>A[2]I0]+A[0][1]=11，更新A[2][1]=11，更\n新后的方阵标记为4\n第2轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A°[0]12]>A\"[0][1]+A[1]12]=\n10，更新A[0][2]=10，更新后的方阵标记为A'。\n第3轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A'[1]I0]>A'[1][2]+A'[2]I0]=9,\n更新 A'[1]I0]=9，更新后的方阵标记为 A。此时 A²中保存的就是任意顶点对的最短路径长度。\n表6.3Floyd算法的执行过程\nA(-1)\nA(O)\nAU)\nA(2)\nVo\nV\nVo\nV\nV2\nV\nV\nV2\n01\nV\nV2\nVo\n0\n6\n13\n0\n6\n13\n0\n6\n1\n0\n6\n10\nV\n10\n0\n4\n10\n0\n4\n10\n0\n4\n0\nV2\n5\n8\n0\n5\n11\n0\n5\n015\n11\n0\nFloyd算法的时间复杂度为O(V)。不过其代码很紧凑，且并不包含其他复杂的数据结构，\n因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。\nFloyd算法允许图中有带负权值的边，但不允许包含总权值为负的回路。Floyd算法同样适\n用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。\n也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源\n点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为O(IV)·V=O(IV)。\nBFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。\n表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结\nBFS算法\nDijkstra算法\nFloyd算法\n用途\n求单源最短路径\n求单源最短路径\n求各顶点之间的最短路径\n无权图\n适用\n适用\n适用\n带权图\n不适用\n适用\n适用\n带负权值的图\n不适用\n不适用\n适用\n带负权回路的图\n不适用\n不适用\n不适用\n时间复杂度\n0()或 O(N+ [E)\n0(V)\noW)",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0334",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0623",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0631",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0633",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q064001",
            "q064002",
            "q064003",
            "q064004",
            "q064005",
            "q064006",
            "q064008",
            "q064009",
            "q064011",
            "q064012",
            "q064014",
            "q064015",
            "q064016",
            "q064017",
            "q064018",
            "q064019",
            "q064020",
            "q064021",
            "q064022",
            "q064023",
            "q064024",
            "q064025",
            "q064026",
            "q064027",
            "q064028",
            "q064029",
            "q064030",
            "q064031",
            "q064032",
            "q064033",
            "q064034",
            "q064035",
            "q064036"
        ],
        "summry": "**最短路径**\n- **定义**：在带权图中，从顶点 `v0` 到顶点 `v` 的路径中，**边权之和最小**的路径称为最短路径（可能不唯一）。\n- **核心性质**：两点间的最短路径的子路径也是最短路径（动态规划基础）。\n---\n### **1. 单源最短路径（Dijkstra算法）**\n- **适用条件**：带权有向图或无向图，**边权非负**。\n- **算法步骤**：\n1. **初始化**：集合 `S` 仅含源点 `v0`；`dist[]` 记录源点到各点的当前最短距离；`final[]` 标记顶点是否已确定最短路径；`path[]` 记录前驱节点。\n2. **贪心选择**：每次从 `V-S` 中选取 `dist` 最小的顶点 `u` 加入 `S`。\n3. **松弛操作**：更新 `u` 的邻接点 `v` 的 `dist[v]`（若 `dist[u] + weight(u,v) < dist[v]`）。\n4. **重复**：直至所有顶点加入 `S`。\n- **时间复杂度**：\n- 邻接矩阵：**O(|V|²)**\n- 优先队列优化（邻接表）：**O(|E| + |V|log|V|)**\n- **关键点**：\n- **不支持负权边**（可能导致已确定的最短路径被错误更新）。\n- **与Prim算法区别**：Dijkstra更新的是到源点的距离，Prim更新的是到生成树的距离。\n---\n### **2. 多源最短路径（Floyd算法）**\n- **适用条件**：带权有向图或无向图，**允许负权边**（但无负权回路）。\n- **算法思想**：动态规划，逐步尝试以每个顶点 `k` 作为中间节点，优化所有顶点对 `(i,j)` 的路径。\n- **递推式**：\n```\nA⁽ᵏ⁾[i][j] = min(A⁽ᵏ⁻¹⁾[i][j], A⁽ᵏ⁻¹⁾[i][k] + A⁽ᵏ⁻¹⁾[k][j])\n```\n- **时间复杂度**：**O(|V|³)**，空间复杂度：**O(|V|²)**。\n- **特点**：\n- 代码简洁，适合稠密图。\n- 可检测负权回路（若某次迭代后 `A[i][i] < 0`）。\n---\n### **对比总结**\n| **算法**   | **用途**               | **适用图类型**       | **时间复杂度**   | **限制**               |\n|------------|------------------------|----------------------|------------------|------------------------|\n| **BFS**    | 无权图单源最短路径     | 无权图               | O(|V| + |E|)     | 仅无权图               |\n| **Dijkstra** | 单源最短路径           | 非负权图             | O(|V|²)          | 边权必须非负           |\n| **Floyd**  | 多源最短路径           | 允许负权（无负回路） | O(|V|³)          | 不能有负权回路         |\n**记忆提示**：\n- **Dijkstra** ≈ 贪心 + 优先队列，**Floyd** ≈ 动态规划 + 三重循环。\n- 负权图优先考虑 **Floyd**，非负权图优先考虑 **Dijkstra**。"
    },
    {
        "id": "kc0643",
        "title": "",
        "chapter_id": "06",
        "description": "有向无环图描述表达式\n有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。\n命题追踪构建表达式的有向无环图（2019）\n有向无环图是描述含有公共子式的表达式的有效工具。例如表达式\n(（p+∞）)((p+∞)+(（p+∞)9）(q+D))\n可以用上一章描述的二叉树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的\n子表达式（c+d)和（c+d)*e，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对\n相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。\n\n238\n2026年数据结构考研复习指导\n图6.20\n二叉树描述表达式\n图6.21\n有向无环图描述表达式\n用有向无环图描述表达式的解题方法举例见本书配套课程。\n注意\n在表达式的有向无环图表示中，不可能出现重复的操作数顶点",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0644",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q064001",
            "q064002",
            "q064003",
            "q064004",
            "q064005",
            "q064006",
            "q064008",
            "q064009",
            "q064011",
            "q064012",
            "q064014",
            "q064015",
            "q064016",
            "q064017",
            "q064018",
            "q064019",
            "q064020",
            "q064021",
            "q064022",
            "q064023",
            "q064024",
            "q064025",
            "q064026",
            "q064027",
            "q064028",
            "q064029",
            "q064030",
            "q064031",
            "q064032",
            "q064033",
            "q064034",
            "q064035",
            "q064036"
        ],
        "summry": "**有向无环图（DAG）描述表达式**\n- **定义**：\n- 有向无环图（DAG）是**不存在任何环**的有向图，用于高效表示具有**公共子式**的表达式。\n- 通过共享相同子表达式节点，避免重复存储（对比二叉树会重复存储相同子式）。\n- **特性**：\n- **顶点**：表示操作数（如变量、常量）或运算符（如`+`, `*`）。\n- **边**：表示运算依赖关系（如运算符顶点指向其操作数顶点）。\n- **关键优势**：消除冗余子式，节省存储空间（如表达式`(a+b)*(a+b)+c`中`(a+b)`仅存储一次）。\n- **应用场景**：\n- 编译器优化（如表达式简化、常量折叠）。\n- 数学公式的紧凑表示。\n- **实现要点**：\n- **唯一性约束**：同一操作数（如变量`p`）在图中仅对应一个顶点，通过哈希表维护操作数到顶点的映射。\n- **构建步骤**：\n1. 递归分解表达式为子表达式。\n2. 为每个子表达式创建或复用已有节点。\n3. 按运算符连接操作数节点（如`+`节点指向左右操作数）。\n- **示例对比**：\n- **二叉树**：重复存储`(p+∞)`和`(p+∞)*e`，空间效率低。\n- **DAG**：共享`(p+∞)`节点，仅存储一次，通过边复用。\n- **记忆提示**：\n- **DAG表达式 ≈ 共享子式**，操作数顶点唯一，边表示计算依赖。\n- 对比二叉树时，DAG的\"折叠\"特性类似代码中的**公共子表达式消除**优化。\n- **复杂度**：\n- 构建时间复杂度：**O(n)**（需遍历表达式并查重）。\n- 空间复杂度：**O(m)**（m为唯一子式数量，远小于原始表达式长度）。"
    },
    {
        "id": "kc0644",
        "title": "拓扑排序",
        "chapter_id": "06",
        "description": "AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边<V，V>表示活动V必\n须先于活动V进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。\n在AOV网中，活动V是活动V的直接前驱，V是V的直接后继，这种前驱和后继关系具有传\n递性，且任何活动V不能以它自己作为自己的前驱或后继。\n称为该图的一个拓扑排序：\n1）每个顶点出现且只出现一次。\n2）若顶点A在序列中排在顶点B的前面，则在图中不存在从B到A的路径。\n或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶\n命题追踪拓扑排序和回路的关系（2011）\n对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：\n①从AOV网中选择一个没有前驱（入度为0）的顶点并输出。\n②从网中删除该顶点和所有以它为起点的有向边。\n③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况\n说明有向图中必然存在环。\n命题追踪拓扑排序的实例（2010、2014、2018、2021）\n图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶\n点和所有以它为起点的有向边，最后得到拓扑排序的结果为{1,2,4,3,5}。\n结点号\n1\n2\n3\n4\n5\n初始入度\n0\n1\n2\n2\n2\n第1轮\n0\n2\n2\n第2轮\n0\n2\n第3轮\n0\nA\n第4轮\n第5轮\n(a)\n图6.22有向无环图的拓扑排序过程\n\n第6章图\n239\n出\n(b)\n图6.22有向无环图的拓扑排序过程（续）\n命题追踪\n（算法题）拓扑排序的实现（2024）\n拓扑排序算法（基于邻接表存储）的实现如下：\nbool TopologicalSort(Graph G) (\nInitStack(S);\n//初始化栈，存储入度为0的顶点\ninti;\nfor（i=0;i<G.vexnum;i++)\nif(indegree[i]==0)\nPush(S,i);\n/将所有入度为0的顶点入栈\nint count=0;\n//计数，记录当前已经输出的顶点数\nwhile(!IsEmpty(S)){\n/栈不空，则存在入度为0的顶点\nPop(S,i）;\n/栈顶元素出栈\nprint[count++]=i;\n//输出顶点\nfor(p=G.vertices[i].firstarc;p;p=p-\n->nextarc){\n/将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S\nv=p->adjvex;\nif(!(--indegree[v]))\nPush(S,v);\n1/入度为0，则入栈\nif(count<G.vexnum)\nreturn\nfalse;\n/排序失败，有向图中有回路\nelse\nreturn\ntrue;\n//拓扑排序成功\n命题追踪\n不同存储方式下的拓扑排序的效率（2016）\n因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时\n间复杂度为O(IV+[E)，采用邻接矩阵存储时拓扑排序的时间复杂度为O(IV)。\n命题追踪DFS实现拓扑排序的思想（2020）\n此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码\n见本节后的习题。对于有向无环图G中的任意结点uuV，它们之间的关系必然是下列三种之一：\n1）若u是v的祖先，则在调用DFS访问u之前，必然已对v进行了DFS访问，即v的DFS\n结束时间先于u的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在\nDFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。\n2）若u是v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。\n3）若u和v没有路径关系，则u和v在拓扑序列的关系任意。\n于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。\n\n240\n2026年数据结构考研复习指导\n对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：\n①从AOV网中选择一个没有后继（出度为O）的顶点并输出。\n②从网中删除该顶点和所有以它为终点的有向边。\n③重复①和②直到当前的AOV网为空。\n用拓扑排序算法处理AOV网时，应注意以下问题：\n1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶\n点所代表的活动开始或继续。\n命题追踪拓扑排序序列的存在性和唯一性分析（2011、2024）\n2）拓扑排序的结果可能不唯一。不少人误认为AOV网的各顶点为线性序列是拓扑序列唯一\n的充要条件，而它其实只是充分非必要条件。拓扑序列是否唯一的判断条件是在每次输\n出顶点时，检测入度为0的顶点是否唯一，若每次都唯一，则说明拓扑序列唯一。\n3）AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新\n编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般\n的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列：反之则不一定成立。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "extension"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0622",
                "relation_type": "extension"
            },
            {
                "id": "kc0623",
                "relation_type": "extension"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0633",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0643",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0645",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q064001",
            "q064002",
            "q064003",
            "q064004",
            "q064005",
            "q064006",
            "q064008",
            "q064009",
            "q064011",
            "q064012",
            "q064014",
            "q064015",
            "q064016",
            "q064017",
            "q064018",
            "q064019",
            "q064020",
            "q064021",
            "q064022",
            "q064023",
            "q064024",
            "q064025",
            "q064026",
            "q064027",
            "q064028",
            "q064029",
            "q064030",
            "q064031",
            "q064032",
            "q064033",
            "q064034",
            "q064035",
            "q064036"
        ],
        "summry": "**拓扑排序**\n- **定义**：对有向无环图（**DAG**）的顶点进行线性排序，使得对图中任意有向边 `<u, v>`，`u` 在排序中始终位于 `v` 前。\n- **AOV网**：顶点表示活动的有向图，边 `<V_i, V_j>` 表示活动 `V_i` 必须先于 `V_j` 完成。\n**核心算法**（基于入度）\n1. **步骤**：\n- 选择入度为 **0** 的顶点输出，并删除其所有出边。\n- 重复直至无顶点剩余（成功）或剩余顶点入度均非 **0**（存在环，失败）。\n2. **实现**（邻接表）：\n- **时间复杂度**：**O(|V| + |E|)**（栈/队列辅助）。\n- **关键代码**：\n```c\nwhile (!IsEmpty(S)) {\nPop(S, u);\nfor (v : u的邻接顶点)\nif (--indegree[v] == 0) Push(S, v);\n}\n```\n**特性与注意**\n- **拓扑序列存在性**：当且仅当图为 **DAG**（无环）。\n- **唯一性**：当且仅当每步选择入度 **0** 的顶点唯一（多解时序列不唯一）。\n- **逆拓扑排序**：按出度 **0** 的顶点删除，思想类似。\n**应用与扩展**\n- **工程调度**：确定活动执行顺序（如课程选修依赖）。\n- **DFS实现**：按顶点 **DFS结束时间降序** 排列即拓扑序列。\n- **存储影响**：邻接矩阵效率 **O(|V|²)**，邻接表更优。\n**快速记忆**\n- **入度零先输出，删边循环判回路**。\n- **DFS结束倒序排，同样可得拓扑序**。"
    },
    {
        "id": "kc0645",
        "title": "关键路径",
        "chapter_id": "06",
        "description": "在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的\n开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。AOE网和AOV网\n值：而AOV网中的边无权值，仅表示顶点之间的前后关系。\nAOE网具有以下两个性质：\n①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；\n②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生，\n在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始：\n也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。\n命题追踪7关键路径的性质（2020）\n在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这\n些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活\n动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的\n路径称为关键路径，而把关键路径上的活动称为关键活动。\n完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这\n是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间\n就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。\n下面给出在寻找关键活动时所用到的几个参量的定义。\n1.事件v的最早发生时间ve(k)\n指从源点v到顶点v的最长路径长度。事件v的最早发生时间决定了所有从v开始的活动\n能够开工的最早时间。可用下面的递推公式来计算：\nve(源点）=0\nvc（k)=Max{ve()+Weight(v,v)}，v为v的任意后继，Weight（v,v)表示<v,v>上的权值\n\n第6章图\n241\n注意\n计算v(）值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：\n①初始时，令ve[1..n]=0。\n②输出一个入度为O的顶点v时，计算它所有直接后继顶点v的最早发生时间，若ve]+Weight(vy\nvk)>ve[k]，则v[A]=veL]+Weight(v,vk)。以此类推，直至输出全部顶点。\n2.事件V的最迟发生时间v(k)\n指在不推迟整个工程完成的前提下，即保证它的后继事件v在其最迟发生时间v(i)能够发生\n时，该事件最迟必须发生的时间。可用下面的递推公式来计算：\nv(汇点)=v(汇点)\nv(（k)=Min{v()-Weight（vk,v）}，v为v的任意前驱\n注意\n计算v（k值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑\n序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：\n①初始时，令v[1….n]=ve[n]。\n②栈顶顶点V出栈，计算其所有直接前驱顶点V的最迟发生时间，若vD]-Weight(vk,y)<v[k]，则\nv[k]=vU]-Weight(vk, v)。以此类推，直至输出全部栈中顶点。\n3.活动a;的最早开始时间e(i)\n指该活动弧的起点所表示的事件的最早发生时间。若边<v,v>表示活动a，则有e(i)=v(k)。\n4.活动a的最迟开始时间1(i)\n指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边<v，v>表示活\n动a，则有I(i)=v/()-Weight(vk,v)。\n5.一个活动a;的最迟开始时间I(i)和其最早开始时间e(i)的差额d(i)=I(i)-e(i)\n指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动a可以拖\n延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工\n程的进度，所以称(i)-e(i)=0即 I(i)=e(i)的活动a,是关键活动。\n命题追踪求关键路径的实例（2019、2022）\n求关键路径的算法步骤如下：\n①从源点出发，令ve（源点）=0，按拓扑有序求其余顶点的最早发生时间ve()。\n②从汇点出发，令v(汇点)=ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间v()。\n③根据各顶点的ve()值求所有弧的最早开始时间e()。\n④根据各顶点的v(）值求所有弧的最迟开始时间1()。\n③求AOE网中所有活动的差额d)，找出所有dO=0的活动构成关键路径。\n图6.23所示为求解关键路径的过程，简单说明如下：\n①求ve(）：初始ve(1）=0，在拓扑排序输出顶点过程中，求得v(2）=3，v(3）=2，v(4）=\nmax{v(2)+2,ve(3)+4}=max{5,6}=6，ve(5)=6，ve（6)=max{v(5)+1,ve（4)+2,ve(3)+\n3}=max{7,8,5}=8。\n\n242\n2026年数据结构考研复习指导\n若这是一道选择题，根据上述求ve()的过程就已经能知道关键路径。\n②求v)：初始v(6)=8，在逆拓扑排序出栈过程中，求得v(5)=7，v(4)=6，v(3)=min{v(4)-4,\nv(6)-3}=min{2,5}=2，v(2)=min{v(5)-3,v(4)-2}=min{4,4}=4，v(1)必然为0而无\n须再求。\n③弧的最早开始时间e(0等于该弧的起点的顶点的v)），结果如下表。\n④弧的最迟开始时间（(i)等于该弧的终点的顶点的v)减去该弧持续的时间，结果如下表。\n③根据 I(i)-e(i)=0的关键活动，得到的关键路径为(v,V3,v4,v6)。\nVe()\n0\nv/()\n4\n2\n1=2\na\na3\ne(i)\n0\n0\n3\n)\n2\n=\n(i)\n1\n0\n4\n5\n6\n(i)-e(i)\n1\n0\n3\n0\n图6.23求解关键路径的过程\n命题追踪缩短工期的相关分析（2013）\n对于关键路径，需要注意以下几点：\n1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加\n快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定\n的程度，该关键活动就可能会变成非关键活动。\n2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键\n活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动\n才能达到缩短工期的目的。\n各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。\n表6.5采用不同存储结构时各种图算法的时间复杂度\nDijkstra\nFloyd\nPrim\nKruskal\nDFS\nBFS\n拓扑排序\n关键路径\n邻接矩阵\nO(n)\nO(n)\nO(n²)\nO(n²)\nO(n²)\nO(n²)\nO(n²)\n邻接表\nO(elogze)\nO(n+e)\nO(n+e)\nO(n+ e)\nO(n+e)",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0611",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0621",
                "relation_type": "extension"
            },
            {
                "id": "kc0622",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0623",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0625",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0642",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0644",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q064001",
            "q064002",
            "q064003",
            "q064004",
            "q064005",
            "q064006",
            "q064008",
            "q064009",
            "q064011",
            "q064012",
            "q064014",
            "q064015",
            "q064016",
            "q064017",
            "q064018",
            "q064019",
            "q064020",
            "q064021",
            "q064022",
            "q064023",
            "q064024",
            "q064025",
            "q064026",
            "q064027",
            "q064028",
            "q064029",
            "q064030",
            "q064031",
            "q064032",
            "q064033",
            "q064034",
            "q064035",
            "q064036"
        ],
        "summry": "**关键路径**\n- **定义**：在**AOE网**（Activity On Edge Network）中，从源点到汇点的最长路径，决定整个工程的最短完成时间。关键路径上的活动称为**关键活动**。\n- **AOE网性质**：\n- 顶点表示事件，边表示活动，边权为活动开销（如时间）。\n- 仅一个入度为0的**源点**（工程开始）和一个出度为0的**汇点**（工程结束）。\n- 事件触发条件：前驱活动全部完成（事件才能发生）；后继活动需事件触发（活动才能开始）。\n- **关键参量**：\n1. **事件最早发生时间 `ve(k)`**：\n- 源点 `ve(源点)=0`，递推公式：`ve(k) = Max{ve(j) + Weight(j, k)}`（`j`为`k`的前驱）。\n- *计算顺序*：拓扑排序基础上从前往后计算。\n2. **事件最迟发生时间 `vl(k)`**：\n- 汇点 `vl(汇点)=ve(汇点)`，递推公式：`vl(k) = Min{vl(j) - Weight(k, j)}`（`j`为`k`的后继）。\n- *计算顺序*：逆拓扑排序（栈实现）从后往前计算。\n3. **活动最早开始时间 `e(i)`**：`e(i) = ve(k)`（活动`i`的起点事件`k`的最早时间）。\n4. **活动最迟开始时间 `l(i)`**：`l(i) = vl(j) - Weight(k, j)`（活动`i`的终点事件`j`的最迟时间减去活动耗时）。\n5. **时间余量 `d(i)`**：`d(i) = l(i) - e(i)`。关键活动满足 `d(i)=0`。\n- **求解步骤**：\n1. 拓扑排序求所有 `ve(k)`。\n2. 逆拓扑排序求所有 `vl(k)`。\n3. 计算所有活动的 `e(i)` 和 `l(i)`。\n4. 筛选 `d(i)=0` 的活动，构成关键路径。\n- **注意事项**：\n- **关键路径不唯一**，缩短工期需同时加速所有关键路径的共有关键活动。\n- 过度缩短关键活动可能使其变为非关键活动。\n- *时间复杂度*：邻接表存储时为 **O(n+e)**（拓扑排序+逆拓扑排序）。\n- **记忆提示**：\n- 关键路径 ≈ 最长路径，决定工程最短时间。\n- `ve` 从前算，`vl` 从后算；`d(i)=0` 是关键。"
    },
    {
        "id": "kc0634",
        "title": "节的综合应用题03。",
        "chapter_id": "06",
        "description": "3）广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像深度优先\n搜索那样有回退的情况。因此，它不是一个递归的过程。\n4）一个给定的图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入先后次序不\n同，则生成的邻接表表示也不同。\n通，使得其权值总和达到最小，且不出现回路。\n6）加速某一关键活动不一定能缩短整个工程的工期，因为AOE网中可能存在多条关键路\n径。可能存在称为桥的一种特殊关键活动，它位于所有的关键路径上，只有它加速才会\n缩短整个工期。\n思维拓展\n【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的\n边，无向图不再连通，描述算法。\n提示\n要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再\n用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的\n方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料\n\n第\n章\n查找\n【考纲内容】\n扫扫\n（一）查找的基本概念\n（二）顺序查找法\n（三）分块查找法\n（四）折半查找法\n口\n（五）树形查找\n视频讲解\n二叉搜索树：平衡二叉树：红黑树\n（六）B树及其基本操作、B+树的基本概念\n（七）散列（Hash）表\n（八）查找算法的分析及应用\n【知识框架】\n基本概念：静态查找、动态查找\n顺序查找\n线性结构\n折半查找\n分块查找\n二叉排序树\n查找\n树形结构\n二叉平衡树\n红黑树\nB树、B+树\n厂性能分析\n散列结构一\n散列表\n冲突处理\n厂查找成功\n效率指标一\n一平均查找长度\n查找失败\n【复习提示】\n本章是考研命题的重点。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找\n长度等。对于二叉排序树、二叉平衡树和红黑树，要了解它们的概念、性质和相关操作等。B树\n和B+树是本章的难点。对于B树，考研大纲要求掌握插入、删除和查找的操作过程；对于B+树，\n仅要求了解其基本概念和性质。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的\n处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。\n7.1查找的基本概念\n1）查找。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分\n为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。",
        "related_points": [
            {
                "id": "kc0721",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0722",
                "relation_type": "extension"
            },
            {
                "id": "kc0723",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            },
            {
                "id": "kc0751",
                "relation_type": "related"
            },
            {
                "id": "kc0752",
                "relation_type": "extension"
            },
            {
                "id": "kc0753",
                "relation_type": "extension"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**广度优先搜索 (BFS)**\n- **定义**：基于队列实现的图/树遍历算法，按层次逐层访问顶点，无回溯过程。\n- **特性**：\n- **非递归**：依赖队列显式管理待访问节点（对比DFS的隐式递归栈）。\n- **分层遍历**：单次扩展一批节点，保证先访问距离起点最近的顶点。\n- **时间复杂度**：邻接表为**O(|V|+|E|)**，邻接矩阵为**O(|V|²)**。\n- **应用**：最短路径（无权图）、连通性检测、社交网络层级分析。\n- **记忆提示**：BFS≈队列，分层扩散；无权图最短路径必用BFS。\n---\n**图的存储表示**\n- **邻接矩阵**：\n- **唯一性**：给定图的邻接矩阵唯一，与边输入顺序无关。\n- **空间**：**O(|V|²)**，适合稠密图。\n- **邻接表**：\n- **非唯一性**：边输入顺序不同可能导致邻接表不同（链表节点插入次序差异）。\n- **空间**：**O(|V|+|E|)**，适合稀疏图。\n---\n**最小生成树 (MST)**\n- **定义**：连通无向图的生成树中，边权值和最小的树，且无回路。\n- **关键性质**：\n- 若图有**|V|**个顶点，MST恰有**|V|-1**条边。\n- 可能不唯一（存在等权边时），但权值和相同。\n- **算法**：Prim（贪心选点）、Kruskal（贪心选边）。\n---\n**关键路径与AOE网**\n- **关键活动**：\n- 位于关键路径上的活动，其延迟将直接延长总工期。\n- **桥活动**：存在于所有关键路径上的活动，加速它才能缩短工期。\n- **注意**：非桥关键活动加速可能无效（因存在其他并行关键路径）。\n---\n**割点检测算法**\n- **定义**：删除割点及关联边后，图不再连通。\n- **朴素方法**：\n1. 移除目标顶点及边。\n2. 使用DFS/BFS检查剩余图的连通性（连通分量是否增加）。\n- **优化算法**：Tarjan算法（基于DFS和low值，时间复杂度**O(|V|+|E|)**）。\n- **记忆提示**：割点≈图中“枢纽”，Tarjan算法用DFS回溯标记。\n---\n**查找章节核心要点**\n- **折半查找**：\n- **条件**：有序顺序表。\n- **判定树**：平衡二叉搜索树，成功/失败ASL均为**O(log n)**。\n- **B树/B+树**：\n- **B树**：多路平衡，节点关键字数∈[⌈m/2⌉-1, m-1]，插入/删除需分裂/合并。\n- **B+树**：非叶节点仅索引，叶节点链表串联，适合范围查询。\n- **散列表**：\n- **冲突处理**：开放定址（线性探测、平方探测）、链地址法。\n- **ASL计算**：依赖装载因子α，成功≈1+α/2，失败≈1+α（链地址法）。"
    },
    {
        "id": "kc0721",
        "title": "顺序查找",
        "chapter_id": "07",
        "description": "顺序查找也称线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增\n来顺序扫描每个元素；对于链表，可通过指针next来依次扫描每个元素。顺序查找通常分为对\n一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。下面分别进行讨论。\n1.一般线性表的顺序查找\n作为一种最直观的查找方法，其基本思想：①从线性表的一端开始，逐个检查关键字是否满\n足给定的条件：②若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表\n中的位置；③若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败\n的信息。下面给出其算法，后面说明了算法中引入的“哨兵”的作用。\ntypedef struct{\n//查找表的数据结构（顺序表）\nElemType *elem;\n/动态数组基址\nint TableLen;\n/表的长度\n)SSTable;\nint Search_Seq(SSTable ST,ElemType key){\nST.elem[0]=key;\n》“哨兵”\nfor(int i=ST.TableLen;ST.elem[i]!=key;--i);//从后往前找\nreturni;/\n/若查找成功，则返回元素下标；若查找失败，则返回0\n上述算法中，将sT.elem[O］称为哨兵，引入它的目的是使得Search_Seq内的循环不必\n判断数组是否会越界。算法从尾部开始查找，若找到 sT.elem[i]==key则返回i值，查找成\n功。否则一定在查找到sT.elem[0］==key时跳出循环，此时返回的是0，查找失败。在程序中\n引入“哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。\n对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需进行n-i+1\n\n第7章查\n找\n271\n次关键字的比较，即C，=n-i+1。查找成功时，顺序查找的平均长度为\n>P(n-i+1)\nj=l\n当每个元素的查找概率相等，即P=1/n时，有\nASL成功\n=1\n查找不成功时，与表中各关键字的比较次数显然是n+1次，即ASL不成功=n+1。\n通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记\n录的查找概率进行排序，使表中记录按查找概率由小至大重新排列。\n综上所述，顺序查找的缺点是当n较大时，平均查找长度较大，效率低：优点是对数据元素\n的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按\n关键字有序，均可应用。同时还需注意，对链表只能进行顺序查找。\n2.有序线性表的顺序查找\n若在查找之前就已知表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返\n回查找失败的信息，从而降低查找失败的平均查找长度。假设表L是按关键字从小到大排列的，\n的关键字小于key，但第i+1个元素的关键字大于key，这时就可返回查找失败的信息，因为第\ni个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。\n命题追踪?有序线性表的顺序查找的应用（2013）\n可以用如图7.1所示的判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性\n表中存在的元素；矩形结点称为失败结点（若有n个结点，则相应地有n+1个查找失败结点），\n它描述的是那些不在表中的数据值的集合。若查找到矩形结点，则说明查找失败。\n查找序列（10.20.30.40.50.60)\n10\n40>10\n查找25\n查找40\n25>10\n(-00,10)\n25>20(10.20)\n25<30(20.30)\n(30.40)\n(40.50)\n(50.60)\n(60.00)\n图7.1有序顺序表上的顺序查找判定树\n在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找\n失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存\n在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的\n平均查找长度在相等查找概率的情形下为\n1+2+..+n+n=n+-n\nASL不成功=\nZq;(l-1)=\nn+1\n2n+1\nj=1\n式中，α,是到达第j个失败结点的概率，在相等查找概率的情形下，它为1/(n+1)；I是第j个失\n败结点所在的层数。当n=6时，ASL不成功=6/2+6/7=3.86，比一般的顺序查找好一些。\n\n272\n2026年数据结构考研复习指导\n注意，有序线性表的顺序查找和后面的折半查找的思想是不一样的，且有序线性表的顺序查\n找中的线性表可以是链式存储结构，而折半查找中的线性表只能是顺序存储结构。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0753",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q072002",
            "q072003",
            "q072004",
            "q072005",
            "q072006",
            "q072007",
            "q072008",
            "q072009",
            "q072010",
            "q072011",
            "q072012",
            "q072014",
            "q072015",
            "q072016",
            "q072017",
            "q072018",
            "q072019",
            "q072020",
            "q072021",
            "q072022",
            "q072023",
            "q072025"
        ],
        "summry": "**顺序查找**\n- **定义**：线性查找方法，适用于顺序表（数组）和链表，通过逐个扫描元素定位目标值。\n- **分类**：\n- **无序线性表**：从头至尾遍历，成功返回位置，失败返回0（使用**哨兵**优化边界判断）。\n- **有序线性表**：查找失败时可提前终止（如第`i`个元素<key但第`i+1`个>key时停止）。\n- **哨兵机制**：\n- 将目标值`key`存入`ST.elem[0]`，循环从尾部开始，避免越界检查。\n- **代码示例**：\n```cpp\nint Search_Seq(SSTable ST, ElemType key) {\nST.elem[0] = key; // 哨兵\nfor (int i = ST.TableLen; ST.elem[i] != key; --i);\nreturn i; // 成功返回下标，失败返回0\n}\n```\n- **性能分析**：\n- **无序表**：\n- 成功平均比较次数（等概率）：**ASL成功 = (n+1)/2**\n- 失败比较次数：**ASL不成功 = n+1**\n- **有序表**：\n- 成功ASL与无序表相同。\n- 失败ASL（等概率）：**ASL不成功 = n/2 + n/(n+1)**（如n=6时为3.86）。\n- **优缺点**：\n- **优点**：实现简单，支持顺序/链式存储，无需数据有序。\n- **缺点**：**O(n)**时间复杂度，数据量大时效率低。\n- **应用提示**：\n- 链式存储仅支持顺序查找。\n- 若已知查找概率，可按概率从高到低排列以优化ASL。\n- **对比折半查找**：\n- 有序顺序查找可提前终止，但时间复杂度仍为**O(n)**；折半查找要求顺序存储且时间复杂度为**O(log n)**。\n- **快速记忆**：\n- 无序表≈全盘扫描；有序表≈失败可提前退出。\n- 哨兵技巧≈免越界检查，循环从后往前。"
    },
    {
        "id": "kc0722",
        "title": "折半查找",
        "chapter_id": "07",
        "description": "折半查找也称二分查找，它仅适用于有序的顺序表。\n命题追踪分析对比给定查找算法与折半查找的效率（2016）\n折半查找的基本思想：①首先将给定值key与表中中间位置的元素比较，若相等，则查找成\n功，返回该元素的存储位置：②若不等，则所需查找的元素只能在中间元素以外的前半部分或后\n半部分（例如，在查找表升序排列时，若key大于中间元素，则所查找的元素只可能在后半部分），\n然后在缩小的范围内继续进行同样的查找。重复上述步骤，直到找到为止，或确定表中没有所需\n要查找的元素，则查找不成功，返回查找失败的信息。算法如下：\nint Binary_Search(SsTable L,ElemType key) (\nint low=0,high=L.TableLen-1,mid;\nwhile(low<=high)(\nmid=（low+high)/2;\n/取中间位置\nif(L.elem[mid]==key)\nreturn mid;\n//查找成功则返回所在位置\nelse if(L.elem[mid]>key)\nhigh=mid-1;\n//从前半部分继续查找\nelse\nlow=mid+1;\n1//从后半部分继续查找\nreturn-1;\n//查找失败，返回-1\n当折半查找算法选取中间结点时，既可以采用向下取整，又可以采用向上取整。但每次查找\n的取整方式必须相同，这部分内容请读者结合本节部分习题来理解。\n命题追踪折半查找的查找路径的判断（2015）\n例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元\n素，指针1ow和high分别指向表的下界和上界，mid则指向表的中间位置l（low+high）/2]。\n下面来说明查找11的过程（查找32的过程请读者自行分析）：\n71013\n16\n192932\n33\n41\n43\nlow\n↑mid\n↑high\n第一次查找时，将中间位置元素与key比较。因为11<29，说明待查元素若存在，则必在范围\n[low，mid-1]内，令high指向位置mid-1，high=mid-1=5，mid=（1+5）/2=3，第二次查找范\n围为[1,5]。\n7101316\n19293233374143\n↑low\n↑mid\n↑high\n第二次查找时，将中间位置元素与key比较。因为11<13，说明待查元素若存在，则必在范围\n[low，mid-1]内，令high指向位置mid-1，high=mid-1=2，mid=（1+2）/2=1，第三次查找范\n围为[1,2]。\n7\n101316\n19293233374143\nlow ↑\n↑high\nmid ↑\n第三次查找时，将中间位置元素与key比较。因为11>7，说明待查元素若存在，则必在范围\n[mid+1,high]内。令1ow=mid+1=2，mid=（2+2）/2=2，第四次查找范围为[2，2]。\n\n第7章查\n找\n273\n7101316\n192\n2932\n33\n37\n4143\nlow↑ thigh\n↑mid\n第四次查找，此时子表只含有一个元素，且10≠11，所以表中不存在待查元素。\n命题追踪分析给定二叉树树形能否构成折半查找判定树（2017）\n折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个\n记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找失败的区\n间。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查\n找失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数：每个结点值均大于\n其左子结点值，且均小于其右子结点值。若有序序列有n个元素，则对应的判定树有n个圆形的\n非叶结点和n+1个方形的叶结点。显然，判定树是一棵平衡二叉树（见",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "extension"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0233",
                "relation_type": "extension"
            },
            {
                "id": "kc0236",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0723",
                "relation_type": "related"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q072002",
            "q072003",
            "q072004",
            "q072005",
            "q072006",
            "q072007",
            "q072008",
            "q072009",
            "q072010",
            "q072011",
            "q072012",
            "q072014",
            "q072015",
            "q072016",
            "q072017",
            "q072018",
            "q072019",
            "q072020",
            "q072021",
            "q072022",
            "q072023",
            "q072025"
        ],
        "summry": "**折半查找（二分查找）**\n- **定义**：在**有序顺序表**中通过不断缩小查找范围定位目标元素的高效搜索算法。\n- **核心思想**：\n1. 将目标值 `key` 与中间元素比较，相等则返回位置。\n2. 若不等，根据大小关系将范围缩小至前半部分（`key < mid`）或后半部分（`key > mid`），重复直至找到或确认不存在。\n- **时间复杂度**：\n- 最优/平均：**O(log n)**（每次范围减半）。\n- 最坏：**O(log n)**（需查至单元素子表）。\n- **实现要点**：\n- 初始化 `low=0`，`high=len-1`。\n- 循环条件 `while(low <= high)` 确保范围有效。\n- 中间位置计算 `mid = (low + high) / 2`（需统一取整方式）。\n- **特性**：\n- **判定树**：平衡二叉树结构，圆形结点为有效元素，方形叶结点表示失败区间。\n- 成功路径长度 = 根到目标结点的层数；失败路径长度 = 根到对应失败结点父结点的层数。\n- **应用场景**：静态有序数据集的快速查找（如数据库索引、内存中的排序数组）。\n- **典型问题提示**：\n- 查找路径分析：模拟 `low/high/mid` 变化过程（如 `{7,10,...,43}` 中找11需4次比较）。\n- 判定树验证：需满足二叉搜索树性质且左右子树高度差≤1（平衡性）。\n- **对比其他查找**：\n- 优于顺序查找（**O(n)**），但要求数据预先有序。\n- 类似分治策略，但仅适用于顺序存储结构（链表不适用）。\n**代码示例**\n```c\nint Binary_Search(SqList L, ElemType key) {\nint low = 0, high = L.length - 1, mid;\nwhile (low <= high) {\nmid = (low + high) / 2;  // 统一向下取整\nif (L.data[mid] == key) return mid;\nelse if (L.data[mid] > key) high = mid - 1;\nelse low = mid + 1;\n}\nreturn -1;  // 查找失败\n}\n```"
    },
    {
        "id": "kc0732",
        "title": "节）。",
        "chapter_id": "07",
        "description": "(13,16)\n(37,41)\n(7.10)\n（10,13)\n(16,19)\n(19.29)\n(33.37)\n图7.2描述折半查找过程的判定树\n命题追踪折半查找的最多比较次数的分析（2010、2023）\n由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率\n查找时，查找成功的平均查找长度为\nn+1\nASL=\n(1x1+2×2+..+h×2-l)=\n-log(n+1)-1≈log2(n+1)-1\n=1\nn\n式中，h是树的高度，并且元素个数为n时树高h=[log2（n+1）l。所以，折半查找的时间复杂度\n为O(log2n)，平均情况下比顺序查找的效率高。\n在图7.2所示的判定树中，在等概率情况下，查找成功（圆形结点）的ASL=（1×1+2×2+3×4+\n4×4)/11=3，查找失败（方形结点）的ASL=（3×4+4×8)/12=11/3。\n命题追踪折半查找的适用场景（2024）\n因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，\n该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。",
        "related_points": [
            {
                "id": "kc0721",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q073002",
            "q073003",
            "q073004",
            "q073005",
            "q073006",
            "q073007",
            "q073011",
            "q073012",
            "q073013",
            "q073014",
            "q073015",
            "q073017",
            "q073019",
            "q073020",
            "q073021",
            "q073022",
            "q073023",
            "q073024",
            "q073025",
            "q073026",
            "q073027",
            "q073028",
            "q073029",
            "q073030",
            "q073031",
            "q073032"
        ],
        "summry": "**折半查找（二分查找）**\n- **定义**：在**有序顺序表**中通过不断缩小查找区间定位目标元素的高效算法，核心为“分治思想”。\n- **特性**：\n- **时间复杂度**：最坏**O(log₂n)**（由判定树高度决定），优于顺序查找的O(n)。\n- **平均查找长度（ASL）**：成功时≈**log₂(n+1)-1**，失败时取决于判定树方形结点分布（如图7.2中ASL=11/3）。\n- **判定树**：\n- 圆形结点为成功结点，方形结点为失败结点。\n- 树高 **h=⌈log₂(n+1)⌉**，最大比较次数≤h。\n- **适用条件**：\n- **顺序存储**结构（支持随机存取）。\n- 元素必须**按关键字有序排列**（否则无法折半）。\n- **典型问题**：\n- **比较次数计算**：直接关联判定树高度（如n=11时最多4次比较）。\n- **链式存储不适用**：因无法直接计算中间位置地址。\n**快速记忆**\n- “折半≈有序数组+随机存取，效率log₂n”\n- “判定树高度决定最大比较次数”"
    },
    {
        "id": "kc0723",
        "title": "分块查找",
        "chapter_id": "07",
        "description": "分块查找也称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又\n适于快速查找。\n分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序\n的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字\n小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有\n\n274\n2026年数据结构考研复习指导\n各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。\n分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折\n半查找索引表：第二步是在块内顺序查找。\n例如，关键码集合为{88,24,72,61,21,6,32,11,8,31,22,83,78,54}，按照关键码值24,54,78,\n88，分为4个块和索引表，如图7.3所示。\n24\n索引表\n查找表24216118223231547261788883\n图7.3分块查找示意图\n分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的\n平均查找长度分别为L和Ls，则分块查找的平均查找长度为\nASL=L+Ls\n将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引\n表中均采用顺序查找，则平均查找长度为\nb+1s+1s²+2s+n\nASL=L+Ls\n2\n2\n2s\n此时，若s=√n，则平均查找长度取最小值√n+1。\n虽然索引表占用了额外的存储空间，索引查找也增加了一定的系统开销，但由于其分块结构，\n使得在块内查找时的范围较小，与顺序查找相比，分块查找的总体效率提升了不少。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0741",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            },
            {
                "id": "kc0753",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q072002",
            "q072003",
            "q072004",
            "q072005",
            "q072006",
            "q072007",
            "q072008",
            "q072009",
            "q072010",
            "q072011",
            "q072012",
            "q072014",
            "q072015",
            "q072016",
            "q072017",
            "q072018",
            "q072019",
            "q072020",
            "q072021",
            "q072022",
            "q072023",
            "q072025"
        ],
        "summry": "**分块查找**\n- **定义**：结合顺序查找与折半查找优点的动态查找方法，通过分块建立索引表加速查询。\n- **特性**：\n- **分块规则**：查找表分为若干子块，块内无序，块间有序（前一块最大值 < 后一块最小值）。\n- **索引表**：记录每块的最大关键字和起始地址，按关键字有序排列。\n- **查找步骤**：\n1. **索引阶段**：确定记录所在块（顺序或折半查找索引表）。\n2. **块内阶段**：在对应块内顺序查找。\n- **时间复杂度**：\n- 索引表顺序查找 + 块内顺序查找：**ASL = (b+1)/2 + (s+1)/2**（b为块数，s为块大小）。\n- 最优块大小：当 **s = √n** 时，**ASL ≈ √n + 1**（效率显著高于纯顺序查找）。\n- **应用场景**：数据动态增减频繁且需兼顾查询效率的场景（如文件系统目录检索）。\n- **优缺点**：\n- **优点**：插入/删除只需调整局部块，无需全局重组；效率介于顺序与折半查找之间。\n- **缺点**：需额外存储索引表，块间有序性维护可能增加开销。\n- **记忆提示**：\n- \"块内乱序，块间有序；索引先行，块内兜底\"。\n- 类比书籍目录：章节（块）标题有序，章节内页码无序。"
    },
    {
        "id": "kc0731",
        "title": "二叉排序树 (BST)",
        "chapter_id": "07",
        "description": "构造一棵二叉排序树的目的并不是排序，而是提高查找、插入和删除关键字的速度，二叉排\n序树这种非线性结构也有利于插入和删除的实现。\n1.二叉排序树的定义\n命题追踪二叉排序树的应用（2013）\n二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：\n1）若左子树非空，则左子树上所有结点的值均小于根结点的值。\n2）若右子树非空，则右子树上所有结点的值均大于根结点的值。\n\n284\n2026年数据结构考研复习指导\n3）左、右子树也分别是一棵二叉排序树。\n命题追踪二叉排序树中结点值之间的关系（2015、2018、2024）\n根据二叉排序树的定义，左子树结点值<根结点值<右子树结点值，因此对二叉排序树\n进行中序遍历，可以得到一个递增的有序序列。例如，图7.4所示二叉排序树的中序遍历序列\n为123468。\n图7.4\n一棵二叉排序树\n2.二叉排序树的查找\n二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，\n先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，若小于根结点的关键字，则\n在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。\n二叉排序树的非递归查找算法：\nBSTNode *BST_Search(BiTree T,ElemType key){\nwhile(T!=NULL&&key!=T->data){\n/若树空或等于根结点值，则结束循环\nif(key<T->data) T=T->lchild;\n//小于，则在左子树上查找\nelse T=T->rchild;\n//大于，则在右子树上查找\nreturn T;\n例如，在图7.4中查找值为4的结点。首先4与根结点6比较。因为4小于6，所以在根结\n点6的左子树中继续查找。因为4大于2，所以在结点2的右子树中查找，查找成功。\n同样，二叉排序树的查找也可用递归算法实现，递归算法比较简单，但执行效率较低。具体\n的代码实现，留给读者思考。\n3.二叉排序树的插入\n二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，\n当树中不存在关键字值等于给定值的结点时再进行插入的。\n插入结点的过程如下：若原二叉排序树为空，则直接插入：否则，若关键字k小于根结点值，\n则插入到左子树，若关键字k大于根结点值，则插入到右子树。新插入的结点一定是一个叶结点，\n且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。如图7.5所示在一棵二叉\n排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。\n20\n28\n28\n(a)插入28\n(b)插入58\n图7.5向二叉排序树中插入结点\n\n第7章查\n找\n285\n二叉排序树插入操作的算法描述如下：\nint BST_Insert(BiTree &T,KeyType k){\nif（T==NULL）{\n//原树为空，新插入的记录为根结点\nT=(BiTree)malloc(sizeof(BsTNode));\nT->data=k;\nT->lchild=T->rchild=NULL;\nreturn1;\n//返回1，插入成功\nelse if(k==T->data)\n//树中存在相同关键字的结点，插入失败\nreturn0;\nelse if(k<T->data)\n/插入T的左子树\nreturn BsT_Insert(T->lchild,k);\nelse\n//插入T的右子树\nreturn\nBST_Insert(T->rchild,k);\n4.二叉排序树的构造\n命题追踪构造二叉排序树的过程（2020）\n从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设插入的关键字序\n列为{45,24,53,45,12.24}，则生成的二叉排序树如图7.6所示。\n45\n(a）空树\n(b）插入45\n（c）插入24\n（d）插入53\n(e）插入12\n图7.6二叉排序树的构造过程\n构造二叉排序树的算法描述如下：\nvoid Creat_BsT(BiTree &T,KeyType str[],int n){\nT=NULL;\n//初始时T为空树\nint i=0;\nwhile(i<n){\n//依次将每个关键字插入二叉排序树\nBST_Insert(T,str[i]);\ni++;\n5.二叉排序树的删除\n在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被\n删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时\n确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：\n①若被删除结点：是叶结点，则直接删除，不会破坏二叉排序树的性质。\n②若结点：只有一棵左子树或右子树，则让=的子树成为=父结点的子树，替代=的位置。\n③若结点=有左、右两棵子树，则令=的直接后继（或直接前驱）替代=，然后从二叉排序\n树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。\n图7.7显示了在3种情况下分别删除结点45，78，78的过程。\n\n286\n2026年数据结构考研复习指导\n右子树空，用左子女填补\n23\na\n删除78\n左子树空，用右子女填补\n23\n88\n23\n(b)\n53\n53\n删除78\n78\n左、有子树均不空，\n在右子树上找中序第\n个子女填补\n转换为删除81\n23\n88\n(c)\n图7.73种情况下的删除过程\n命题追踪二叉排序树中删除并插入某结点的分析（2013）\n思考：若在二叉排序树中删除并插入某结点，得到的二叉排序树是否和原来的相同？\n6．二叉排序树的查找效率分析\n二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差\n的绝对值不超过1（平衡二叉树，下一节)，它的平均查找长度和O(log2n)成正比。在最坏情\n况下，即构造二叉排序树的输入序列是有序的，则会形成一个只有右孩子的单支树，此时二叉排\n序树的性能显著变坏，树的高度为n，则其平均查找长度为（n+1)/2，如图7.8(b)所示。\nQ12\nQ28\nQ37\nQ40\nQ45\n053\n055\nQ60\n070\n(a)\n(b)\n图7.8相同关键字组成的不同二叉排序树\n\n第7章查找\n287\n在等概率情况下，图7.8(a)查找成功的平均查找长度为\nASLa=(1 + 2×2+ 3x4 + 4×3)/10 = 2.9\n而图7.8(b)查找成功的平均查找长度为\nASL,=(1+2+3+4+5+6+7+8+9+10)10=5.5\n从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和\n二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入\n顺序不同可能生成不同的二叉排序树，如图7.8所示。\n就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，\n平均执行时间为O(log2)。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的\n代价是O（n)。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查\n找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "extension"
            },
            {
                "id": "kc0532",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0732",
                "relation_type": "extension"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q073002",
            "q073003",
            "q073004",
            "q073005",
            "q073006",
            "q073007",
            "q073011",
            "q073012",
            "q073013",
            "q073014",
            "q073015",
            "q073017",
            "q073019",
            "q073020",
            "q073021",
            "q073022",
            "q073023",
            "q073024",
            "q073025",
            "q073026",
            "q073027",
            "q073028",
            "q073029",
            "q073030",
            "q073031",
            "q073032"
        ],
        "summry": "**二叉排序树 (BST)**\n- **定义**：一种非线性数据结构，满足：\n- 左子树非空时，所有结点值 **<** 根结点值。\n- 右子树非空时，所有结点值 **>** 根结点值。\n- 左、右子树也是二叉排序树。\n- **关键性质**：中序遍历结果为递增序列（如 `1→2→3→4→6→8`）。\n- **核心操作**：\n- **查找**：\n- 从根开始比较，若 `key == 根值` 则成功；若 `key < 根值` 查左子树，否则查右子树。\n- **时间复杂度**：平均 **O(log n)**，最坏 **O(n)**（退化为单支树）。\n- **非递归实现**：\n```c\nBSTNode *BST_Search(BiTree T, ElemType key) {\nwhile (T != NULL && key != T->data) {\nif (key < T->data) T = T->lchild;\nelse T = T->rchild;\n}\nreturn T;\n}\n```\n- **插入**：\n- 若树空则直接插入为根；否则递归比较大小，插入到对应子树。\n- **特点**：新结点必为叶结点。\n- **代码片段**：\n```c\nint BST_Insert(BiTree &T, KeyType k) {\nif (T == NULL) { /* 创建新结点 */ }\nelse if (k < T->data) return BST_Insert(T->lchild, k);\nelse return BST_Insert(T->rchild, k);\n}\n```\n- **删除**：分三种情况处理：\n1. **叶结点**：直接删除。\n2. **单子树**：用子结点替代被删结点。\n3. **双子树**：用直接后继（或前驱）替代，并递归删除后继结点。\n- **构造过程**：从空树开始，依次插入关键字序列（如 `{45,24,53,12}`）。\n- **效率分析**：\n- **平衡时**：树高接近 **log₂n**，查找效率 **O(log n)**。\n- **最坏情况**（输入有序）：退化为链表，查找效率 **O(n)**。\n- **动态优势**：插入/删除仅需修改指针（**O(log n)**），优于有序顺序表的 **O(n)** 移动成本。\n- **应用场景**：\n- 动态查找表（频繁插入/删除）。\n- 维护有序数据且需高效查找（如数据库索引）。\n- **记忆提示**：\n- **BST ≈ 中序有序**\n- **查找路径**：大右小左，递归到底。\n- **删除双子树**：后继替代，递归清理。"
    },
    {
        "id": "kc0732",
        "title": "平衡二叉树",
        "chapter_id": "07",
        "description": "1.平衡二叉树的定义\n为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保\n证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced\nBinaryTree），也称AVL树。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡\n二叉树结点的平衡因子的值只可能是-1、0或1。\n命题追踪平衡二叉树的定义（2009）\n因此，平衡二叉树可定义为或是一棵空树，或是具有下列性质的二叉树：它的左子树和右子\n图7.9（b）所示是不平衡的二叉树。结点中的数字为该结点的平衡因子。\n(a)平衡二义树\n(b)不平衡的二义树\n图7.9平衡二叉树和不平衡的二叉树\n2.平衡二叉树的插入\n二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首\n先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入\n路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉\n排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。\n命题追踪平衡二叉树中插入操作的特点（2015）\n注意，每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的\n绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。\n\n288\n2026年数据结构考研复习指导\n插入51\n对最小不平衡树\n执行LR旋转\n插入27、16、75、38\n之后的二叉排序树\n图7.10最小不平衡子树示意\n命题追踪）平衡二叉树的插入及调整操作的实例（2010、2019、2021）\n平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径\n上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：\n1）LL平衡旋转（右单旋转）。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，\nA的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将\nA的左孩子B向右上旋转代替A成为根结点，将A向右下旋转成为B的右孩子，而B的\n原右子树则作为4的左子树。如图7.11所示，结点旁的数值代表结点的平衡因子，而用\n方块表示相应结点的子树，下方数值代表该子树的高度。\nA\nBL.\nBR\n(a)插入结点前\n(b)插入结点导致不平衡\n(c)LL旋转（右单旋转）\n图7.11LL平衡旋转\n2）RR平衡旋转（左单旋转）。由于在结点A的右孩子（R）的右子树（R）上插入了新结点，\nA的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。\n将A的右孩子B向左上旋转代替A成为根结点，将A向左下旋转成为B的左孩子，而B\n的原左子树则作为4的右子树，如图7.12所示。\nBL\n(a）插入结点前\n(b)插入结点导致不平衡\n(c)RR旋转（左单旋转）\n图7.12RR平衡旋转\n3）LR平衡旋转（先左后右双旋转）。由于在结点A的左孩子（L）的右子树（R）上插入新\n结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，\n先左旋转后右旋转。先将A的左孩子B的右子树的根结点C向左上旋转提升到B的位置，\n\n第7章查\n找\n289\n然后把C向右上旋转提升到A的位置，如图7.13所示。\n(a)插入结点前\n(b)插入结点导致不平衡\n（c)LR旋转（双旋转）\n图7.13LR平衡旋转\n4）RL平衡旋转（先右后左双旋转）。由于在结点A的右孩子（R）的左子树（L）上插入新\n结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操\n作，先右旋转后左旋转。先将A的右孩子B的左子树的根结点C向右上旋转提升到B的\n位置，然后把C向左上旋转提升到A的位置，如图7.14所示。\n(a)插入结点前\n(b)插入结点导致不平衡\n(c)RL旋转（双旋转)\n图7.14RL平衡旋转\n注意\n公众号：小兔网盘免费分享无水印PDF\nLR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树不影响旋转过程，而图7.13\n和图7.14中以插入C的左子树中为例。\n命题追踪构造平衡二叉树的过程（2013）\n以关键字序列{15,3，7,10，9，8构造一棵平衡二叉树的过程为例，图7.15（d)插入7后导致不\n平衡，最小不平衡子树的根为15，插入位置为其左孩子的右子树，所以执行LR旋转，先左后右\n双旋转，调整后的结果如图7.15(e)所示。图7.15(g)插入9后导致不平衡，最小不平衡子树的根为\n15，插入位置为其左孩子的左子树，所以执行LL旋转，右单旋转，调整后的结果如图7.15(h)所\n示。图7.15（1插入8后导致不平衡，最小不平衡子树的根为7，插入位置为其右孩子的左子树，\n所以执行RL旋转，先右后左双旋转，调整后的结果如图7.15(所示。\n3.平衡二叉树的删除\n与平衡二叉树的插入操作类似，以删除结点v为例来说明平衡二叉树删除操作的步骤：\n1）用二叉排序树的方法对结点w执行删除操作。\n2）若导致了不平衡，则从结点w开始向上回溯，找到第一个不平衡的结点=（最小不平衡子\n树）：y为结点=的高度最高的孩子；x是结点y的高度最高的孩子。\n\n290\n2026年数据结构考研复习指导\n15\n15\n10\n(a)空树\n(b)插入15\n(c)插入3\n(d)插入7\n(e)LR旋转\n(f)插入10\nG\nG\n9\n10\n(g)插入9\n(h)LL旋转\n(i)插入8\n(i)RL旋转\n图7.15平衡二叉树的生成过程\n3）然后对以=为根的子树进行平衡调整，其中x、y和=可能的位置有4种情况：\n·y是=的左孩子，x是y的左孩子（LL，右单旋转);\n·y是=的左孩子，x是y的右孩子（LR，先左后右双旋转);\n·y是=的右孩子，x是y的右孩子（RR，左单旋转);\n·y是=的右孩子，x是y的左孩子（RL，先右后左双旋转)。\n这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以：为根的子树\n进行平衡调整；而删除操作就不一样，先对以=为根的子树进行平衡调整，若调整后子树的高度\n减1，则可能需要对：的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。\n以删除图7.16(a)的结点32为例，由于32为叶结点，直接删除即可，向上回溯找到第一个不\nRL情况，先右后左双旋转，调整后的结果如图7.16(c)所示。\n右旋\n左旋\n(a)删除32前\n(b)右旋\n(c）左旋\n图7.16平衡二叉树的删除\n4.平衡二叉树的查找\n命题追踪）指定条件下平衡二叉树的结点数的分析（2012）\n在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，进行关键字的\n比较次数不超过树的深度。假设以n表示深度为h的平衡二叉树中含有的最少结点数。显然，有\n\n第7章查\n找\n291\nno=0,n=1,n2=2，并且有n=nh-2+n-i+1，如图7.17所示，依次推出n=4,n4=7,ns=12,·\n含有n个结点的平衡二叉树的最大深度为O(log2n)，因此平均查找效率为O(log2n)。\n图7.17结点个数n最少的平衡二叉树\n注意\n该结论可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数（或树的最大高度）。如在含\n有12个结点的平衡二叉树中查找某个结点的最多比较次数？\n深度为h的平衡二叉树中含有的最多结点数显然是满二叉树的情况。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0531",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0733",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q073002",
            "q073003",
            "q073004",
            "q073005",
            "q073006",
            "q073007",
            "q073011",
            "q073012",
            "q073013",
            "q073014",
            "q073015",
            "q073017",
            "q073019",
            "q073020",
            "q073021",
            "q073022",
            "q073023",
            "q073024",
            "q073025",
            "q073026",
            "q073027",
            "q073028",
            "q073029",
            "q073030",
            "q073031",
            "q073032"
        ],
        "summry": "**平衡二叉树（AVL树）**\n- **定义**：一种自平衡的二叉排序树，保证任意结点的左右子树高度差（**平衡因子**）绝对值不超过1。空树或满足以下性质：\n- 平衡因子 ∈ {-1, 0, 1}\n- 插入/删除后通过旋转调整恢复平衡\n- **核心特性**：\n- **高度平衡**：树高始终为 **O(log n)**，确保查找、插入、删除操作高效。\n- **最小不平衡子树**：调整时仅处理插入/删除路径上最近的失衡结点及其子树。\n- **插入操作**：\n1. 按二叉排序树规则插入新结点。\n2. 向上回溯检查平衡因子，若失衡则调整：\n- **LL型**（右单旋）：失衡结点的左孩子的左子树插入导致。\n- **RR型**（左单旋）：失衡结点的右孩子的右子树插入导致。\n- **LR型**（先左后右双旋）：失衡结点的左孩子的右子树插入导致。\n- **RL型**（先右后左双旋）：失衡结点的右孩子的左子树插入导致。\n- **删除操作**：\n1. 按二叉排序树规则删除结点。\n2. 向上回溯调整失衡结点（同插入的4种情况），可能需多次调整至根结点。\n- **查找性能**：\n- **最坏情况**：树高 **⌊log₂n⌋ + 1**，比较次数不超过树高。\n- **最少结点公式**：nₕ = nₕ₋₁ + nₕ₋₂ + 1（类似斐波那契数列）。\n- **应用场景**：需频繁查找、插入/删除且要求稳定时间复杂度的场景，如数据库索引、内存中的有序映射。\n**快速记忆**\n- **旋转口诀**：LL→右旋，RR→左旋，LR→先左后右，RL→先右后左。\n- **平衡因子**：|左高 - 右高| ≤ 1，失衡时绝对值=2。\n- **调整对象**：总是最小不平衡子树（离插入点最近的失衡结点）。"
    },
    {
        "id": "kc0733",
        "title": "红黑树",
        "chapter_id": "07",
        "description": "1.红黑树的定义\n为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构，\n代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。\n棵红黑树是满足如下红黑性质的二叉排序树：\n①每个结点或是红色，或是黑色的。\n②根结点是黑色的。\n③叶结点（虚构的外部结点、NULL结点）都是黑色的。\n④不存在两个相邻的红结点（红结点的父结点和孩子结点均是黑色的）。\n③对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。\n与折半查找树和B树类似，为了便于对红黑树的实现和理解，引入了n+1个外部叶结点，\n以保证红黑树中每个结点（内部结点）的左、右孩子均非空。图7.18所示是一棵红黑树。\n空结点\n黑结点\n红结点\n图7.18\n一棵红黑树\n从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结\n点的黑高（记为bh），黑高的概念是由性质5确定的。根结点的黑高称为红黑树的黑高。\n结论1：从根到叶结点的最长路径不大于最短路径的2倍。\n由性质，当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。\n\n292\n2026年数据结构考研复习指导\n黑结点的数量相同。图7.18中的6-2和6-15-18-20就是这样的两条路径。\n结论2：有n个内部结点的红黑树的高度h≤2log2（n+1)。\n证明：由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是\n黑结点，因此，根的黑高至少为h/2，于是有n≥2h㎡2-1，即可求得结论。\n由结论2也可推出，黑高为h的红黑树的内部结点数最少是2\"-1，最多是22\"-1。\n可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任意一个结点左右子\n树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，若插入\n和删除操作比较少，查找操作比较多，则采用AVL树比较合适，否则采用红黑树更合适。但由\n于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C++中的\nmap和set（Java中的TreeMap和TreeSet）就是用红黑树实现的。\n2.红黑树的插入\n红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新\n结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。\n结论3：新插入红黑树中的结点初始着为红色。\n假设新插入的结点初始着为黑色，则这个结点所在的路径比其他路径多出一个黑结点（几乎\n每次插入都破坏性质），调整起来也比较麻烦。若插入的结点是红色的，则此时所有路径上的\n黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。\n设结点：为新插入的结点。插入过程描述如下：\n1)用二叉查找树插入法插入，并将结点：着为红色。若结点z的父结点是黑色的，无须做任\n何调整，此时就是一棵标准的红黑树，结束。\n2）若结点=是根结点，则将=着为黑色（树的黑高增1），结束。\n3）若结点=不是根结点，且=的父结点=.p是红色的，则分为下面三种情况，区别在于=的\n叔结点y的颜色不同，因=.p是红色的，插入前的树是合法的，根据性质②和④，爷结点\n=.p.p 必然存在且为黑色。性质④只在=和=.p之间被破坏了。\n情况1：=的叔结点y是黑色的，且=是一个右孩子。\n情况2：=的叔结点y是黑色的，且=是一个左孩子。\n每棵子树T、T、T和T4都有一个黑色根结点，且具有相同的黑高。\n情况1（LR，先左旋，再右旋），即=是其爷结点的左孩子的右孩子。先做一次左旋将此情\n形转变为情况2（变为情况2后再做一次右旋），左旋后=和父结点=.p交换位置。因为=和=.p\n都是红色的，所以左旋操作对结点的黑高和性质5都无影响。\n情况2（LL，右单旋），即=是其爷结点的左孩子的左孩子。做一次右旋，并交换=的原父\n结点和原爷结点的颜色，就可以保持性质，也不会改变树的黑高。这样，红黑树中也不再有连\n续两个红结点，结束。情况1和情况2的调整方式如图7.19所示。\n注：p表示父结点；p.p表示爷结点\n情况1\n情况2\n红结点\n黑结点\n图7.19情况1和情况2的调整方式\n\n第7章查\n找\n293\n若父结点=.p是爷结点=.p.p的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和\nRR（左单旋），这里不再赘述。红黑树的调整方法和AVL树的调整方法有异曲同工之妙。\n情况3：=的叔结点y是红色的。\n情况3（=是左孩子或右孩子无影响），=的父结点=.p和叔结点y都是红色的，因为爷结点\n=.p.p 是黑色的，将=.p 和y 都着为黑色，将=.p.p 着为红色，以在局部保持性质④和③。然后，把\n=.p.p作为新结点=来重复循环，指针=在树中上移两层。调整方式如图7.20所示。\n新结点\n(a)\nR\n黑结点\n红结点\n图7.20情况3的调整方式\n若父结点=.p是爷结点=.P.p的右孩子，也还有两种对称的情况，不再赘述。\n只要满足情况3的条件，就会不断循环，每次循环指针z都会上移两层，直到满足2）（表示\n=上移到根结点）或情况1或情况2的条件。\n可能的疑问：虽然插入的初始位置一定是红黑树的某个叶结点，但因为在情况3中，结点=\n存在不断上升的可能，所以对于三种情况，结点：都有存在子树的可能。\n以图7.21(a)中的红黑树为例（虚线表示插入后的状态），先后插入5、4和12的过程如图7.21\n所示。插入5，为情况3，将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时\n因为7已是根，所以又重新着为黑色，树的黑高加1，结束。插入4，为情况1的对称情况（RL），\n此时特别注意虚构黑色空结点的存在，先对以5为根的子树做右旋；转变为情况2的对称情况\n（RR），交换3和4的颜色，再对以4为根的子树做左旋，结束。插入12，父结点是黑色的，无\n须任何调整，结束。\n空结点\n情况3\n因7为根\n黑结点\n(10\n3\n10\n将7着为黑色\n红结点\n将3和10着为黑色\n树的黑高加！\n5\n将7着为红色\n(a)插入5\n(b）第一步调整\n（c)第二步调整，插入4\n情况1的对称情况（RL）\n情况2的对称情况（RR）\n对5做右旋\n交换3和4的颜色\n对3做左旋\n(d）第一步调整\n(e)第二步调整，插入12\n图7.21红黑树的插入过程\n\n294\n2026年数据结构考研复习指导\n*3.红黑树的删除\n注意\n本节难度较大，考查概率较低，读者可根据自身情况决定是否学习或学习的时机。\n红黑树的插入操作容易导致连续的两个红结点，破坏性质④。而删除操作容易造成子树黑高\n的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质。\n删除过程也是先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找\n到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后\n继结点至多只有一个孩子，这样就转换为待删结点是终端结点或仅有一个孩子的情况。\n最终，删除一个结点有以下两种情况：\n·待删结点只有右子树或左子树。\n·待删结点没有孩子。\n1）若待删结点只有右子树或左子树，则只有两种情况，如图7.22所示。\n删除Y\n删除Y\n或\n黑结点\nYR\n红结点\n图7.22只有右子树或左子树的删除情况\n只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质5。\n2）待删结点无孩子，且该结点是红色的，这时可直接删除，而不需要做任何调整。\n3）待删结点无孩子，且该结点是黑色的，这时设待删结点为y，x是用来替换y的结点（注\n意，当y是终端结点时，x是黑色的NULL结点）。删除y后将导致先前包含y的任何路\n径上的黑结点数量减1，因此y的任何祖先都不再满足性质，简单的修正办法就是将替\n换y的结点x视为还有额外一重黑色，定义为双黑结点。也就是说，若将任何包含结点x\n的路径上的黑结点数量加1，则在此假设下，性质5得到满足，但破坏了性质①。于\n是，删除操作的任务就转化为将双黑结点恢复为普通结点。\n分为以下四种情况，区别在于x的兄弟结点w及w的孩子结点的颜色不同。\n情况1：x的兄弟结点w是红色的。\n情况1，w必须有黑色左右孩子和父结点。交换w和父结点x.p的颜色，然后对x.p做一次左\n旋，而不会破坏红黑树的任何规则。现在，x的新兄弟结点是旋转之前w的某个孩子结点，其颜\n色为黑色，这样，就将情况1转换为情况2、3或4处理。调整方式如图7.23所示。\n黑结点\n情况1\n红结点\n图7.23情况1的调整方式\n情况2：x的兄弟结点w是黑色的，且w的右孩子是红色的。\n情况3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。\n情况2（RR，左单旋），即这个红结点是其爷结点的右孩子的右孩子。交换w和父结点x.p\n\n第7章查\n找\n295\n的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，将x变为单重黑色，此时不\n再破坏红黑树的任何性质，结束。调整方式如图7.24所示。\n情况2\n黑结点红结点\n图7.24情况2的调整方式\n情况3（RL，先右旋，再左旋），即这个红结点是其爷结点的右孩子的左孩子。交换w和其\n左孩子的颜色，然后对w做一次右旋，而不破坏红黑树的任何性质。现在，x的新兄弟结点v的\n右孩子是红色的，这样就将情况3转换为了情况2。调整方式如图7.25所示。\n情况3\n新结点\n注：白色结点表示既可为黑色也可为红色，对操作没有影响\n黑结点\n红结点\n图7.25情况3的调整方式\n情况4：x的兄弟结点w是黑色的，且w的两个孩子结点都是黑色的。\n在情况4中，因为w也是黑色的，所以可从x和w上去掉一重黑色，使得x只有一重黑色而\nw变为红色。为了补偿从x和w中去掉的一重黑色，把x的父结点x.p额外着一层黑色，以保持\n局部的黑高不变。通过将x.p作为新结点x来循环，x上升一层。若是通过情况1进入情况4的，\n因为原来的x.p是红色的，将新结点x变为黑色，终止循环，结束。调整方式如图7.26所示。\n新结点x\n情况4\n黑结点红结点\n图7.26情况4的调整方式\n若x是父结点x.p的右孩子，则还有四种对称的情况，处理方式类似，不再赘述。\n归纳总结：在情况4中，因x的兄弟结点w及左右孩子都是黑色，可以从x和w中各提取\n重黑色（以让x变为普通黑结点），不会破坏性质④，并把调整任务向上“推”给它们的父结点\nx.p。在情况1、2和3中，因为x的兄弟结点w或w左右孩子中有红结点，所以只能在x.p子树\n内用调整和重新着色的方式，且不能改变x原根结点的颜色（否则向上可能破坏性质④）。情况1\n虽然可能会转换为情况4，但因为新x的父结点x.p是红色的，所以执行一次情况4就会结束。情\n况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯\n\n296\n2026年数据结构考研复习指导\n一情况，每执行一次指针x上升一层，至多O(log2n)次。\n以图7.27(a)中的红黑树为例（虚线表示删除前的状态），依次删除5和15的过程如图7.27\n所示。删除5，用虚构的黑色NULL结点（图中为N结点）替换，视为双黑NULL结点，为情况\n1，交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4，从双黑NULL结点和\n10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），\n因原父结点8是红色，所以将8变为黑色，结束。删除15，为情况3的对称情况（LR），交换8\n和10的颜色，对8做左旋：转变为情况2的对称情况（LL），交换10和12的颜色（两者颜色一\n样，无变化），将10的左孩子8着为黑色，对12做右旋，结束。\n删除5\n情况1\n黑结点\n空叶结点替换\n交换8和12的颜色\n）红结点\n视为双黑结点\n对8做一次左旋\n新结点\n（a）删除5\n(b）删除后，空叶结点替换\n（c）第一步调整后\n交换10和12的颜色\n情况4\n对12做右旋\n情况3的对称情况（LR）\nN和10各提取一重黑色\n0的左孩子8着为黑色\n8变为黑色\n交换8和10的颜色\n对8做左旋\n10\n(d)第二步调整后，删除15\n(e)第一步调整后\n(第二步调整后\n图7.27红黑树的删除过程",
        "related_points": [
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0741",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q073002",
            "q073003",
            "q073004",
            "q073005",
            "q073006",
            "q073007",
            "q073011",
            "q073012",
            "q073013",
            "q073014",
            "q073015",
            "q073017",
            "q073019",
            "q073020",
            "q073021",
            "q073022",
            "q073023",
            "q073024",
            "q073025",
            "q073026",
            "q073027",
            "q073028",
            "q073029",
            "q073030",
            "q073031",
            "q073032"
        ],
        "summry": "**红黑树**\n- **定义**：自平衡二叉搜索树，通过颜色规则和旋转操作保持近似平衡，放宽AVL树的严格平衡条件以降低调整频率。\n- **核心性质**：\n1. 节点为**红色**或**黑色**。\n2. 根节点和叶节点（NULL节点）必为黑色。\n3. 无相邻红节点（红节点的父节点和子节点必为黑）。\n4. 任意节点到叶节点的路径包含相同数量的黑节点（**黑高**一致）。\n- **平衡性**：\n- 最长路径≤2倍最短路径（全黑路径为最短，红黑交替为最长）。\n- 树高**h ≤ 2log₂(n+1)**，保证**O(log n)**的查找、插入、删除操作。\n- **应用场景**：C++ `map/set`、Java `TreeMap/TreeSet`等需高效动态操作的场景。\n**插入操作**\n1. **新节点着色为红**（避免破坏黑高，仅可能违反红节点相邻规则）。\n2. **调整策略**（根据叔节点颜色）：\n- **叔节点为红**：父、叔变黑，祖父变红，递归调整祖父（情况3）。\n- **叔节点为黑**：通过旋转（LL/RR/LR/RL）和变色恢复平衡（情况1/2）。\n- **记忆提示**：红叔向上递归，黑叔旋转+变色。\n**删除操作**\n1. **转换为删除单孩子或无孩子节点**（若有两个孩子，用后继节点替换）。\n2. **双黑节点处理**（删除黑节点后，替换节点视为“双黑”以保持黑高）：\n- **兄弟节点为红**：旋转父节点，转为兄弟为黑的情况（情况1）。\n- **兄弟为黑且兄弟子节点有红**：通过旋转和变色消除双黑（情况2/3）。\n- **兄弟及子节点全黑**：向上传递双黑至父节点（情况4）。\n- **记忆提示**：红兄旋转，黑兄看侄子，全黑则上推。\n**与AVL树对比**\n- **红黑树**：平衡宽松（高度差≤2倍），插入/删除调整次数少，适合频繁修改场景。\n- **AVL树**：严格平衡（高度差≤1），查找更快，适合读多写少场景。\n**图示辅助**\n- 插入：红叔向上“冒泡”，黑叔旋转“修剪”。\n- 删除：双黑“上浮”至根或通过兄弟“借色”。"
    },
    {
        "id": "kc0741",
        "title": "B树及其基本操作",
        "chapter_id": "07",
        "description": "所谓m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。\n命题追踪B树的定义和特点（2009）\n一棵m阶B树或为空树，或为满足如下特性的m叉树：\n1）树中每个结点至多有m棵子树，即至多有m-1个关键字。\n2）若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字。\n3）除根结点外的所有非叶结点至少有「m/2]棵子树，即至少有「m/2]-1个关键字。\n4）所有非叶结点的结构如下：\nnPoKPK2P2KP\n其中，K，（i=1,2,…，n）为结点的关键字，且满足K<K2<.….<Kn；P（i=0,1,……·，n）\n为指向子树根结点的指针，且指针P所指子树中所有结点的关键字均小于K，P所指子\n树中所有结点的关键字均大于K；n（「m/2l-1≤n≤m-1）为结点中关键字的个数。\n5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查\n找判定树的失败结点，实际上这些结点并不存在，指向这些结点的指针为空）。\n命题追踪B树中关键字数和结点数的分析（2013、2014、2018、2021）\n图7.28所示为一棵5阶B树，可以借助该实例来分析上述性质：\n22\n3645\n内部结点\n13689131530354042\n图7.28一棵5阶B树的实例\n1）结点的孩子个数等于该结点中关键字个数加1。\n2）若根结点没有关键字就没有子树，则此时B树为空；若根结点有关键字，则其子树个数\n必然大于或等于2，因为子树个数等于关键字个数加1。\n3）除根结点外的所有非叶结点至少有m/2]=「5/2]=3棵子树（至少有m/2]-1=[5/2]-1=2\n个关键字）：至多有5棵子树（至多有4个关键字）。\n4）结点中的关键字从左到右递增有序，关键字两侧均有指向子树的指针，左侧指针所指子\n树的所有关键字均小于该关键字，右侧指针所指子树的所有关键字均大于该关键字。或\n者看成下层结点的关键字总是落在由上层结点的关键字所划分的区间内，如第二层最左\n结点的关键字划分成了3个区间：（-，5)，（5,11),（11,+∞），该结点中的3个指针所指子\n树的关键字均分别落在这3个区间内。\n5）所有叶结点均在第4层，代表查找失败的位置。\n1.B树的查找\n在B树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，在每个结\n①多数教材将B树的叶结点定义为失败结点，本书也采用这种定义，但408真题将B树的叶结点定义为最底层的终端结点。\n\n312\n2026年数据结构考研复习指导\n点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。\nB树的查找包含两个基本操作：①在B树中找结点：②在结点内找关键字。B树常存储在\n磁盘上，因此前一查找操作是在磁盘上进行的，而后一查找操作是在内存中进行的，即在磁盘上\n找到目标结点后，先将结点信息读入内存，然后再采用顺序查找法或折半查找法。因此，在磁盘\n上进行查找的次数即目标结点在B树上的层次数，决定了B树的查找效率。\n在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的\n点只有一个关键字，且42>22，若存在，必在关键字22的右边子树上，右孩子结点有两个关键\n字，而36<42<45，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查\n找成功）。查找到叶结点时（对应指针为空），则说明树中没有对应的关键字，查找失败。\n2.B树的高度（磁盘存取次数）\n由上一节得知，B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。\n下面来分析B树在不同情况下的高度。当然，首先应该明确B树的高度不包括最后的不带任\n何信息的叶结点所处的那一层（有些书对B树的高度的定义中，包含最后的那一层）。\n若n≥1，则对任意一棵包含n个关键字、高度为h、阶数为m的B树：\n1）若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。\n因为B树中每个结点最多有m棵子树，m-1个关键字，所以在一棵高度为h的m阶B\n树中关键字的个数应满足n≤（m-1)(1+m+m²+..·+m²-)=m-1，因此有\nh≥1ogm(n+1)\n2）若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。\n第一层至少有1个结点；第二层至少有2个结点；除根结点外的每个非叶结点至少有「m/2]\n棵子树，则第三层至少有2m/2|个结点……··第h+1层至少有2（m/21）-1个结点，注意\n到第h+1层是不包含任何信息的叶结点。对于关键字个数为n的B树，叶结点即查找不\n成功的结点为n+1，由此有n+1≥2(「m/2])²1，即h≤log[m/2]((n+ 1)/2)+ 1。\n例如，假设一棵3阶B树共有8个关键字，则其高度范围为2≤h≤3.17，取整数。\n3.B树的插入\n命题追踪通过插入操作构造一棵初始为空的B树（2020）\n与二叉排序树的插入操作相比，B树的插入操作要复杂得多。在B树中查找到插入的位置后，\n并不能简单地将其添加到终端结点（最底层的非叶结点）中，因为此时可能会导致整棵树不再满\n足B树定义中的要求。将关键字key插入B树的过程如下：\n1）定位。利用前述的B树查找算法，找出插入该关键字的终端结点（在B树中查找key时，\n会找到表示查找失败的叶结点，因此插入位置一定是最底层的非叶结点）。\n2）插入。每个非根结点的关键字个数都在[m/2｜-1，m-1]。若结点插入后的关键字个数小\n于m，可以直接插入；若结点插入后的关键字个数大于m-1，必须对结点进行分裂。\n分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置（「m/2]）将其中的关\n键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间\n位置（m/21）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则\n继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。\n对于m=3的B树，所有结点中最多有m-1=2个关键字，若某结点中已有两个关键字，则\n所示，此时必须进行结点分裂，分裂的结果如图7.29（c）所示。\n\n第7章\n找\n313\n结点分裂\n20\n5052\n20\n505260\n2050\n60\n(a)插入前\n(b)插入后，结点溢出\n(c）结点分裂\n图7.29结点的“分裂”示意\n4.B树的删除\nB树的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个\n数≥[m/2]-1，因此将涉及结点的“合并”问题。\n命题追踪B树的删除操作的实例（2012、2022）\n当被删关键字k不在终端结点中时，可以用k的前驱（或后继）k，即k的左侧子树中“最\n右下”的元素（或右侧子树中“最左下”的元素），来替代k，然后在相应的结点中删除k，关键\n字k必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30的4阶B\n树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。\n6080\n删除80\n6878\n...\n68\n图7.30B树中删除非终端结点关键字的取代\n因此只需讨论被删关键字在终端结点中的情形，有下列三种情况：\n1）直接删除关键字。若被删关键字所在结点删除前的关键字个数≥「m/2]，表明删除该关键\n字后仍满足B树的定义，则直接删去该关键字。\n2）兄弟够借。若被删关键字所在结点删除前的关键字个数=「m/2]-1，且与该结点相邻的右\n（或左）兄弟结点的关键字个数≥「m/2]，则需要调整该结点、右（或左）兄弟结点及其双\n亲结点（父子换位法），以达到新的平衡。在图7.31(a)中删除4阶B树的关键字65，右\n兄弟关键字个数≥[m/2]=2，将71取代原65的位置，将74调整到71的位置。\n删除65\n6074\n7486\n71\n86\n(a)兄弟够借\n6071\n删除5\n71\n60\n65\n7486\n(b)兄弟不够借\n图7.314阶B树中删除终端结点关键字的示意图\n3）兄弟不够借。若被删关键字所在结点删除前的关键字个数=「m/2]-1，且此时与该结点相\n邻的左、右兄弟结点的关键字个数都=「m/2]-1，则将关键字删除后与左（或右）兄弟结\n点及双亲结点中的关键字进行合并。在图7.31（b)中删除4阶B树的关键字5，它及其右\n兄弟结点的关键字个数=「m/21-1=1，所以在5删除后将60合并到65结点中。\n\n314\n2026年数据结构考研复习指导\n命题追踪非空B树的查找、插入、删除操作的特点（2023）\n在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少\n至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根；\n若双亲结点不是根结点，且关键字个数减少到「m/21-2，则又要与它自已的兄弟结点进行调整或\n合并操作，并重复上述步骤，直至符合B树的要求为止。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0512",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0731",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0733",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0742",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q074001",
            "q074002",
            "q074003",
            "q074004",
            "q074005",
            "q074006",
            "q074007",
            "q074008",
            "q074010",
            "q074011",
            "q074012",
            "q074013",
            "q074014",
            "q074015",
            "q074016",
            "q074017",
            "q074018",
            "q074019",
            "q074020",
            "q074021",
            "q074022"
        ],
        "summry": "**B树及其基本操作**\n- **定义**：\n- **m阶B树**是平衡因子均为0的**m路平衡查找树**，用于高效管理磁盘存储的大量数据。\n- **空树**或满足以下特性的m叉树：\n1. 每个结点至多含**m-1个关键字**和**m棵子树**。\n2. 根结点若非叶结点，至少含**1个关键字**和**2棵子树**。\n3. 非根非叶结点至少有**⌈m/2⌉-1个关键字**和**⌈m/2⌉棵子树**。\n4. 关键字按序排列（`K₁ < K₂ < ... < Kₙ`），子树指针`Pᵢ`满足：`P₀`子树关键字均小于`K₁`，`Pₙ`子树关键字均大于`Kₙ`。\n5. 所有叶结点在同一层（视为外部空结点）。\n- **特性**：\n- **平衡性**：所有叶结点同层，保证**O(logₘ n)**的查找效率。\n- **关键字与子树关系**：结点中**关键字数 = 子树数 - 1**。\n- **示例（5阶B树）**：\n- 非叶结点关键字数范围：2 ≤ n ≤ 4（⌈5/2⌉-1至5-1）。\n- 子树数范围：3 ≤ k ≤ 5（根结点例外）。\n- **查找操作**：\n- **步骤**：\n1. **磁盘访问**：从根结点开始，逐层向下查找目标结点。\n2. **内存查找**：在结点内用**顺序查找**或**折半查找**定位关键字。\n- **时间复杂度**：**O(h)**，h为树高（磁盘存取次数）。\n- **高度分析**：\n- **最小高度**（结点满）：`h ≥ logₘ(n+1)`。\n- **最大高度**（结点最空）：`h ≤ log⌈m/2⌉((n+1)/2) + 1`。\n- **示例**：3阶B树含8个关键字时，高度2 ≤ h ≤ 3。\n- **插入操作**：\n- **步骤**：\n1. **定位**：找到最底层非叶结点插入位置。\n2. **分裂**：若关键字数 > m-1，则取中间关键字上提至父结点，左右部分分裂为新结点。\n- **分裂示例**：3阶B树插入`60`导致溢出，分裂为`[20,50]`和`[60]`，中间关键字`50`上提。\n- **删除操作**：\n- **非终端结点**：用前驱（左子树最右）或后继（右子树最左）关键字替代，转为终端删除。\n- **终端结点**：\n1. **直接删除**：若关键字数 ≥ ⌈m/2⌉。\n2. **兄弟够借**：从相邻兄弟借关键字，父子换位（如删除`65`借`71`）。\n3. **兄弟不够借**：与父结点关键字及兄弟合并（如删除`5`合并`60`和`65`）。\n- **合并连锁反应**：若父结点关键字数不足，继续向上合并，可能减少树高。\n- **应用场景**：\n- 数据库索引、文件系统（如NTFS、EXT4），需**减少磁盘I/O次数**的场景。\n- **记忆提示**：\n- **插入分裂**：关键字超限→中间提父，左右分裂。\n- **删除合并**：兄弟能借则借，不能借则合。\n- **高度公式**：最小满、最大空，对数关系定范围。"
    },
    {
        "id": "kc0742",
        "title": "B+树的基本概念",
        "chapter_id": "07",
        "description": "命题追踪B+树的应用场合（2017）\nB+树是应数据库所需而出现的一种B树的变形树。\n一棵m阶B+树应满足下列条件：\n1）每个分支结点最多有m棵子树（孩子结点）。\n2）非叶根结点至少有两棵子树，其他每个分支结点至少有「m/2］棵子树。\n3）结点的子树个数与关键字个数相等。\n4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，\n并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）。\n5）所有分支结点（可视为索引的索引）中仅包含它的各个子结点（下一级的索引块）中关\n键字的最大值及指向其子结点的指针。\n命题追踪B树和B+树的差异的分析（2016）\nm阶B+树与m阶B树的主要差异如下：\n1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树：而在\nB树中，具有n个关键字的结点含有n+1棵子树。\n2）在B+树中，每个结点（非根内部结点）的关键字个数n的范围是「m/2≤n≤m（非叶根\n结点：2≤n≤m）；而在B树中，每个结点（非根内部结点)的关键字个数n的范围是「m/2]-1\n≤n≤m-1（根结点：1≤n≤m-1）。\n3）在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而\n在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。\n4）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含\n有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使\n一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快。\n5）在B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表。\n图7.32所示为一棵4阶B+树。可以看出，分支结点的关键字是其子树中最大关键字的副本。通\n常在B+树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对B+树\n进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。\n10205060\n7785\n81016204050556069778085\n图7.32B+树结构示意图\n\n第7章查\n找\n315\nB+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键\n字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。因此，在B+\n树中查找成功或失败（≤最大关键字）时，每次查找都是一条从根结点到叶结点的路径。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0741",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q074001",
            "q074002",
            "q074003",
            "q074004",
            "q074005",
            "q074006",
            "q074007",
            "q074008",
            "q074010",
            "q074011",
            "q074012",
            "q074013",
            "q074014",
            "q074015",
            "q074016",
            "q074017",
            "q074018",
            "q074019",
            "q074020",
            "q074021",
            "q074022"
        ],
        "summry": "**B+树**\n- **定义**：专为数据库设计的B树变种，通过分层索引与叶结点链表优化磁盘I/O效率。\n- **特性**：\n- **分支结点规则**：\n- m阶B+树中，分支结点最多m棵子树，非根分支结点至少⌈m/2⌉棵子树。\n- 关键字数=子树数（B树为子树数-1）。\n- **叶结点规则**：\n- 包含全部关键字及记录指针，按序排列并双向链接（支持顺序扫描）。\n- 分支结点仅存储子结点最大关键字的副本（不存记录地址）。\n- **与B树差异**：\n- **结构差异**：B+树非叶结点纯索引，关键字重复出现在叶结点；B树各层关键字不重复。\n- **范围约束**：B+树结点关键字数n满足⌈m/2⌉≤n≤m（根：2≤n≤m）；B树为⌈m/2⌉-1≤n≤m-1（根：1≤n≤m-1）。\n- **查找路径**：B+树查找必到叶结点（即使中间匹配）；B树可能在非叶结点终止。\n- **应用场景**：\n- 数据库索引（如MySQL InnoDB），文件系统（高效范围查询与顺序访问）。\n- **操作复杂度**：\n- 查找/插入/删除均为**O(log n)**，基于多路平衡与结点分裂/合并。\n- **优势**：\n- 更高扇出（减少磁盘访问），天然支持范围查询（叶结点链表）。\n- **记忆提示**：\n- \"B+树≈多层目录+有序链表，分支结点是导航，叶结点存数据\"。"
    },
    {
        "id": "kc0751",
        "title": "散列表的基本概念",
        "chapter_id": "07",
        "description": "在前面介绍的线性表和树表的查找中，查找记录需进行一系列的关键字比较，记录在表中的\n位置与记录的关键字之间不存在映射关系，因此在这些表中的查找效率取决于比较的次数。\n散列函数（也称哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，\n记为Hash(key）=Addr（这里的地址可以是数组下标、索引或内存地址等）。\n\n324\n2026年数据结构考研复习指导\n散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些\n方面，因为这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。\n散列表（也称哈希表）：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了\n关键字和存储地址之间的一种直接映射关系。\n理想情况下，对散列表进行查找的时间复杂度为0（1)，即与表中元素的个数无关。下面分别\n介绍常用的散列函数和处理冲突的方法。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0752",
                "relation_type": "extension"
            },
            {
                "id": "kc0753",
                "relation_type": "extension"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q075001",
            "q075002",
            "q075003",
            "q075004",
            "q075005",
            "q075006",
            "q075008",
            "q075009",
            "q075010",
            "q075011",
            "q075012",
            "q075013",
            "q075014",
            "q075015",
            "q075016",
            "q075017",
            "q075018",
            "q075019",
            "q075020",
            "q075021",
            "q075022",
            "q075023"
        ],
        "summry": "**散列表（哈希表）**\n- **定义**：通过**散列函数**（Hash Function）将关键字直接映射到存储地址的数据结构，建立关键字→地址的直接访问关系。\n- **核心特性**：\n- **理想时间复杂度**：**O(1)**（无冲突时）。\n- **冲突必然性**：不同关键字可能映射到同一地址（如 `Hash(key1) == Hash(key2)`）。\n- **关键组件**：\n1. **散列函数设计**：\n- 目标：均匀分布、减少冲突。\n- 常见方法：直接定址法（`Hash(key)=a*key+b`）、除留余数法（`Hash(key)=key%p`）、平方取中法等。\n2. **冲突解决方法**：\n- **开放定址法**：线性探测、二次探测、双重散列。\n- **链地址法**：冲突地址拉链表存储（如Java `HashMap`）。\n- **应用场景**：高速缓存、数据库索引、符号表（如Python字典）。\n- **优缺点**：\n- 优点：平均高效（接近O(1)），适合频繁查找。\n- 缺点：冲突增多时性能退化，需动态扩容。\n**记忆提示**：\n- “哈希≈字典，直接找地址；冲突必处理，链址或探测”。\n- 设计原则：散列均匀、冲突少、计算快。"
    },
    {
        "id": "kc0752",
        "title": "散列函数的构造方法",
        "chapter_id": "07",
        "description": "在构造散列函数时，必须注意以下几点：\n1）散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小。\n2）散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。\n3）散列函数应尽量简单，能在较短的时间内计算出任意一个关键字对应的散列地址。\n下面介绍常用的散列函数。\n1.直接定址法\n直接取关键字的某个线性函数值为散列地址，散列函数为\nH(key)=key或H(key)=axkey +b\n式中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的\n情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。\n2.除留余数法\n这是一种最简单、最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m\n的质数p，利用以下公式把关键字转换成散列地址。散列函数为\nH(key) = key % p\n除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上\n的任意一个地址，从而尽可能减少冲突的可能性。\n3.数字分析法\n设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某\n些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经\n常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集\n合，若更换了关键字，则需要重新构造新的散列函数。\n4.平方取中法\n顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情\n况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，\n适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。\n在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。\n在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0751",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0753",
                "relation_type": "extension"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q075001",
            "q075002",
            "q075003",
            "q075004",
            "q075005",
            "q075006",
            "q075008",
            "q075009",
            "q075010",
            "q075011",
            "q075012",
            "q075013",
            "q075014",
            "q075015",
            "q075016",
            "q075017",
            "q075018",
            "q075019",
            "q075020",
            "q075021",
            "q075022",
            "q075023"
        ],
        "summry": "**散列函数的构造方法**\n- **核心原则**：\n1. **定义域覆盖**：必须包含所有关键字，值域由散列表大小决定。\n2. **均匀性**：计算结果应均匀分布，减少冲突。\n3. **高效性**：计算简单快速（**O(1)** 时间复杂度）。\n- **常用方法**：\n1. **直接定址法**\n- **公式**：`H(key) = key` 或 `H(key) = a×key + b`（a、b为常数）。\n- **特点**：无冲突，但要求关键字分布连续，否则浪费空间。\n- **适用场景**：如学号、连续ID等线性分布数据。\n2. **除留余数法**\n- **公式**：`H(key) = key % p`（p为≤表长m的最大质数）。\n- **关键**：质数p的选择直接影响均匀性，减少聚集现象。\n- **适用场景**：通用性强，适合大多数情况（如哈希表默认实现）。\n3. **数字分析法**\n- **步骤**：分析关键字各位数码分布，选取均匀的位组合作为地址。\n- **特点**：依赖已知关键字集合，更换数据需重新设计。\n- **适用场景**：如手机号后四位、身份证号特定段等局部均匀数据。\n4. **平方取中法**\n- **步骤**：对关键字平方后取中间几位作为地址。\n- **特点**：利用平方扩大位数差异，使地址与关键字各位相关。\n- **适用场景**：关键字各位不均匀或位数不足时（如短字符串哈希）。\n- **选择建议**：\n- 关键字连续→**直接定址法**；\n- 通用需求→**除留余数法**（优先选质数模数）；\n- 已知分布规律→**数字分析法**；\n- 局部不均匀→**平方取中法**。\n**记忆提示**：\n- “连续用直接，通用取余数，已知看数字，不均平方中”。"
    },
    {
        "id": "kc0753",
        "title": "处理冲突的方法",
        "chapter_id": "07",
        "description": "应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲\n突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。用H表示处理冲突\n\n第7章查\n找\n325\n中第i次探测得到的散列地址，假设得到的另一个散列地址H仍然发生冲突，只得继续求下一个\n地址H，以此类推，直到H不发生冲突为止，则H为关键字在表中的地址。\n1．开放定址法\n所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非\n同义词表项开放。其数学递推公式为\nH,=(H(key) +d)% m\n式中，H(key)为散列函数；i=1,2,··，k（k≤m-1)；m表示散列表表长；d为增量序列。\n取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：\n命题追踪?堆积现象导致的结果（2014）\n1）线性探测法，也称线性探测再散列法。d=1,2,…，m-1。它的特点是：冲突发生时，顺\n序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址是表首地址0），直\n到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n线性探测法可能使第i个散列地址的同义词存入第1+1个散列地址，这样本应存入第i+\n1个散列地址的元素就争夺第1+2个散列地址的元素的地址从而造成大量元素在相\n邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。\n2）平方探测法，也称二次探测法。d=1²,-1²,2²,-2²,.…,k²,-k²，其中k≤m/2，散列表长度\nm必须是一个可以表示成4k+3的素数。\n平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能\n探测到散列表上的所有单元，但至少能探测到一半单元。\n3）双散列法。d=ixHash2(key)。需要使用两个散列函数，当通过第一个散列函数H(key)得\n到的地址发生冲突时，则利用第二个散列函数Hashz（key)计算该关键字的地址增量。它的\n具体散列函数形式如下：\nH,=(H(key) + ixHash2(key)) % m\n初始探测位置H=H(key)%m。i是冲突的次数，初始为0。\n4）伪随机序列法。d=伪随机数序列。\n命题追踪\n散列表中删除部分元素后的查找效率分析（2023）\n注意\n采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径，删\n除元素时可以做一个删除标记，进行逻辑删除，具体举例见本书配套课程。但这样做的副作用是：执行\n多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。\n2.拉链法（链接法，chaining）\n显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，\n可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地\n址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入和删除操作主要在\n同义词链中进行。拉链法适用于经常进行插入和删除的情况。\n用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可尝试计算本例的平均ASL）。\n\n326\n2026年数据结构考研复习指导\n01142779\n1\n2\n3\n5568\n4\n5\n5\n1984\n7\nM\n8\n6\n10\n公众号：小兔网盘\n11\n免费网课+无水印PDF\n12\n图7.33拉链法处理冲突的散列表",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0723",
                "relation_type": "extension"
            },
            {
                "id": "kc0751",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0752",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0754",
                "relation_type": "extension"
            }
        ],
        "questions": [
            "q075001",
            "q075002",
            "q075003",
            "q075004",
            "q075005",
            "q075006",
            "q075008",
            "q075009",
            "q075010",
            "q075011",
            "q075012",
            "q075013",
            "q075014",
            "q075015",
            "q075016",
            "q075017",
            "q075018",
            "q075019",
            "q075020",
            "q075021",
            "q075022",
            "q075023"
        ],
        "summry": "**处理冲突的方法**\n- **定义**：当散列函数将不同关键字映射到同一地址（冲突）时，通过特定策略寻找下一个可用地址的方法，确保数据能正确存入散列表。\n- **核心方法**：\n1. **开放定址法**\n- **原理**：冲突时按增量序列探测下一个空闲地址，递推公式为 `H_i = (H(key) + d_i) % m`（`m`为表长）。\n- **增量序列类型**：\n- **线性探测法**（`d_i = 1, 2, ..., m-1`）：\n- 顺序探测相邻单元，易导致**堆积现象**（元素聚集），降低查找效率（最坏**O(n)**）。\n- **平方探测法**（`d_i = ±1², ±2², ..., ±k²`）：\n- 避免堆积，但要求表长 `m` 为 `4k+3` 的素数，仅能探测约一半单元。\n- **双散列法**（`d_i = i×Hash2(key)`）：\n- 使用第二个散列函数计算步长，减少冲突聚集。\n- **伪随机序列法**（`d_i` 为伪随机数）：\n- 依赖随机性，实际应用较少。\n- **删除注意**：需逻辑删除（标记而非物理删除），避免截断查找路径。\n2. **拉链法（链地址法）**\n- **原理**：将冲突的同义词存储在同一个链表中，散列表单元指向链表头。\n- **优点**：\n- 无堆积现象，平均查找效率高（**O(1 + α)**，`α`为装载因子）。\n- 支持动态插入/删除，空间利用率高。\n- **适用场景**：频繁插入/删除操作。\n- **关键对比**：\n- **开放定址法** vs **拉链法**：\n- 开放定址法需表长足够，易受堆积影响；拉链法额外存储指针但更灵活。\n- **记忆提示**：\n- 线性探测≈排队找空位；拉链法≈冲突关键字“手拉手”成链表。\n- **典型问题**：\n- 堆积现象（线性探测）导致查找效率下降。\n- 删除元素时需逻辑删除（开放定址法）。"
    },
    {
        "id": "kc0754",
        "title": "散列查找及性能分析的应用",
        "chapter_id": "07",
        "description": "命题追踪散列表的构造及查找效率的分析（2010、2018、2019、2024）\n散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函\n数可以计算出其散列地址，执行步骤如下：\n初始化：Addr=Hash(key);\n①检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，\n比较它与key的值，若相等，则返回查找成功标志，否则执行步骤②。\n②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤①。\n和线性探测处理冲突构造所得的散列表L如图7.34所示。\n0\n2345678\n9\n10\n11\n12\n13\n14\n15\n140168275519208479231110\n图7.34用线性探测法得到的散列表L\n给定值84的查找过程为：首先求得散列地址H（84）=6，因L[6]不空且L[6]≠84，则找第\n一次冲突处理后的地址H=（6+1）%16=7，而L[7]不空且L[7]≠84，则找第二次冲突处理后的\n地址H2=（6+2）%16=8，L[8]不空且L[8]=84，查找成功，返回记录在表中的序号8。\n给定值38的查找过程为：先求散列地址H（38）=12，L[12]不空且L[12]≠38，则找下一\n地址H=（12+1）%16=13，因为L[13]是空记录，所以表中不存在关键字为38的记录。\n查找各关键字的比较次数如图7.35所示。\n关键字\n14\n01\n682755\n192084\n79\n比较次数\n一\n2\n1114\n13\n3\n9\n3\n图7.35查找各关键字的比较次数\n平均查找长度ASL为\nASL=（1x6+2+3x3+4+9)/12=2.5\n对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们\n的平均查找长度也不同，本例与上节采用拉链法的平均查找长度不同。\n从散列表的查找过程可见：\n1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，\n\n第7章查\n找\n327\n使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程，因此仍然需要以平\n均查找长度作为衡量散列表的查找效率的度量。\n命题追踪】影响散列表查找效率的因素（2011、2022）\n2）散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。\n装填因子。散列表的装填因子一般记为α，定义为一个表的装满程度，即\n表中记录数n\nα=\n散列表长度m\n散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观地看，α\n越大，表示装填的记录越“满”，发生冲突的可能性越大；反之发生冲突的可能性越小。\n读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的\n基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0634",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0751",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0752",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0753",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [
            "q075001",
            "q075002",
            "q075003",
            "q075004",
            "q075005",
            "q075006",
            "q075008",
            "q075009",
            "q075010",
            "q075011",
            "q075012",
            "q075013",
            "q075014",
            "q075015",
            "q075016",
            "q075017",
            "q075018",
            "q075019",
            "q075020",
            "q075021",
            "q075022",
            "q075023"
        ],
        "summry": "**散列查找及性能分析**\n- **定义**：通过**散列函数**将关键字映射到表中地址，实现快速查找的数据结构。\n- **查找流程**：\n1. 计算初始地址 `Addr = Hash(key)`。\n2. 若 `Addr` 位置为空→查找失败；若匹配→成功；否则用冲突处理方法计算下一地址（如线性探测：`H_i = (Hash(key) + i) % m`）。\n3. 重复步骤2直至找到或确认不存在。\n- **性能指标**：\n- **平均查找长度（ASL）**：成功/失败时的平均比较次数（例：线性探测法 ASL=2.5）。\n- **装填因子 α = n/m**（n为记录数，m为表长），α越大冲突概率越高。\n- **关键因素**：\n1. **散列函数**：均匀性影响冲突频率（如取模法、平方取中法）。\n2. **冲突处理**：\n- **开放定址法**（线性探测、平方探测）。\n- **链地址法**（冲突记录链式存储）。\n3. **装填因子α**：通常要求 α < 0.7 以保证效率。\n- **命题重点**：\n- 构造散列表并计算ASL（如线性探测法需统计比较次数）。\n- 对比不同冲突方法的ASL差异（链地址法通常优于开放定址法）。\n- **记忆提示**：\n- **查找≈散列函数+冲突探测**，**ASL≈冲突概率的量化**。\n- 线性探测易产生“聚集”，链地址法空间开销较大。\n- **示例**：\n- 关键字84的查找：`H(84)=6 → 7 → 8`（3次比较）。\n- 关键字38的查找：`H(38)=12 → 13`（2次比较，失败）。"
    },
    {
        "id": "kc0811",
        "title": "排序的定义",
        "chapter_id": "08",
        "description": "排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，\n通常希望计算机中的表是按关键字有序的。排序的确切定义如下：\n输入：n个记录R，R2,.…，R，对应的关键字为k，k2.…，kn。\n输出：输入序列的一个重排R'，R'，…,R”，使得K≤k≤.·≤k’（其中“≤”可以换成其他\n的比较大小的符号）。\n算法的稳定性。若待排序表中有两个元素 R,和 R，其对应的关键字相同，即key,=key，且\n在排序前R在R的前面，若使用某一排序算法排序后，R仍然在R的前面，则称这个排序算法\n是稳定的，否则称这个排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一\n个算法的优劣，它主要是对算法的性质进行描述。若待排序表中的关键字不允许重复，排序结果\n是唯一的，则对于排序算法的选择，稳定与否无关紧要。\n注意\n对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。\n在排序过程中，根据数据元素是否完全存放在内存中，可将排序算法分为两类：①内部排序，\n是指在排序期间元素全部存放在内存中的排序：②外部排序，是指在排序期间元素无法全部同时\n存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。\n一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关\n键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部\n排序算法都要基于比较操作，事实上，基数排序就不基于比较操作。\n每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出\n一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序\n和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂\n度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。\n注意\n大多数的内部排序算法都更适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc086597",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc0831",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0841",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "extension"
            },
            {
                "id": "kc0852",
                "relation_type": "extension"
            },
            {
                "id": "kc0853",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**排序的定义**\n- **定义**：将表中的元素按关键字重新排列，使其满足有序性（如升序/降序）。\n- **输入/输出**：\n- 输入：n个记录 `R₁, R₂, ..., Rₙ`，对应关键字 `k₁, k₂, ..., kₙ`。\n- 输出：重排序列 `R'₁, R'₂, ..., R'ₙ`，使得 `k'₁ ≤ k'₂ ≤ ... ≤ k'ₙ`（“≤”可替换为其他比较符号）。\n- **稳定性**：\n- 若关键字相同的元素（`keyᵢ = keyⱼ`）在排序前后相对位置不变，则称算法**稳定**，否则为**不稳定**。\n- 稳定性不决定算法优劣，仅描述性质；关键字唯一时稳定性无关紧要。\n- **分类**：\n- **内部排序**：数据全部在内存中完成（如快速排序、堆排序）。\n- **外部排序**：数据需通过内存与外存交互完成（如归并排序处理大文件）。\n- **核心操作**：\n- **比较**：确定元素间顺序关系。\n- **移动**：调整元素位置（部分算法如**基数排序**无需比较）。\n- **算法类型**：\n- 插入排序、交换排序、选择排序、归并排序、基数排序五大类。\n- 性能由**时间复杂度**（比较/移动次数）和**空间复杂度**决定。\n- **注意**：\n- 大多数内部排序更适用于**顺序存储**的线性表。\n- 不稳定算法只需一组反例即可证明（如快速排序中相同关键字的相对位置可能变化）。\n**快速记忆**\n- 稳定性：相同关键字“先来后到” → 稳定；否则不稳定。\n- 内/外部排序：数据是否全在内存 → 内部/外部。"
    },
    {
        "id": "kc0821",
        "title": "直接插入排序?",
        "chapter_id": "08",
        "description": "过程中，待排序表L[1..n］在某次排序过程中的某一时刻状态如下：\n有序序列L[1..i-1]L（i）无序序列L[i+1..n]\n要将元素L（i)插入已有序的子序列L[1..i-1]，需要执行以下操作（为避免混淆，下面用\nL[表示一个表，而用L（）表示一个元素）：\n1）查找出L（i）在L[1..i-1]中的插入位置k。\n2）将L[k..i-1]中的所有元素依次后移一个位置。\n3）将L(i)复制到L(k)。\n为了实现对L[1..n]的排序，可以将L（2）～L（n）依次插入前面已排好序的子序列，初始L[1]\n上通常采用原地排序（空间复杂度为0（1)），因而在从后往前的比较过程中，需要反复把已排序\n元素逐步向后挪位，为新元素提供插入空间。\n①在本书中，凡是没有特殊注明的，通常默认排序结果为非递减有序序列。\n\n340\n2026年数据结构考研复习指导\n下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）。\nvoid InsertSort(ElemType A[],int n)(\nint i,j;\nfor(i=2;i<=n;i++)\n//依次将A[2]~A[n]插入前面已排序序列\nif(A[i]<A[i-1]){\n若A[i]关键码小于其前驱，将A[i]插入有序表\nA[O]=A[i];\n/复制为哨兵，A[0]不存放元素\nfor（j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置\nA[j+1]=A[j];\n//向后挪位\nA[j+1]=A[0];\n/复制到插入位置\n假定初始序列为49，3",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "extension"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "extension"
            },
            {
                "id": "kc0341",
                "relation_type": "extension"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "extension"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**直接插入排序**\n- **定义**：通过构建有序序列，逐个将未排序元素插入到已排序部分的正确位置，实现整体排序的算法。\n- **核心过程**：\n1. **划分序列**：将数组分为已排序区 `L[1..i-1]` 和未排序区 `L[i..n]`。\n2. **插入操作**：\n- 查找位置：在已排序区中找到 `L(i)` 的插入位置 `k`（从后向前比较）。\n- 移动元素：将 `L[k..i-1]` 后移一位。\n- 插入元素：将 `L(i)` 放入位置 `k`。\n- **特性**：\n- **时间复杂度**：\n- 最好情况（已有序）：**O(n)**（只需比较，无需移动）。\n- 最坏/平均情况（逆序/随机）：**O(n²)**（需比较并移动大量元素）。\n- **空间复杂度**：**O(1)**（原地排序，仅需常数辅助空间，如哨兵）。\n- **稳定性**：稳定（相等元素不改变相对顺序）。\n- **优化技巧**：\n- **哨兵机制**：使用 `A[0]` 暂存待插入元素，避免越界检查（如示例代码）。\n- **二分查找**：在已排序区中用二分法找插入位置（减少比较次数，但移动次数不变）。\n- **应用场景**：\n- 小规模数据或基本有序数据时效率较高。\n- 作为高级排序算法（如快速排序）的子过程。\n- **示例代码关键点**：\n```c\nfor (i=2; i<=n; i++) {\nif (A[i] < A[i-1]) {       // 触发插入条件\nA[0] = A[i];             // 哨兵\nfor (j=i-1; A[0]<A[j]; --j) A[j+1] = A[j]; // 后移\nA[j+1] = A[0];           // 插入\n}\n}\n```\n- **记忆提示**：\n- “扑克牌排序”类比：逐个将新牌插入手中已排序的牌堆。\n- **哨兵**作用：简化边界判断，提升代码效率。"
    },
    {
        "id": "kc086597",
        "title": "，76.13,27.49，初始时49可以视为一个已排好序的子序列，",
        "chapter_id": "08",
        "description": "按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。\n[初始关键字]：\n(49)\n65\n97\n76\n13\n27\n49\ni=2:\n(38)\n49)\n97\n76\n13\n27\n49\ni=3:\n(65)\n(38\n49\n65)\n97\n76\n13\n27\n49\ni=4:\n(97)\n(38\n49\n65\n97)\n76\n13\n27\n49\ni=5:\n(76)\n(38\n49\n65\n76\n97)\n13\n27\n49\n(1#\ni=6:\n38\n49\n65\n(13)\n97)\n27\n49\n#\ni=7:\n(27)\n(13\n38\n49\n65\n76\n97)\n49\ni=8:\n(49)\n(13\n27\n38\n49\n65\n76\n97)\n监视哨L.R[0]\n图8.1直接插入排序示例\n直接插入排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为0（1)。\n时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作\n都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。\n在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，\n因而时间复杂度为O(n)。\n在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达\n到最大，总的移动次数也达到最大，总的时间复杂度为O(²)。\n平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为\n平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n²/4。\n因此，直接插入排序算法的时间复杂度为O(²)。\n稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置\n发生变化的情况，即直接插入排序是一个稳定的排序算法。\n适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。",
        "related_points": [
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "extension"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0841",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**直接插入排序**\n- **定义**：通过构建有序子序列，逐个将未排序元素插入到正确位置的稳定排序算法。\n- **核心过程**：\n- **初始状态**：首元素视为已排序子序列（如示例中的`(49)`）。\n- **插入步骤**：从第2个元素开始（`i=2`），依次将`L.R[i]`与有序子序列从后向前比较，找到插入位置并移动元素（需**监视哨**`L.R[0]`暂存当前元素）。\n- **终止条件**：完成`n-1`趟插入后，整个序列有序。\n- **性能分析**：\n- **空间复杂度**：**O(1)**（仅需常数辅助空间）。\n- **时间复杂度**：\n- 最好（已有序）：**O(n)**（每趟仅比较1次，无移动）。\n- 最坏（逆序）：**O(n²)**（比较和移动次数均达`n(n-1)/2`）。\n- 平均：**O(n²)**（比较和移动次数约`n²/4`）。\n- **稳定性**：稳定（相同元素不跨位置交换）。\n- **适用性**：\n- 顺序存储（需移动元素）或链式存储（无需移动，仅修改指针）。\n- 适用于小规模数据或基本有序的序列。\n- **快速记忆**：\n- **“扑克牌排序”**：类似整理手牌，逐个插入到已排序部分。\n- **监视哨作用**：避免每次比较时数组越界检查，提升效率。\n- **示例关键步骤**（见图8.1）：\n- `i=5`时：将`76`插入到`(38,49,65,97)`中，需移动`97`后插入。\n- `i=6`时：`13`需插入到子序列最前，引发多次比较与移动。"
    },
    {
        "id": "kc0822",
        "title": "折半插入排序",
        "chapter_id": "08",
        "description": "从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：①从前面的有序子\n表中查找出待插入元素应该被插入的位置：②给插入位置腾出空间，将待插入元素复制到表中的\n插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半\n\n第8章排\n序\n341\n查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，\n可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折\n半查找来实现。确定待插入位置后，就可统一地向后移动元素。\n折半插入排序算法的排序过程举例见本书配套课程，其代码如下：\nvoid InsertSort（ElemType A[l,int n)(\nint i，j,low,high,mid;\nfor（i=2;i<=n;i++）{\n//依次将A[2]～A[n]插入前面的已排序序列\nA[0]=A[i];\n//将A[i]暂存到A[0]\nlow=1;high=i-1;\n//设置折半查找的范围\nwhile(low<=high）{\n//折半查找（默认递增有序）\nmid=(1ow+high)/2;\n/取中间点\nif（A[mid] >A[0]）high=mid-1；//查找左半子表\nelse low=mid+1;\n//查找右半子表\nfor(j=i-1;j>=high+l;--j)\nA[j+1]=A[j];\n/统一后移元素，空出插入位置\nA[high+1]=A[0];\n//插入操作\n命题追踪\n直接插入排序和折半插入排序的比较（2012）\n从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为O(nlog2n)，\n该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，\n它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(r²），但对于数据量不算\n很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。\n折半插入排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "kc0111",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0211",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0212",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0221",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0342",
                "relation_type": "extension"
            },
            {
                "id": "kc0721",
                "relation_type": "extension"
            },
            {
                "id": "kc0722",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0732",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0723",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0823",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**折半插入排序**\n- **定义**：直接插入排序的优化版本，通过**折半查找**确定插入位置，减少比较次数，但保持移动元素操作不变。\n- **核心改进**：\n- 分离比较与移动操作，先通过**二分查找**（`low=1, high=i-1`）定位插入点（`high+1`），再统一后移元素。\n- 仅适用于**顺序表**（数组），因需随机访问支持折半查找。\n- **时间复杂度**：\n- 比较次数：**O(n log n)**（优于直接插入排序的O(n²)）。\n- 移动次数：**O(n²)**（与初始状态相关，与直接插入排序相同）。\n- **稳定性**：稳定（相等元素相对位置不变）。\n- **适用场景**：数据量较小且顺序存储的线性表，对比较开销敏感的场景。\n- **代码要点**：\n```c\nA[0] = A[i];          // 哨兵暂存待插入元素\nwhile (low <= high) { // 折半查找\nif (A[mid] > A[0]) high = mid - 1;\nelse low = mid + 1;\n}\nfor (j = i-1; j >= high+1; --j) A[j+1] = A[j]; // 统一后移\nA[high+1] = A[0];     // 插入\n```\n- **快速记忆**：\n- \"二分找位置，统一挪数据\"\n- 直接插入的优化版，比较次数降为对数级，但移动次数不变。"
    },
    {
        "id": "kc0823",
        "title": "希尔排序",
        "chapter_id": "08",
        "description": "从前面的分析可知，直接插入排序算法的时间复杂度为O（n²)，但若待排序列为“正序”时，\n其时间效率可提高至O（n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔\n排序正是基于这两点分析对直接插入排序进行改进而得来的，也称缩小增量排序。\n命题追踪希尔排序中各子序列采用的排序算法（2015）\n希尔排序的基本思想是：先将待排序表分割成若干形如L[i,i+d,i+2d.·，i+kd]的“特殊”\n子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个\n表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。\n命题追踪根据希尔排序的中间过程判断所采用的增量（2014、2018）\n希尔排序的过程如下：先取一个小于n的增量d，把表中的全部记录分成d组，所有距离为d\n的倍数的记录放在同一组，在各组内进行直接插入排序：然后取第二个增量d<d，重复上述过程，\n直到所取到的d=1，即所有记录已放在同一组中，再进行直接插入排序，此时已经具有较好的局部\n有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0222",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0341",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**希尔排序**\n- **定义**：基于直接插入排序改进的**不稳定**排序算法，通过**增量分组**逐步使序列趋于基本有序，最终完成排序。\n- **核心思想**：\n- **缩小增量**：将序列按增量`d`分割为若干子序列（如`L[i, i+d, i+2d...]`），对每组进行直接插入排序。\n- **逐步收敛**：重复缩小增量（`d₁ > d₂ > ... > 1`），直至增量为1时完成最后一次全局插入排序。\n- **特性**：\n- **时间复杂度**：依赖增量序列，最坏**O(n²)**，优化增量（如Hibbard序列）可达**O(n^(3/2))**。\n- **空间复杂度**：**O(1)**（原地排序）。\n- **关键细节**：\n- **增量选择**：常用序列为`n/2, n/4,...,1`（希尔原始序列），但最优序列尚无定论。\n- **子序列排序**：每组独立进行直接插入排序，利用基本有序时插入排序的高效性（接近**O(n)**）。\n- **应用场景**：中等规模数据、对稳定性无要求的排序任务。\n- **记忆提示**：\n- “分组插排→缩小增量→最终插排”三步走。\n- 增量序列选择直接影响效率，但无需严格最优。"
    },
    {
        "id": "kc0821",
        "title": "节的",
        "chapter_id": "08",
        "description": "关键字为例，假定第一趟取增量d=5，将该序列分成5个子序列，即图中第2行至第6行，分别对\n直接插入排序，结果如第11行所示；最后对整个序列进行一趟直接插入排序，整个排序过程如\n图8.2所示。\n\n342\n2026年数据结构考研复习指导\n[初始关键字]：\n49\n38659776132749\n55\n04\n[49\n13\n38\n27\n65\n49\n97\n55\n76\n0\n第一趟排序结果：\n1327\n49\n5504\n49\n38\n65\n97\n76\n13\n55\n76\n27\n65\n04\n49\n49\n97\n第二趟排序结果：\n13\nt0\n49\n38\n27\n49\n55\n65\n97\n76\n第三趟排序结果：\n04\n13\n27\n38\n49\n49\n5565\n7697\n图8.2希尔排序示例\n希尔排序算法的代码如下：\nvoid ShellSort(ElemType A[l,int n)(\n//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到\nint dk，i，j;\nfor(dk=n/2;dk>=1;dk=dk/2)\n/增量变化（无统一规定）\nfor（i=dk+1;i<=n;++i)\nif(A[i]<A[i-dk]){\n//需将A[i]插入有序增量子表\n//暂存在A[0]\nA[O]=A[i];\nfor(j=i-dk;j>0&&A[0]<A[j];j-=dk)\nA[j+dk]=A[j];\n/记录后移，查找插入的位置\nA[j+dk]=A[0];\n/插入\n希尔排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为0（1)。\n时间效率：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难\n题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度约为O（n3)。\n在最坏情况下希尔排序的时间复杂度为O（n²)。\n稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因\n此希尔排序是一种不稳定的排序算法。例如，图8.2中49与49的相对次序已发生了变化。\n适用性：希尔排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0823",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**希尔排序**\n- **定义**：基于**增量分组**的插入排序改进算法，通过逐步缩小增量对子序列进行插入排序，最终完成整体排序。\n- **核心步骤**：\n1. **增量选择**：初始增量`dk=n/2`，每趟递减至`dk=dk/2`（无统一标准）。\n2. **子序列排序**：对每个增量划分的子序列进行**直接插入排序**（如图8.2中`dk=5→2→1`）。\n3. **最终排序**：当`dk=1`时，对整个序列做一次插入排序，确保完全有序。\n- **代码要点**：\n- 外层循环控制增量`dk`，内层循环实现插入排序（`A[0]`暂存待插入元素）。\n- 插入时通过`j-=dk`在子序列中后移元素。\n- **性能分析**：\n- **空间复杂度**：**O(1)**（仅常数辅助单元）。\n- **时间复杂度**：依赖增量序列，通常为**O(n^1.3)**，最坏**O(n²)**。\n- **稳定性**：**不稳定**（相同关键字可能分到不同子序列，改变相对次序，如图8.2的`49`）。\n- **应用限制**：仅适用于**顺序存储线性表**（因需随机访问子序列）。\n- **记忆提示**：\n- \"缩小增量插入\" → 先粗调后微调。\n- 增量序列选择影响效率，但无最优解。"
    },
    {
        "id": "kc0839",
        "title": ".11.2,1.4.7.5.10.6",
        "chapter_id": "08",
        "description": "第一趟：\n1.3,7.5,2,6.4,9,11,10.8\n第二趟：\n126437581.10.9\n第一趟分组：8,1,6；3,4；9,7；11,5；2,10：间隔为5，排序后组内递增。\n第二趟分组：1,5,4,10：3,2,9,8：7.6,11；间隔为3，排序后组内递增。\n因此，选择选项D。\n二、综合应用题\n01.【解答】\n直接插入排序过程如下。\n初始序列：\n4,5,1,2,6,3\n第一趟：\n4,5,1,2,6,3\n（将5插入{4}）\n第二趟：\n1,4,5,2,6,3\n(将1插入{4,5})\n第三趟：\n1,2,4,5,6,3\n（将2插入{1,4,5}）\n第四趟：\n1,2,4,5,6,3\n（将6插入{1,2,4,5}）\n第五趟：\n1,2,3,4,5,6\n（将3插入{1,2,4,5,6})\n02.【解答】\n原始序列：\n50,26,38,80,70,90,8,30,40,20\n第一趟（增量5）：\n50,8,30,40,20,90,26,38,80,70\n第二趟（增量3）：\n26,8,30,40,20,80,50,38,90,70\n第三趟（增量1)：\n8,20,26,30,38,40, 50, 70, 80, 90\n8.3交换排序\n所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。\n\n第8章排\n序\n347\n基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，\n般很少直接考查，通常会重点考查快速排序算法的相关内容。",
        "related_points": [
            {
                "id": "kc0831",
                "relation_type": "extension"
            },
            {
                "id": "kc0832",
                "relation_type": "extension"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**希尔排序（Shell Sort）**\n- **定义**：改进的插入排序，通过**分组插入**和**逐步缩小增量**实现高效排序。\n- **特性**：\n- **增量序列**：按递减间隔分组（如5→3→1），每组内使用插入排序。\n- **时间复杂度**：依赖增量选择，最好**O(n log n)**，最坏**O(n²)**（如间隔1时退化为插入排序）。\n- **不稳定排序**：相同元素可能因分组跨越交换位置。\n- **关键步骤**：\n1. **第一趟**：大间隔分组（如间隔5），组内排序后序列部分有序。\n2. **第二趟**：缩小间隔（如3），进一步细化排序。\n3. **最后一趟**：间隔为1，完成全局排序。\n- **示例**：\n- 初始序列：`50,26,38,80,70,90,8,30,40,20`\n- 增量5分组：`[50,90], [26,8], [38,30], [80,40], [70,20]` → 组内排序后：`50,8,30,40,20,90,26,38,80,70`\n- 增量1时完成最终排序。\n**直接插入排序**\n- **定义**：逐个将元素插入已排序子序列的合适位置。\n- **特性**：\n- **时间复杂度**：最好**O(n)**（已有序），最坏**O(n²)**（逆序）。\n- **稳定排序**：相等元素不跨位置交换。\n- **示例**：\n- 初始序列：`4,5,1,2,6,3`\n- 第五趟后：`1,2,3,4,5,6`（每次插入后子序列保持有序）。\n**交换排序**\n- **核心思想**：通过比较并交换元素对实现排序，主要包括：\n- **冒泡排序**：相邻元素比较交换，每趟将最大/最小元素“冒泡”到末端。\n- **快速排序**：选定基准（pivot），分区（partition）使左侧≤基准≤右侧，递归处理子序列。\n**快速记忆提示**\n- **希尔排序**：“大间隔粗调→小间隔细调→最后插入”。\n- **插入排序**：“扑克牌理牌法，逐个插入有序区”。\n- **交换排序**：“冒泡≈相邻打架，快排≈分而治之”。"
    },
    {
        "id": "kc0831",
        "title": "冒泡排序",
        "chapter_id": "08",
        "description": "冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序\n（A[i-1]>A[i])，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元\n素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最\n小的元素如气泡一般逐渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。\n下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或\n最大元素）放到了序列的最终位置.…·这样最多做n-1趟冒泡就能把所有元素排好序。\n图8.3所示为冒泡排序的过程，第一趟冒泡时：27<49，不交换；13<27，不交换；76>13，\n交换：97>13，交换：65>13，交换；38>13，交换；49>13，交换。通过第一趟冒泡后，最小\n元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排\n序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。\n49\n13\nB\n3\n3\n13\n3\n38\n49\n27\n27\n27\n27\n27\n65\n38\n49\n38\n38\n38\n38\n97\n65\n38\n49\n49\n49\n49\n76\n97\n65\n49\n49\n49\n49\n13\n76\n97\n65\n65\n65\n65\n27\n27\n76\n97\n76\n76\n76\n49\n49\n49\n76\n97\n97\n97\n初\n第\n第\n第\n第\n第\n最\n始\n二\n三\n一\n五\n终\n状\n趟\n趟\n趟\n趟\n趟\n状\n态\n后\n后\n后\n后\n后\n态\n图8.3\n冒泡排序示例\n冒泡排序算法的代码如下：\nvoid BubbleSort(ElemType A[],int n)(\nfor（inti=0;i<n-l;i++){\nbool flag=false;\n//表示本趟冒泡是否发生交换的标志\nfor(int j=n-1;j>i;j--)\n//一趟冒泡过程\nif(A[j-1]>A[j]){\n//若为逆序\nswap(A[j-1],A[j]);\n//使用封装的swap函数交换?\nflag=true;\nif(flag==false)\nreturn;\n//本趟遍历后没有发生交换，说明表已经有序\n冒泡排序的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为O（1)。\n时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换），\n①本章有多处要两两交换元素，为使代码更简洁，使用函数swap（int&a，int&b），其代码如下：\nint temp=a;a=b;b=temp;\n\n348\n2026年数据结构考研复习指导\n初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，而且每次比\n较后都必须移动元素3次来交换元素位置。这种情况下，\nn(n-1)\n3n(n-1)\n移动次数=\n3（n-i)=\ni=1\n2\n2\n从而，最坏情况下的时间复杂度为 O(n²)，平均时间复杂度为 O(n²)。\n稳定性：i>j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序算法。\n适用性：冒泡排序适用于顺序存储和链式存储的线性表。\n注意\n冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的\n所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置\n到其最终的位置上。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "extension"
            },
            {
                "id": "kc0811",
                "relation_type": "extension"
            },
            {
                "id": "kc0839",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0841",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**冒泡排序**\n- **定义**：通过相邻元素两两比较并交换，使最小（或最大）元素逐渐“浮”到序列顶端（或“沉”到底端）的简单排序算法。\n- **核心思想**：\n- **多趟排序**：每趟从后向前（或从前向后）比较相邻元素，逆序则交换，每趟确定一个元素的最终位置。\n- **提前终止**：若某趟无交换（`flag==false`），说明序列已有序，可提前结束。\n- **特性**：\n- **时间复杂度**：\n- 最好（已有序）：**O(n)**（一趟比较后终止）。\n- 最坏（逆序）：**O(n²)**（需 `n-1` 趟，每趟比较 `n-i` 次）。\n- 平均：**O(n²)**。\n- **空间复杂度**：**O(1)**（原地排序，仅用常数辅助空间）。\n- **稳定性**：稳定（相等元素不交换）。\n- **实现要点**：\n```cpp\nvoid BubbleSort(ElemType A[], int n) {\nfor (int i = 0; i < n-1; i++) {\nbool flag = false;  // 优化：检测是否发生交换\nfor (int j = n-1; j > i; j--)\nif (A[j-1] > A[j]) {\nswap(A[j-1], A[j]);\nflag = true;\n}\nif (!flag) return;  // 提前终止\n}\n}\n```\n- **应用场景**：\n- 小规模数据或接近有序的序列。\n- 适用于顺序存储和链式存储（链式需调整指针而非交换元素）。\n- **关键区别**：\n- 与直接插入排序不同，冒泡排序每趟产生的有序子序列是**全局有序**的（子序列所有元素均小于/大于剩余元素）。\n- **记忆提示**：\n- “气泡上浮”类比最小元素升到顶端，或“石头下沉”最大元素降到底端。\n- **优化标志**：`flag` 避免无效遍历，提升有序序列效率。"
    },
    {
        "id": "kc0832",
        "title": "快速排序",
        "chapter_id": "08",
        "description": "命题追踪快速排序的思想（2024）\n快速排序的基本思想：在待排序表L[l..n]中任取一个元素pivot作为枢轴（或称基准，\n通常取首元素)，通过一趟排序将待排序表划分为独立的两部分L[1..k-1]和L[k+1.n]，使得\nL[1l..k-1]中的所有元素小于pivot，L[k+l..n]中的所有元素大于或等于pivot，则pivot\n放在了其最终位置L（k）上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，\n直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。\n一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针i\n和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。\n指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。\npivot\n49\n38\n65\n97\n76\n13\n27\n49\n指针i从1ow往后搜索找到第-\n个大于枢轴的元素65，将65交换到j所指位置。\n27\n38\n65\n97\n76\n13\n49\n指针j继续往前搜索找到小于枢轴的元素13，将13交换到i所指位置。\n27\n38\n97\n76\n13\n$9\n49\n指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。\n27\n38\n13\n97\n6\n65\n49\n指针」继续往前搜索小于枢轴的元素，直至i==j。\n27\n38\n13\n76\n97\n65\n49\n\n第8章排\n序\n349\n命题追踪\n快速排序的中间过程的分析（2014、2019、2023）\n此时，指针i（==j）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放\n在i所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。\n第一趟后：\n127\n38\n13}\n49\n76\n97\n65\n按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。\n第二趟后：\n113)\n27\n[38)\n49\n149\n65}\n76\n1971\n第三趟后：\n13\n27\n38\n49\n49\n1651\n76\n97\n第四趟后：\n13\n27\n49\n49\n65\n76\n97\n用二叉树的形式描述这个快速排序示例的递归调用过程，如图8.4所示。\n第一层快排处理后：\n9\n第一层快排处理后：\n第二层快排要\n273813\n65926 9\n第二层快排处理后：\n处理的部分：\n第三层快排要\n13\n38\n处理的部分：\n(a)第一层快排处理后\n(b)第二层快排处理后\n第一层快排处理后：\n49\n第一层快排处理后：\n第二层快排处理后：\n第二层快排处理后：\n第三层快排处理后：13\n38\n第三层快排处理后：\n13\n38\n第四层快排要处理的部分：\n65\n第四层快排处理后：\n65\n(c)第三层快排处理后\n(d）第四层快排处理后：最终结果\n图8.4快速排序的递归执行过程\n假设划分算法已知，记为Partition（），返回的是上述的k，则L（k）已放在其最终位置。\n因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：\nif(low<high)(\n//递归跳出的条件\n/lPartition（）就是划分操作，将表A[lowhigh]划分为满足上述条件的两个子表\nint pivotpos=Partition(A，low,high）;/划分\nQuickSort（A，low,pivotpos-1）;//依次对两个子表进行递归排序\nQuickSort(A,pivotpos+l,high);\n命题追踪（算法题）快速排序中划分操作的应用（2016）\n快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总\n以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的\n元素向左移动，使得一趟Partition（）操作后，表中的元素被枢轴一分为二。代码如下：\nint Partition（ElemType A[],int low,int high){ //一趟划分\nElemType pivot=A[low]；//将当前表中第一个元素设为枢轴，对表进行划分\n\n350\n2026年数据结构考研复习指导\nwhile(low<high)(\n//循环跳出条件\nwhile(low<high&&A[high]>=pivot)--high;\nA[low]=A[high]；/将比枢轴小的元素移动到左端\nwhile(low<high&&A[low]<=pivot) ++low;\nA[high]=A[low]；//将比枢轴大的元素移动到右端\nA[low]=pivot;\n/枢轴元素存放到最终位置\nreturn low;\n//返回存放枢轴的最终位置\n快速排序算法的性能分析如下：\n命题追踪）快速排序中递归次数的影响因素分析（2010）\n空间效率：快速排序是递归的，因此需要借助一个递归工作栈来保存每层递归调用的必要信\n息，其容量与递归调用的最大层数一致。最好情况下为O(log2n)：最坏情况下，要进行n-1次递\n归调用，因此栈的深度为 O(n)：平均情况下，栈的深度为O(log2n)。\n时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域\n始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(㎡²)。\n有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如\n从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素：或者随机地\n从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。\n在最理想的状态下，即Partition（）能做到最平衡的划分，得到的两个子问题的大小都不\n可能大于 n/2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog2n)。\n下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。\n稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换\n到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序算法。例如，表L=\n{3,2.2}，经过一趟排序后L={2,2,3}，最终排序序列也是L={2,2,3}，显然，2与2的相对次\n序已发生了变化。\n命题追踪快速排序适合采用的存储方式（2011）\n适用性：快速排序仅适用于顺序存储的线性表。\n注意\n在快速排序算法中，并不产生有序子序列，但每一趟排序后会将上一趟划分的各个无序子表的枢轴（基\n准）元素放到其最终的位置上。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0333",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0839",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**快速排序**\n- **定义**：基于分治策略的排序算法，通过选定枢轴（pivot）将待排序表划分为两个子表，递归排序后合并。\n- **核心思想**：\n- **划分**：选取`pivot`（通常为首元素），将表分为`L[low..k-1]`（元素≤pivot）和`L[k+1..high]`（元素≥pivot），`pivot`置于最终位置`k`。\n- **递归**：对左右子表重复划分直至子表长度为1或0。\n- **划分过程**：\n- 双指针`i`（从`low`开始）、`j`（从`high`开始）交替搜索并交换元素，直至`i==j`时确定`pivot`位置。\n- **代码关键**：\n```c\nint Partition(ElemType A[], int low, int high) {\nElemType pivot = A[low];\nwhile (low < high) {\nwhile (low < high && A[high] >= pivot) --high;\nA[low] = A[high];\nwhile (low < high && A[low] <= pivot) ++low;\nA[high] = A[low];\n}\nA[low] = pivot;\nreturn low;\n}\n```\n- **性能分析**：\n- **时间复杂度**：\n- 最优/平均：**O(n log n)**（平衡划分时）。\n- 最坏：**O(n²)**（表基本有序或逆序，退化为冒泡排序）。\n- **空间复杂度**：\n- 递归栈深度：平均**O(log n)**，最坏**O(n)**。\n- **稳定性**：不稳定（如`{3,2,2}`→`{2,2,3}`）。\n- **优化策略**：\n- **枢轴选择**：三数取中（头、尾、中间元素的中间值）或随机选择。\n- **小规模数据**：切换为插入排序（减少递归开销）。\n- **应用场景**：\n- **适用**：顺序存储的线性表（如数组）。\n- **优势**：平均性能最优的内部排序算法。\n- **记忆提示**：\n- “分治+双指针交替扫描”，递归终止条件为`low >= high`。\n- 每次划分至少确定一个元素（枢轴）的最终位置。"
    },
    {
        "id": "kc0841",
        "title": "简单选择排序",
        "chapter_id": "08",
        "description": "根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为\nL[1..]，第i趟排序即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟排序可以确定\n一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。\n简单选择排序算法的过程较为简单，相关举例见本书配套课程，其代码如下：\nvoid SelectSort(ElemType A[],intn)(\nfor（int i=0;i<n-l;i++）{\n//一共进行n-1趟\nint min=i;\n/记录最小元素位置\nfor（int j=i+1;j<n;j++)\n//在A[i.n-1]中选择最小的元素\nif(A[j]<A[min]） min=j;\n//更新最小元素位置\nif（min!=i) swap(A[i],A[min]);\n//封装的swap（）函数共移动元素3次\n简单选择排序算法的性能分析如下：\n空间效率：仅使用常数个辅助单元，所以空间效率为O（1)。\n时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不\n会超过3（n-1)次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列\n的初始状态无关，始终是n（n-1)/2次，因此时间复杂度始终是O（n²)。\n稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与含有相同关\n键字的元素的相对位置发生改变。例如，表L={2,2,1}，经过一趟排序后L={1,2,2}，最终排\n序序列也是L={1，2，2}，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳\n定的排序算法。\n适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0831",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0842",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**简单选择排序**\n- **定义**：通过每一趟从待排序区间选择最小元素并交换到已排序区间的末尾，逐步完成排序的算法。\n- **特性**：\n- **空间复杂度**：**O(1)**（仅需常数个辅助单元）。\n- **时间复杂度**：始终为**O(n²)**（比较次数固定为`n(n-1)/2`次，移动次数≤`3(n-1)`次）。\n- **稳定性**：**不稳定**（交换可能破坏相同关键字的相对顺序，如`{2,2,1}`→`{1,2,2}`）。\n- **实现要点**：\n- 外层循环控制趟数（`n-1`趟），内层循环在`A[i..n-1]`中寻找最小元素下标`min`。\n- 交换`A[i]`与`A[min]`时，若`min≠i`则调用`swap`（通常需3次元素移动）。\n- **适用场景**：\n- 顺序表或链表（需适配交换操作）。\n- 数据量较小或对移动次数敏感的场景（移动次数少）。\n- **记忆提示**：\n- “选择最小，交换到位，比较固定**O(n²)**”。\n- 不稳定原因：跨位置交换可能颠倒相同元素的原始顺序。"
    },
    {
        "id": "kc0842",
        "title": "堆排序",
        "chapter_id": "08",
        "description": "堆的定义如下，n个关键字序列L[1..n]称为堆，当且仅当该序列满足：\n①L(i)≥L(2i)且L(i)≥L(2i+1）或\n②L(i)≤L(2i)且L(i)≤L(2i+1）(1≤i≤Ln/2」)\n命题追踪堆的性质与特点（2020）\n可以将堆视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆），大根堆的最大元素\n存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件②的堆称为小根\n堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。\n图8.5一个大根堆示意图\n\n第8章排\n序\n359\n最新408统考大纲增加了考点“堆的应用”，堆的应用只有两个：堆排序和优先队列（见本\n节综合题7），优先队列也利用了堆排序的思想，因此本节仅介绍堆排序。\n堆排序的思路很简单：首先将存放在L[1..n]中的n个元素建成初始堆，因为堆本身的特点\n（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时\n根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再\n输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆排序需要解决两个问题：①如\n何将无序序列构造成初始堆？②输出堆顶元素后，如何将剩余元素调整成新的堆？\n命题追踪初始建堆的操作（2018、2021）\n堆排序的关键是构造初始堆。建堆思路是从后往前检查所有分支结点，看是否满足堆的要求，\n若不满口，则对以该分支结点为根的子树进行调整。Ⅱ个结点的完全二叉树，最后一个结点是第\nLn/2」个结点的孩子。对以第Ln/2」个结点为根的子树筛选（对于大根堆，若根结点的关键字小于\n左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点（Ln/2」-1～1）\n为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的\n较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到\n以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。\n如图8.6所示，初始时调整L（4)子树，09<32，交换，交换后满足堆的定义；向前继续调整\nL(3)子树，78<左右孩子的较大者87，交换，交换后满足堆的定义；向前调整L(2)子树，17<左\n右孩子的较大者45，交换后满足堆的定义；向前调整至根结点L（1），53<左右孩子的较大者87，\n交换，交换后破坏了L(3)子树的堆，采用上述方法对L(3)进行调整，53<左右孩子的较大者78,\n交换，至此该完全二叉树满足堆的定义。\n）初始i\n（b)i=\n（c)i=2\n09\n(d)i=1\n(e)结果\n图8.6自下往上逐步调整为大根堆\n命题追踪堆的删除操作及调整操作分析（2015、2024）\n输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进\n行筛选。将09和左右孩子的较大者78交换，交换后破坏了L(3)子树的堆，继续对L(3)子树向下\n筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。\n\n360\n2026年数据结构考研复习指导\n78\n53\n32\n65\n（53）\n32\n（17）\n图8.7输出堆顶元素后再将剩余元素调整成新堆\n下面是建立大根堆的算法：\nvoid BuildMaxHeap(ElemType A[],int len){\nfor（inti=len/2;i>0;i--)\n//从i=[n/2]~1，反复调整堆\nHeadAdjust(A,i,len);\nvoid HeadAdjust(ElemType A[],int k,int len){\n//函数HeadAdjust对以元素k为根的子树进行调整\nA[0]=A[k];\nI/A[0]暂存子树的根结点\nfor（inti=2*k;i<=len;i*=2）{//沿key较大的子结点向下筛选\nif(i<len&&A[i]<A[i+1])\ni++;\n//取key较大的子结点的下标\nif(A[O]>=A[i])break;\n//筛选结束\nelset\nA[k]=A[i];\n/将A[i]调整到双亲结点上\nk=i;\n/修改k值，以便继续向下筛选\nA[k]=A[0];\nI被筛选结点的值放入最终位置\n调整的时间与树高有关，为O(h)。在建含n个元素的堆时，关键字的比较总次数不超过4n，\n时间复杂度为O（n)，这说明可以在线性时间内将一个无序数组建成一个堆。\n下面是堆排序算法：\nvoid HeapSort(ElemType A[l,int len)(\nBuildMaxHeap(A,len);\n//初始建堆\nfor（inti=len;i>1;i--){\n//n-1趟的交换和建堆过程\nSwap(A[i],A[l]);\n//输出堆顶元素（和堆底元素交换）\nHeadAdjust(A,1,i-1);\n//调整，把剩余的i-1个元素整理成堆\n公众号：小兔网盘免费分享无水印PDF\n命题追踪\n堆的插入操作及调整操作分析（2009、2011）\n同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结\n点向上执行调整操作。大根堆的插入操作示例如图8.8所示。\n87\n87\n(a)初始，尾部加63\n（b)父结点关键字32下降\n（c)父结点关键字45下降\n(d)调整完成\n图8.8大根堆的插入操作示例\n\n第8章排序\n361\n命题追踪堆在海量数据中选出最小k个数的应用及效率分析（2022）\n堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大\n小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，\n否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。\n堆排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，所以空间复杂度为O(1)。\n时间效率：建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h)，\n所以在最好、最坏和平均情况下，堆排序的时间复杂度为O(nlog2n)。\n稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种\n不稳定的排序算法。例如，表L={1,2,2}，构造初始堆时可能将2交换到堆顶，此时L={2,1,2}，\n最终排序序列为L={1,2,2}，显然，2与2的相对次序已发生变化。\n适用性：堆排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "kc0112",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0511",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0521",
                "relation_type": "extension"
            },
            {
                "id": "kc0522",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0841",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**堆排序**\n### **定义**\n基于**完全二叉树**的排序算法，利用**堆**（大根堆/小根堆）的性质进行选择排序。\n### **堆的特性**\n1. **大根堆**：每个节点的值 ≥ 子节点的值，根节点为最大值。\n2. **小根堆**：每个节点的值 ≤ 子节点的值，根节点为最小值。\n3. **完全二叉树结构**：可用数组存储，节点`i`的左子节点为`2i`，右子节点为`2i+1`（下标从1开始）。\n### **核心操作**\n1. **建堆（BuildHeap）**\n- **方法**：从最后一个非叶节点（`n/2`）开始，向前依次对每个子树执行**向下调整（Heapify）**。\n- **时间复杂度**：**O(n)**（理论证明比较次数≤4n）。\n- **关键代码**：\n```cpp\nvoid BuildMaxHeap(int A[], int len) {\nfor (int i = len/2; i > 0; i--)\nHeapify(A, i, len);\n}\n```\n2. **向下调整（Heapify）**\n- **步骤**：比较根节点与左右子节点，若不符合堆性质，则与较大（小）子节点交换，递归调整被破坏的子树。\n- **时间复杂度**：**O(log n)**（树高）。\n3. **排序流程**\n- 建堆后，重复交换堆顶与堆底元素，缩小堆范围并重新调整。\n- **代码**：\n```cpp\nvoid HeapSort(int A[], int len) {\nBuildMaxHeap(A, len);\nfor (int i = len; i > 1; i--) {\nswap(A[1], A[i]);\nHeapify(A, 1, i-1);\n}\n}\n```\n### **性能分析**\n- **空间复杂度**：**O(1)**（原地排序）。\n- **时间复杂度**：建堆O(n) + n次调整O(n log n) → **总O(n log n)**。\n- **稳定性**：**不稳定**（交换可能破坏相同元素的相对顺序）。\n### **应用场景**\n1. **Top-K问题**（如1亿数据中找前100大）：\n- 维护大小为K的小根堆，遍历时替换堆顶并调整。\n2. **优先队列**：堆是高效实现优先队列的基础结构。\n### **记忆提示**\n- **建堆从`n/2`开始**：因为叶节点本身已是堆。\n- **堆排序≈选择排序+堆优化**：每次选极值无需全表扫描。\n- **插入操作**：新元素放末尾，向上调整（与父节点比较交换）。\n### **图示类比**\n- **大根堆调整**：像“擂台赛”，根节点必须打败左右子节点，否则让位给胜者。\n- **堆排序流程**：类似“拆积木”，每次拆掉顶层最大块，剩余部分重组。"
    },
    {
        "id": "kc0847",
        "title": "直接调整成堆，则会误选选项C。",
        "chapter_id": "08",
        "description": "21.B\n该序列已调整成大根堆，接下来进行第一次删除操作：删除28后，将5放入堆顶：然后自上而\n下调整。22和20比较，较大者22与5比较，交换：19和8比较，较大者19与5比较，交换。\n5\n22\n19）\n（12）（15\n接下来进行第二次删除操作：删除22后，将15放入堆顶；然后自上而下调整。19和20比\n较，较大者20与15比较，交换；15直接与其仅有的左孩子12比较，不交换。\n15\n20\n5\n(12\n因此，进行两次删除操作后，得到的新堆是20，19，15，5，8,12。\n二、综合应用题\n01.【解答】\n以小根堆为例，堆的特点是双亲结点的关键字必然小于或等于该孩子结点的关键字，而两个\n孩子结点的关键字没有次序规定。在二叉排序树中，每个双亲结点的关键字均大于左子树结点的\n关键字，均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关\n系。这样，当对两种树执行中序遍历后，二叉排序树会得到一个有序的序列，而堆则不一定能得\n到一个有序的序列。\n02.【解答】\n大根堆要求根结点的关键字值既大于或等于左子女的关键字值，又大于或等于右子女的关键\n字值。二叉排序树要求根结点的关键字值大于左子女的关键字值，同时小于右子女的关键字值。\n两者的交集是：根结点的关键字值大于左子女的关键字值。这意味着它是一棵左斜单支树，但大\n根堆要求是完全二叉树，因此最后得到的只能是如下图所示的两个结点的二叉树。\n2\n\n368\n2026年数据结构考研复习指导\n读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子\n是为了体现出排序树与大根堆的区别。\n03.【解答】\n在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才\n能得到前k个最小的元素序列，算法的效率不高。\n冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。\n采用堆排序最合适，对于n个元素的序列，建立初始堆的时间不超过4n，取得第k个最小元素之\n的时间为kn，当k≥5时，通过比较可以得出堆排序最优。\n注意\n求前k个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序。\n04.【解析】\n1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插\n入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。\n0\n88\n90)\n图1插入65后的树形\n88\n90\n图2删除堆顶元素后的树形\n2）父结点的编号为（k-1)/4，第i个孩子的编号为4xk+i，i=1,2,3,4。\n3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有\n关。因此，插入和删除操作的时间复杂度都为O(logmn)，其中n为元素个数。\n05.【解答】\n算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端，\n在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形\n成的结果链表中的结点将按关键字非递减的顺序有序链接。\n单链表的定义如第2章所述，假设它不带表头结点。\nvoid selectSort(LinkedList& L)(\nI对不带表头结点的单链表L执行简单选择排序\nLinkNode *h=L,*p,*g,*r,*s;\nL=NULL;\nwhile(h!=NULL){\n/持续扫描原链表\np=s=h;q=r=NULL;\n//指针s和r记忆最大结点和其前驱；p为工作指针，q为其前驱\n\n第8章排\n序\n369\nwhile(p!=NULL){\n//扫描原链表寻找最大结点s\n(b=!d=s}(eep<-s<eep<-d)\n/找到更大的，记忆它和它的前驱\nut<-d=d!d=b\n//继续寻找\nif(s==h)\nh=h->link;\n//最大结点在原链表前端\nelse\nr->link=s->link;\n//最大结点在原链表表内\ns->link=L;L=s;\nl/结点s插入结果链前端\n06.【解答】\n将顺序表L[1..n］视为一个完全二叉树，扫描所有分支结点，遇到孩子结点的关键字小于根\n结点的关键字时返回false，扫描完后返回true。算法的实现如下：\nbool IsMinHeap(ElemType A[l,int len)(\nif（len%2==0）{\n//len为偶数，有一个单分支结点\nif(A[len/2]>A[len])\n1//判断单分支结点\nreturn false;\nfor（i=len/2-1;i>=1；i--）//判断所有双分支结点\nif(A[i]>A[2*i]1|A[i]>A[2*i+1])\nreturn false;\nelser\n//len为奇数时，没有单分支结点\nfor(i=len/2;i>=1;i--)\n1/判断所有双分支结点\nif(A[i]>A[2*i]l|A[i]>A[2*i+1])\nreturn false;\n?\nreturn true;\n07.【解答】\n1）题目要求整个队列所占用的空间不变，入队操作和出队操作的时间复杂度始终保持为\nO(log2n)，则应采用顺序存储结构，即用数组实现大根堆。\n2）优先队列的数据结构定义如下：\ntypedef struct{\nPriorityQueueElement heap[MAx_SIzE];\n//用数组实现堆\nint size;\n//当前堆中元素的数量\n)PriorityQueue\n3）入队操作：\nvoid enqueue(PriorityQueue*\n*pq,int value,int priority)(\nif(pq->size>=MAx_SIzE){\n队列已满，无法入队；\nreturn;\n将新元素添加到堆的末尾；\n向上调整堆；\n出队操作：\nPriorityQueueElement dequeue(PriorityQueue *pq)(\nif(pq->size==0){\n队列为空时直接退出；\n获取堆顶元素（优先级最高的元素）；\n将堆的最后一个元素放到堆顶；\n\n370\n2026年数据结构考研复习指导\n向下调整堆;\n返回出队元素；\n08.【解答】\n1）算法思想。\n【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。\nforM中的每个元素s\nif（s<A[9]）丢弃A[9]并将s按升序插入A;\n当数据全部扫描完毕，数组A[0]～A[9]保存的就是最小的10个数。\n【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。\nforM中的每个元素s\nif（s<H的堆顶元素）删除堆顶元素并将s插入H;\n当数据全部扫描完毕，堆H中保存的就是最小的10个数。\n2）算法平均情况下的时间复杂度是O(n)，空间复杂度是O(1)。\n8.5归并排序、基数排序和计数排序",
        "related_points": [
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0839",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0842",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [],
        "summry": "**堆（Heap）**\n- **定义**：完全二叉树，满足**堆序性质**（大根堆：父节点≥子节点；小根堆：父节点≤子节点）。\n- **核心操作**：\n- **删除堆顶**：\n1. 用末尾元素替换堆顶。\n2. **自上而下调整**：比较父节点与较大子节点，若违反堆序则交换，递归至叶子。\n- *示例*：删除大根堆顶28后，调整过程为 `5→22→19`，最终堆为 `[22,19,15,5,8,12]`。\n- **插入元素**：\n1. 新元素放末尾。\n2. **自下而上调整**：比较与父节点，若违反堆序则交换，直至根节点。\n- **时间复杂度**：\n- 建堆：**O(n)**（Floyd算法）。\n- 插入/删除：**O(log n)**（树高相关）。\n**堆与二叉排序树（BST）对比**\n- **堆**：中序遍历**无序**，仅保证父子大小关系。\n- **BST**：中序遍历**有序**，左<父<右。\n- *交集*：仅左斜单支树（根>左子）可能同时满足大根堆和BST性质。\n**堆的应用**\n1. **优先队列**：\n- 大根堆实现，入队（插入）和出队（删除堆顶）均为 **O(log n)**。\n- *代码框架*：\n```c\nvoid enqueue(Heap *h, int val) {\nh->heap[++h->size] = val;\nsiftUp(h, h->size);  // 自下而上调整\n}\nint dequeue(Heap *h) {\nswap(h->heap[1], h->heap[h->size--]);\nsiftDown(h, 1);      // 自上而下调整\nreturn h->heap[h->size + 1];\n}\n```\n2. **Top-K问题**：\n- 维护大小为K的堆（最小堆求最大K个，最大堆求最小K个），时间复杂度 **O(n log K)**。\n- *示例*：找最小10个数，用大根堆存储候选，遇更小值替换堆顶并调整。\n**快速记忆**\n- **堆调整**：删除堆顶→末尾补位→自上而下；插入→末尾添加→自下而上。\n- **堆 vs BST**：堆父子无序，BST左右有序；堆用于快速极值操作，BST用于动态排序。"
    },
    {
        "id": "kc0851",
        "title": "归并排序",
        "chapter_id": "08",
        "description": "命题追踪\n二路归并操作的功能（2022）\n归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有\n序表合并成一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表，每个\n子表的长度为1，然后两两归并，得到「n/2|个长度为2或1的有序表；继续两两归并如此重\n复，直到合并成一个长度为n的有序表为止，这种排序算法称为二路归并排序。\n图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。\n初始关键字\n[49]\n[38]\n[65]\n[97]\n[76][13]\n[27]\nL\nL\nL\n第一趟归并后\n[38\n“49]\n[65\n97]\n[13\n76]\n[27]\n#\n第二趟归并后\n[38\n49\n65\n971\n[13\n27\n76]\n第三趟归并后\n[13\n27\n38\n49\n65\n76\n97]\n图8.9\n二路归并排序示例\n命题追踪（算法题）归并排序思想的应用（2011）\nMerge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表\nA[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B\n中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下\n标超出其对应的表长（该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A\n中。算法如下：\nElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));//辅助数组 B\nvoid Merge（ElemType A[],int low,int mid,int high)(\n\n第8章排序\n371\n//表A的两段A[low..mid]和A[mid+1...high]各自有序，将它们合并成一个有序表\nint i,j,k;\nfor(k=low;k<=high;k++)\nB[k]=A[k];\n//将A中所有元素复制到B中\nfor（i=low,j=mid+1,k=i;i<=mid&&j<=high;k++）{\nif(B[i]<=B[j])\n//比较B的两个段中的元素\nA[k]=B[i++];\n/将较小值复制到A中\nelse\nA[k]=B[j++];\nwhile(i<=mid)\nA[k++]=B[i++]；/若第一个表未检测完，复制\nwhile(j<=high)\nA[k++]=B[j++]；//若第二个表未检测完，复制\n注意\n在上面的代码中，最后两个while循环只有一个会执行。\n有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行log2n趟。\n递归形式的二路归并排序算法是基于分治的，其过程如下。\n分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用二路归并排序算法对两\n个子表递归地进行排序。\n合并：合并两个已排序的子表得到排序结果。\nvoid MergeSort(ElemType A[l,int low,int high)(\nif(low<high）(\nint mid=（low+high)/2;\n//从中间划分两个子序列\nMergeSort(A,low,mid);\n/对左侧子序列进行递归排序\nMergeSort(A,mid+l,high);\n//对右侧子序列进行递归排序\nMerge(A,low,mid,high);\n//归并\n命题追踪\n归并排序和插入排序的对比（2017）\n命题追踪\n二路归并比较次数的分析（2024）\n路归并排序算法的性能分析如下：\n空间效率：Merge（）操作中，辅助空间刚好为n个单元，因此算法的空间复杂度为O(n)。\n时间效率：每趟归并的时间复杂度为O（n)，共需进行「1og2n趟归并，因此算法的时间复杂\n度为 O(nlog2n)。\n稳定性：Merge（）操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种\n稳定的排序算法。\n适用性：归并排序适用于顺序存储和链式存储的线性表。\n注意\n一般而言，对于N个元素进行k路归并排序时，排序的趟数m满足k\"=N，从而m=logkN，又考虑到m\n为整数，因此m=「logkV。这和前面的二路归并排序算法是一致的。",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**归并排序**\n- **定义**：基于分治法的稳定排序算法，通过将有序子表逐步合并实现整体有序。核心操作为**二路归并**（将两个有序表合并为一个）。\n- **核心步骤**：\n1. **分解**：将表递归划分为长度为1的子表（天然有序）。\n2. **合并**：调用`Merge()`函数合并相邻有序子表，直至整个表有序。\n- **Merge()实现要点**：\n- 使用辅助数组**B**复制待合并区间（`A[low..high]`）。\n- 双指针遍历两段有序子表（`B[low..mid]`和`B[mid+1..high]`），按序写回原数组。\n- **关键代码**：\n```c\nwhile(i<=mid) A[k++]=B[i++]; // 处理剩余左段\nwhile(j<=high) A[k++]=B[j++]; // 处理剩余右段\n```\n- **性能分析**：\n- **时间复杂度**：**O(n log n)**（每趟归并O(n)，共⌈log₂n⌉趟）。\n- **空间复杂度**：**O(n)**（辅助数组开销）。\n- **稳定性**：稳定（`B[i]<=B[j]`时优先取左段元素）。\n- **应用场景**：\n- 大数据量外部排序（如多路归并）。\n- 链表排序（无需随机访问，合并操作高效）。\n- **对比提示**：\n- **与快排区别**：归并侧重“合”，快排侧重“分”；归并稳定且时间稳定，快排不稳定但常数更优。\n- **递归与非递归**：递归实现直观，非递归可通过控制步长`h`（1→2→4…）迭代合并。\n- **记忆技巧**：\n- “分而治之，先拆后合”。\n- **Merge()双指针≈拉链闭合**，剩余段直接拼接。"
    },
    {
        "id": "kc0852",
        "title": "基数排序",
        "chapter_id": "08",
        "description": "基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大\n\n372\n2026年数据结构考研复习指导\n小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。\n假设长度为n的线性表中每个结点a,的关键字由d元组（k,kg-²，,},k）组成，满足\n0≤k≤r-1（0≤j<n,0≤i≤d-1)。其中kg-为最高位关键字，k²为最低位关键字。\n为实现多关键字排序，通常有两种方法：第一种是最高位优先（MSD）法，按关键字位权重\n递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列：第二种是\n最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列。\n下面描述以r为基数的最低位优先基数排序的过程，在排序过程中，使用r个队列Qo，Q,，\nQ~1。基数排序的过程如下：\n对i=0，1,，d-1，依次做一次分配和收集（其实是一次稳定的排序过程）。\n①分配：开始时，把Ωo,Q,…，Q-各个队列置成空队列，然后依次考察线性表中的每个结\n点a（j=0,1,…，n-1），若a的关键字k=k，就把a放进Qk队列中。\n②收集：把Qo,Q1…,Q-1各个队列中的结点依次首尾相接，得到新的结点序列，从而组成\n新的线性表。\n命题追踪）基数排序的中间过程的分析（2013、2021）\n通常采用链式基数排序，假设对如下10个记录进行排序：\n每个关键字是1000以下的正整数，基数r=10，在排序过程中需借助10个链队列，每个关\n键字由3位子关键字构成一一KK²K’，分别代表百位、十位和个位，一共进行三趟“分配”和“收\n集”操作。第一趟分配用最低位子关键字K?进行，将所有最低位子关键字（个位）相等的记录分\n配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。\nlo]b\n[n]b\nq[2]\nq[3]\n+]b\nq[6]\nq[7]\nq[8]\n[6]b\n086\n063\n184505\n[27809]\n083\n008\n589\n269\n（a）第趟分配后\n930063083184505278008109589269\n（b）第一趟收集后\n图8.10第一趟链式基数排序操作\n第二趟分配用次低位子关键字K进行，将所有次低位子关键字（十位）相等的记录分配到\n同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。\n[o]b\nq[1]\nq[2]\nq[3]\n[+]b\nq[5]\n[9]b\nq[7]\nq[8]\n[6]b\n[505\n930\n063\n278\n083\n08\n269\n184\n601\n589\n(a）第二趟分配后\n505008109930063269278083184589\n（b）第二趟收集后\n图8.11第二趟链式基数排序操作\n\n第8章排\n373\n第三趟分配用最高位子关键字K进行，将所有最高位子关键字（百位）相等的记录分配到\n同一个队列，如图8.12(a)所示，第三趟收集后的结果如图8.12(b)所示，至此整个排序结束。\n[o]b\n[1]b\nq[2]\nq[3]\n[+]b\nq[5]\n[9]b\nq[7]\n[8]b\n[6]b\n008\n[09]\n269\n505\n930\n063\n184\n278\n589\nY\n083\n(a）第三趟分配后\n008063083109184269278505589930\n(b）第三趟收集后\n图8.12第三趟链式基数排序操作\n基数排序算法的性能分析如下。\n空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针），但\n以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r)。\n命题追踪）元素的移动次数与序列初态无关的排序算法（2015）\n时间效率：基数排序需要进行d趟“分配”和”收集”操作。一趟分配需要遍历所有关键字，\n度为O（d（n+r))，它与序列的初始状态无关。\n稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，因此基\n数排序是一种稳定的排序算法。\n适用性：基数排序适用于顺序存储和链式存储的线性表。\n*",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0853",
                "relation_type": "extension"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**基数排序**\n- **定义**：非比较型排序算法，通过**多关键字分配与收集**实现排序，将单逻辑关键字拆分为d位元组（如百位、十位、个位）。\n- **核心思想**：\n- **LSD（最低位优先）**：从最低位到最高位依次分配和收集（常用）。\n- **MSD（最高位优先）**：从最高位到最低位递归划分子序列。\n- **流程**：\n1. **分配**：按当前位值将元素放入对应的**r个队列**（如十进制数字需10个队列）。\n2. **收集**：按队列顺序首尾拼接，形成新序列。\n3. 重复d趟（d为关键字位数）。\n- **性能**：\n- **时间复杂度**：**O(d(n+r))**（d为位数，n为元素数，r为基数，如十进制r=10）。\n- **空间复杂度**：**O(r)**（需r个队列的辅助空间）。\n- **稳定性**：稳定（同值元素保持原始相对顺序）。\n- **适用场景**：\n- 关键字位数固定且范围较小（如整数、字符串）。\n- 适合链式存储（无需随机访问）。\n- **记忆提示**：\n- \"按位分配，队列拼接\"\n- \"LSD从右到左，MSD从左到右\"\n- **示例**：对[930, 063, 083, 184, 505, 278, 008, 109, 589, 269]排序：\n- 个位→十位→百位三趟操作（如图8.10-8.12）。"
    },
    {
        "id": "kc0853",
        "title": "计数排序",
        "chapter_id": "08",
        "description": "命题追踪（算法题）计数排序思想的应用（2013、2015、2018）\n计数排序也是一种不基于比较的排序算法。计数排序的思想是：对每个待排序元素x，统计\n小于x的元素个数，利用该信息就可确定x的最终位置。例如，若有8个元素小于x，则x就排\n在第9号位置上。当有几个元素相同时，该排序方案还需做一定的优化。\n注意\n计数排序并不在统考大纲的范围内，但其排序思想在历年真题中多次涉及。\n在计数排序算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数\n引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：\n命题追踪计数排序相关的思想和代码的分析（2021）\nvoid CountSort(ElemType A[],ElemType B[],int n,int k)(\nint i,c[k];\nfor（i=0;i<k;i++)\nC[i]=0;\n1//初始化计数数组\nfor（i=0;i<n;i++)\n//遍历输入数组，统计每个元素出现的次数\nC[A[i]]++;\nIIC[A[i]]保存的是等于A[i]的元素个数\n\n374\n2026年数据结构考研复习指导\nfor(i=1;i<k;i++)\nC[i]=C[i]+C[i-1];\n//C[x]保存的是小于或等于x的元素个数\nfor（i=n-1;i>=0;i--){\n//从后往前遍历输入数组\nB[C[A[i]]-1]=A[i];\n//将元素A[i]放在输出数组B[]的正确位置上\nC[A[i]]=C[A[i]]-1;\n第一个for循环执行完后，数组c的值初始化为O。第二个for循环遍历输入数组A，若\n个输入元素的值为x，则将C[x]值加1，该for循环执行完后，C[x]中保存的是等于x的元\n素个数。第三个for循环通过累加计算后，C[x］中保存的是小于或等于×的元素个数。第四个\nfor循环从后往前遍历数组A，把每个元素A[i]放入它在输出数组B的正确位置上。若数组A\n中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]\n个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要\n将C[A[i]]减1，这样，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数\n组B中A[i]的前一个位置上。\n假设输入数组A[]={2，4,3，0，2，3}，第二个for循环执行完后，辅助数组c的情况如图8.13(a)\n所示：第三个for循环执行完后，辅助数组c的情况如图8.13（b）所示。图8.13（c)至图8.13（h)分别是\n第四个for循环每迭代一次后，输出数组B和辅助数组c的情况。\n012345\n012345\n012345\n012345\nA2]430|213\nA2|4302|3\nA2]43023\nA214]3|0]213\n01234\n012345\nA3\nA213\n01234\n01234\n01234\n01234\nc102|21\nc111356\nC111346\nc1246\n(a)\n(b)\n(c)\n(d)\n012345\n012345\n012345\n012345\nA2|4302|3\nA2|43023\nA2|43023\n012345\n012345\nB023\nB0233\nB02334\nB022334\n01234\n01234\n01234\n01234\nc01246\nc01121316\nc0121315\nc01135\n(e)\n(f\n(g)\n(h)\n图8.13计数排序的过程\n由上面的过程可知，计数排序的原理是：数组的索引（下标）是递增有序的，通过将序列中\n的元素作为辅助数组的索引，其个数作为值放入辅助数组，遍历辅助数组来排序。\n计数排序算法的性能分析如下。\n空间效率：计数排序是一种用空间换时间的做法。输出数组的长度为n；辅助的计数数组的\n长度为k，空间复杂度为O(n+k)。若不把输出数组视为辅助空间，则空间复杂度为O(k)。\n环所花的时间为O（n)，总时间复杂度为O（n+k)。因此，当k=O(n)时，计数排序的时间复杂度为\nO(n)：但当k>O(nlog2n)时，其效率反而不如一些基于比较的排序（如快速排序、堆排序等）。\n稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对\n位置不会改变，因此计数排序是一种稳定的排序算法。\n适用性：计数排序更适用于顺序存储的线性表。计数排序适用于序列中的元素是整数且元素\n范围（0～k-1）不能太大，否则会造成辅助空间的浪费。\n\n第8章排\n375",
        "related_points": [
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "extension"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**计数排序**\n- **定义**：非比较型整数排序算法，通过统计元素频次确定其有序位置。\n- **核心思想**：\n- 统计每个元素`x`的出现次数，存入辅助数组`C`（`C[x]`为`x`的频次）。\n- 累加`C`数组（`C[x]`变为≤`x`的元素总数），逆向填充输出数组`B`。\n- **关键步骤**：\n1. 初始化计数数组`C[k]`（`k`为元素最大值+1）。\n2. 遍历输入数组`A`，统计频次：`C[A[i]]++`。\n3. 累加`C`：`C[i] += C[i-1]`（此时`C[x]`表示≤`x`的元素数）。\n4. 逆向填充`B`：`B[C[A[i]]-1] = A[i]`，并递减`C[A[i]]`（保证稳定性）。\n- **性能分析**：\n- **时间复杂度**：**O(n+k)**（`n`为元素数，`k`为值域范围）。\n- **空间复杂度**：**O(n+k)**（需输出数组`B`和计数数组`C`）。\n- **特性**：\n- **稳定性**：稳定（逆向填充保持相同元素顺序）。\n- **适用场景**：整数序列且值域范围`k`较小（`k=O(n)`时最优）。\n- **限制**：\n- 值域过大时空间效率低（如`k>>n`）。\n- 仅适用于离散整数（需可映射为数组下标）。\n- **快速记忆**：\n- “统计→累加→逆向填充”三步骤。\n- 稳定性关键：**从后往前遍历**输入数组。"
    },
    {
        "id": "kc0861",
        "title": "内部排序算法的比较",
        "chapter_id": "08",
        "description": "前面讨论的排序算法很多，对各种排序算法的比较是考研常考的内容。一般基于五个因素进\n行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。\n命题追踪各种排序算法的特点、比较和适用场景（2017、2020、2022）\n从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为\nO(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的\n数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据\n结构，可以在线性时间内完成建堆，且在O(nlog2n)内完成排序过程。快速排序基于分治的思想，\n虽然最坏情况下的时间复杂度会达到O(n²)，但快速排序的平均性能可以达到O(nlog2n)，在实际\n应用中常常优于其他排序算法。归并排序同样基于分治的思想，但其分割子序列与初始序列的排\n列无关，因此它的最好、最坏和平均时间复杂度均为O(mlog2n)。\n丛空问复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数\n个辅助空间。快速排序需要借助一个递归工作栈，平均大小为O(log2n)，当然在最坏情况下可能\n会增长到O（m)。二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为O（n)，\n虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。\n命题追踪排序算法的稳定性判断及改进（2021、2023）\n从稳定性看：插入排序、冒泡排序、归并排序和基数排序是稳定的排序算法，而简单选择排\n序、快速排序、希尔排序和堆排序都是不稳定的排序算法。平均时间复杂度为O(nlog2n)的稳定排\n序算法只有归并排序，对于不稳定的排序算法，只需举出一个不稳定的实例即可。对于排序算法\n的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。\n命题追踪更适合采用顺序存储的排序算法（2017）\n从适用性看：折半插入排序、希尔排序、快速排序和堆排序适用于顺序存储。直接插入排序、\n\n第8章排\n序\n381\n冒泡排序、简单选择排序、归并排序和基数排序既适用于顺序存储，又适用于链式存储。\n命题追踪\n根据排序的中间过程判断所采用的排序算法（2009、2010）\n从过程特征看：采用不同的排序算法，在一趟或几趟处理后的排序结果通常是不同的，考研\n生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等。\n的复杂度，因为希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。\n表8.1各种排序算法的性质\n算法种类\n时间复杂度\n空间复杂度\n是否稳定\n最好情况\n平均情况\n最坏情况\n直接插入排序\nO(n)\n(u)o\nO(n)\n0(1)\n是\n冒泡排序\nO(n)\nO(n²)\n0(n²)\n0(1)\n是\n简单选择排序\nO(n²)\nO(n²)\nO(n²)\n0(1)\n否\n希尔排序\n0(1)\n否\n快速排序\nO(nlog2n)\nO(nlog2n)\nO(nr²)\nO(log2n)\n否\n堆排序\nO(nlogan)\nO(nlog2n)\nO(nlogan)\n0(1)\n香\n路归并排序\nO(nlog2n)\nO(nlog2n)\nO(nlog2n)\nO(n)\n是\n基数排序\nO(d(n+r)\nO(d(n+r))\nO(d(n+r))\n(0)0\n是",
        "related_points": [
            {
                "id": "kc0121",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0122",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0822",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0823",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0839",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0831",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0832",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0841",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0842",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0853",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**内部排序算法的比较**\n### **1. 时间复杂度对比**\n- **O(n²)类**：\n- **直接插入排序**、**冒泡排序**：平均和最坏均为O(n²)，最好情况（已有序）为O(n)。\n- **简单选择排序**：始终O(n²)，与初始状态无关。\n- **O(n log n)类**：\n- **快速排序**：平均O(n log n)，最坏（有序时）O(n²)，实际应用最快。\n- **堆排序**：建堆O(n)，排序O(n log n)，始终稳定。\n- **归并排序**：最好/最坏/平均均为O(n log n)。\n- **其他**：\n- **希尔排序**：介于O(n)~O(n²)，依赖增量序列，无精确渐近时间。\n- **基数排序**：O(d(n+r))，d为位数，r为基数。\n### **2. 空间复杂度对比**\n- **O(1)**：插入、冒泡、选择、希尔、堆排序。\n- **O(log n)**：快速排序（递归栈）。\n- **O(n)**：归并排序（辅助数组）、基数排序（桶空间）。\n### **3. 稳定性分析**\n- **稳定算法**：直接插入、冒泡、归并、基数排序（相同元素相对位置不变）。\n- **不稳定算法**：选择、快速、希尔、堆排序（存在交换或跳跃移动）。\n### **4. 适用性**\n- **顺序存储**：折半插入、希尔、快速、堆排序（需随机访问）。\n- **顺序/链式存储**：直接插入、冒泡、选择、归并、基数排序。\n### **5. 过程特征**\n- **快速排序**：每趟确定一个元素最终位置（枢轴）。\n- **堆排序**：每趟输出堆顶（当前最大/最小值）。\n- **冒泡排序**：每趟将最大元素“浮”到末尾。\n### **快速记忆提示**\n- **稳定算法**：插冒归基（谐音“插帽归基”）。\n- **O(n log n)不稳定**：快排、堆排；**稳定**：归并。\n- **空间换时间**：归并排序（O(n)辅助空间）。\n（注：具体参数对比可参考表8.1，实际应用优先考虑快速排序或归并排序。）"
    },
    {
        "id": "kc0862",
        "title": "",
        "chapter_id": "08",
        "description": "内部排序算法的应用\n通常情况，对排序算法的比较和应用应考虑以下情况。\n命题追踪）选取排序算法时需要考虑的因素（2019）\n1.选取排序算法需要考虑的因素\n1）待排序的元素个数n。\n2）待排序的元素的初始状态。\n3）关键字的结构及其分布情况。\n4）稳定性的要求。\n5）存储结构及辅助空间的大小限制等。\n2.排序算法小结\n1）若n较小，可采用直接插入排序或简单选择排序。直接插入排序所需的记录移动次数较\n简单选择排序的多，因此当记录本身信息量较大时，用简单选择排序较好。\n2）若n较大，应采用时间复杂度为O（nlog2n）的排序算法：快速排序、堆排序或归并排序。\n当待排序的关键字随机分布时，快速排序被认为是目前基于比较的内部排序算法中最好\n的算法。堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能的最坏情况，\n这两种排序都是不稳定的。若要求稳定且时间复杂度为O（nlog2n)，可选用归并排序。\n3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。\n4）在基于比较的排序算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，\n\n382\n2026年数据结构考研复习指导\n因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机\n分布时，任何借助于“比较”的排序算法，至少需要O（nlog2n)的时间。\n5）若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。\n6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。",
        "related_points": [
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc086597",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0821",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0831",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0832",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0841",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0853",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**内部排序算法的应用**\n- **选取因素**：\n1. **元素数量**（`n`）：决定算法的时间复杂度选择。\n2. **初始状态**：是否基本有序影响算法效率（如冒泡排序对有序序列最优）。\n3. **关键字结构**：分布是否随机或可分解（如基数排序需关键字可分解）。\n4. **稳定性**：是否要求相等元素的相对顺序不变（如归并排序稳定，快排不稳定）。\n5. **存储限制**：辅助空间需求（如堆排序**O(1)**，归并排序**O(n)**）。\n- **算法选择策略**：\n1. **小规模数据**（`n`较小）：\n- **直接插入排序**：移动次数多，适合记录信息量小的场景。\n- **简单选择排序**：移动次数少，适合记录信息量大的场景。\n2. **大规模数据**（`n`较大）：\n- **快速排序**：平均**O(n log n)**，关键字随机分布时最优（但最坏**O(n²)**）。\n- **堆排序**：空间**O(1)**且无最坏情况，但不稳定。\n- **归并排序**：稳定且**O(n log n)**，但需额外空间。\n3. **基本有序序列**：直接插入排序或冒泡排序（**O(n)**~**O(n²)**）。\n4. **关键字位数少且可分解**：基数排序（**O(d(n+r))**，`d`为位数，`r`为基数）。\n5. **大记录信息量**：采用链表存储减少移动开销（如链式基数排序）。\n- **理论界限**：\n- 基于比较的排序至少需要**O(n log n)**时间（通过判定树模型证明）。\n- **记忆提示**：\n- **小规模选简单，大规模用分治**（快排/堆排/归并）。\n- **有序用插入，随机用快排，稳定选归并，大数用基数**。"
    },
    {
        "id": "kc0871",
        "title": "外部排序的基本概念",
        "chapter_id": "08",
        "description": "前面介绍过的排序算法都是在内存中进行的（称为内部排序）。而在许多应用中，经常需要\n对大文件进行排序，因为文件中的记录很多，无法将整个文件复制进内存中进行排序。因此，需\n要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过\n程中需要多次进行内存和外存之间的交换。这种排序算法就称为外部排序。",
        "related_points": [
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**外部排序**\n- **定义**：处理超大规模数据（无法全部载入内存）的排序方法，通过分批次调入内存排序并多次内存-外存交换完成整体排序。\n- **核心原理**：\n- **分阶段处理**：将大文件分割为若干能在内存中排序的子块（称为**归并段**），每个归并段内部使用**内部排序**（如快速排序）处理。\n- **归并阶段**：通过多路归并（如2路或k路）将有序归并段逐步合并为最终有序文件，减少磁盘I/O次数。\n- **关键特性**：\n- **I/O效率主导**：性能主要取决于磁盘读写次数，而非CPU时间（如**归并趟数=⌈logₖ(m)⌉**，其中m为初始归并段数，k为归并路数）。\n- **缓冲优化**：使用输入/输出缓冲区减少实际I/O操作（如预读下一块数据）。\n- **典型应用**：数据库大型表排序、日志文件处理、科学计算数据集。\n- **快速记忆**：\n- **“分治+归并”**：先切块排序，再逐步合并。\n- **k路归并≈败者树**：优化k路比较效率至**O(log k)**。"
    },
    {
        "id": "kc0872",
        "title": "外部排序的方法",
        "chapter_id": "08",
        "description": "文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘\n读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），因此\n在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。\n命题追踪）对大文件排序时使用的排序算法（2016）\n外部排序通常采用归并排序算法。它包括两个阶段：①根据内存缓冲区大小，将外存上的文\n件分成若干长度为（的子文件，依次读入内存并利用内部排序算法对它们进行排序，并将排序后\n得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串；②对这些归并段进行逐趟\n\n388\n2026年数据结构考研复习指导\n归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。\n例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排\n序得到8个初始归并段R1～R8，每段都含250条记录。然后对该文件做如图8.15所示的两两归\n并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个\n输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出\n缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1）中，再清空输出缓冲区，\n继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下\n块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。\n当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上\n趟的结果R1和R2'、R3'和R4'两两归并，这又是一趟归并。最后把R1\"和R2\"两个归并段归并，\n得到最终的有序文件，一共进行了3趟归并。\n输入缓冲区1\n输出缓冲区\nRI\n输入缓冲区2\n有序文件\n图8.14\n二路归并\n图8.15二路归并的排序过程\n在外部排序中实现两两归并时，不可能将两个有序段及归并结果段同时存放在内存中，因此\n需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：\n外部排序的总时间=内部排序的时间+外存信息读/写的时间+内部归并的时间\n显然，外存信息读/写的时间远大于内部排序和内部归并的时间，因此应着力减少1/O次数。\n外存信息的读/写是以“磁盘块”为单位的，因此可知每趟归并需进行16次读和16次写，3趟归\n并加上内部排序时所需进行的读/写，使得总共需进行32×3+32=128次读/写。\n若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至32×2+32=96。\n因此，增大归并路数，可减少归并趟数，进而减少总的磁盘1/0次数，如图8.16所示。\nRL\nR2\nR3\nR4\nR\nR6R7R8\nRI'\nR2'\n有序文件\n图8.164路归并的排序过程\n一般地，对r个初始归并段，做k路归并（每趟将k个或k个以下的有序子文件归并成一个\n有序子文件）。第一趟可将r个初始归并段归并为r/k个归并段，以后每趟归并将m个归并段归\n并成[m/k个归并段，直至最后形成一个大的归并段为止。树的高度-1=「logkr=归并趟数S。可\n见，只要增大归并路数k，或减少初始归并段个数r，都能减少归并趟数S，进而减少读/写磁盘的\n次数，达到提高外部排序速度的目的。",
        "related_points": [
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**外部排序**\n- **定义**：处理超大规模数据（无法全部载入内存）的排序算法，核心是通过**归并排序**分阶段处理磁盘数据，减少I/O操作次数。\n- **核心思想**：\n- **阶段1（生成归并段）**：将文件分割为若干子文件（长度≤内存缓冲区大小），读入内存后用内部排序（如快排）排序后写回磁盘，形成有序的**归并段**（顺串）。\n- **阶段2（多路归并）**：逐趟归并归并段，使用**k路归并**（如二路、四路）逐步合并为全局有序文件。\n- **关键优化**：\n- **减少I/O次数**：外存读写时间主导性能，归并趟数 `S = ⌈logₖr⌉`（`r`为初始归并段数，`k`为归并路数），增大`k`或减少`r`可降低`S`。\n- **缓冲区管理**：内存划分为输入/输出缓冲区，交替读写磁盘块（如二路归并需两个输入缓冲区+一个输出缓冲区）。\n- **示例计算**：\n- 2000记录文件，块容量125记录，8个初始归并段：\n- **二路归并**：3趟归并，总I/O次数=128次（读+写）。\n- **四路归并**：2趟归并，总I/O次数=96次（效率提升25%）。\n- **应用场景**：数据库大表排序、日志文件处理等海量数据场景。\n- **快速记忆**：\n- **阶段分治**：内存排序→磁盘归并。\n- **优化关键**：`k↑`或`r↓`→`S↓`→I/O↓。"
    },
    {
        "id": "kc0873",
        "title": "多路平衡归并与败者树",
        "chapter_id": "08",
        "description": "增加归并路数k能减少归并趟数S，进而减少I/O次数。然而，增加归并路数k时，内\n部归并的时间将增加。做内部归并时，在k个元素中选择关键字最小的元素需要k-1次比较。\n\n第8章排序\n389\n每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并总共需要的比较次数为\nS(n- 1)(k- 1)=[1ogzr (n- 1)(k- 1)=[1og2r(n- 1)(k - 1)/[1og2k]\n式中，（k-1）/log2k随k增长而增长，因此内部归并时间亦随k的增长而增长。这将抵消因增大\nk而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。\n为了使内部归并不受k的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，\n可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的元素，内\n部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比\n较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。\n命题追踪败者树的实现原理（2024）\n如图8.17（a）所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，\n此时，根结点ls[0]所指的段的关键字最小。对于k路归并，初始构造败者树需要k-1次比较。\nb3中的6输出后，将下一关键字填入b3，继续比较。\n12\n15\n12\n20\n40\n(a)\n(b)\n图8.17实现5路归并的败者树\n因为k路归并的败者树深度为「log2k+1，所以从k个记录中选择最小关键字，仅需进行[log2k]\n次比较。因此总的比较次数约为\nS(n-1) [1og2k]=[logkr](n-1)[1og2k]=(n-1)[1og2r]\n可见，使用败者树后，内部归并的比较次数与k无关了。因此，只要内存空间允许，增大归\n并路数k将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。\n值得说明的是，归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓\n冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外\n存交换数据的次数增大。当k值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。",
        "related_points": [
            {
                "id": "kc0847",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0861",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**多路平衡归并与败者树**\n- **核心作用**：通过增加归并路数 **k** 减少外存I/O次数（归并趟数 **S=⌈logₖr⌉**），但需解决内部归并时比较次数随 **k** 增长的问题。\n- **传统归并瓶颈**：\n- 每次从 **k** 个元素选最小需 **k-1** 次比较，总比较次数为 **S(n-1)(k-1)**，随 **k** 增大效率降低。\n- **败者树原理**：\n- **结构**：完全二叉树，叶节点存储归并段当前元素，内部节点记录子树中的“败者”（较大值），胜者向上传递。\n- **优势**：\n- 初始建树需 **k-1** 次比较，后续每次调整仅需 **⌈log₂k⌉** 次比较（树高相关）。\n- 总比较次数优化为 **(n-1)⌈log₂r⌉**，与 **k** 无关。\n- **关键公式**：\n- 归并趟数：**S=⌈logₖr⌉**（**r** 为初始归并段数）。\n- 比较次数（败者树）：**S(n-1)⌈log₂k⌉≈(n-1)⌈log₂r⌉**。\n- **应用场景**：外部排序（如大数据文件处理），需权衡 **k** 值与缓冲区大小。\n- **限制条件**：\n- **k** 过大导致缓冲区容量不足，反而增加I/O次数（内存-外存交换频繁）。\n- **快速记忆**：\n- 败者树≈“比武擂台”，败者留名，胜者晋级，最小值直达根节点。\n- 多路归并优先选败者树，**k** 值增大但比较次数不增。"
    },
    {
        "id": "kc0874",
        "title": "置换-选择排序（生成初始归并段）",
        "chapter_id": "08",
        "description": "从",
        "related_points": [
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "extension"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**置换-选择排序（生成初始归并段）**\n- **定义**：一种用于外部排序的算法，通过动态选择最小元素生成较长的初始归并段，减少归并趟数。\n- **原理**：\n- 从输入缓冲区读取数据到工作区（内存），工作区容量为`w`。\n- 每次输出当前工作区中的**最小元素**（需≥上一个输出的元素），并用新元素填充空缺。\n- 若新元素无法维持有序性（<上一个输出），则标记为“无效”，当前归并段终止，开始新归并段。\n- **关键点**：\n- **归并段长度**：平均长度为`2w`（优于简单排序的固定`w`）。\n- **时间复杂度**：生成所有归并段为**O(n log w)**，`n`为总元素数。\n- **数据结构**：通常用**最小堆**维护工作区，保证高效取最小元素。\n- **应用场景**：外部排序（如大文件排序），减少磁盘I/O次数。\n- **记忆提示**：“动态选择最小，堆来帮忙；归并段变长，趟数下降”。\n（注：若需图示说明工作区填充/置换过程，可补充流程图。）"
    },
    {
        "id": "kc0872",
        "title": "节的讨论可知，减少初始归并段个数r也可以减少归并趟数S。若总的记录个数为n，",
        "chapter_id": "08",
        "description": "每个归并段的长度为（，则归并段的个数r=「n/C]。采用内部排序算法得到的各个初始归并段长\n①本节中出现的关于比较次数的公式只是为了帮助读者理解相关原理，无须死记硬背。\n\n390\n2026年数据结构考研复习指导\n度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的\n方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。\n命题追踪置换-选择排序生成初始归并段的实例（2023）\n设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状\n态为空，WA可容纳w个记录。置换-选择算法的步骤如下：\n1）从FI输入w个记录到工作区WA。\n2）从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。\n3）将MINIMAX记录输出到FO中去。\n4）若FI不空，则从FI输入下一个记录到WA中。\n5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为\n新的MINIMAX记录。\n6）重复3）～5），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并\n段，输出一个归并段的结束标志到FO中去。\n7）重复2）～6），直至WA为空。由此得到全部初始归并段。\n设待排文件FI={17,21,05,44,10,12,56,32,29}，WA容量为3，排序过程如表8.2所示。\n表8.2置换-选择排序过程示例\n输出文件FO\n工作区WA\n输入文件FI\n17,21,05,44,10,12,56,32,29\n17215\n44,10,12,56,32,29\n05\n2144\n10,12,56,32,29\n0517\n1044\n12,56, 32,29\n1012\n05 1721\n56,32, 29\n10 12\n32,29\n05172144\n0517214456\n10 1232\n29\n0517214456#\n1232\n29\n10\n2932\n一\n10 12\n29\n32\n一\n10 1229\n10 122932\n一\n一\n10122932#\n上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。",
        "related_points": [
            {
                "id": "kc0847",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "extension"
            },
            {
                "id": "kc0874",
                "relation_type": "extension"
            },
            {
                "id": "kc0875",
                "relation_type": "extension"
            }
        ],
        "questions": [],
        "summry": "**置换-选择算法**\n- **定义**：用于外部排序中生成更长初始归并段的算法，通过动态选择记录减少归并段数量，从而降低归并趟数。\n- **核心原理**：\n1. **工作区（WA）**：容量为`w`，暂存从输入文件（FI）读取的记录。\n2. **MINIMAX记录**：当前WA中关键字最小的记录（需大于上一输出的MINIMAX值），输出到归并段文件（FO）。\n3. **动态更新**：每输出一个记录后，从FI补充新记录到WA，重新选择满足条件的MINIMAX记录。\n4. **终止条件**：WA中无满足条件的记录时，当前归并段结束，生成新归并段。\n- **关键步骤**：\n1. 初始化WA（填充`w`个记录）。\n2. 选择并输出MINIMAX记录。\n3. 补充FI记录到WA，更新MINIMAX（需关键字 > 上一MINIMAX）。\n4. 重复直至WA无法选出MINIMAX，标记归并段结束。\n- **实现要点**：\n- **败者树**：高效选择MINIMAX记录（时间复杂度**O(log w)**）。\n- **归并段长度**：通常大于`w`（传统方法归并段长度固定为`w`）。\n- **示例**（WA容量=3）：\n- 输入FI: `[17,21,05,44,10,12,...]`\n- 首归并段输出：`05,17,21,44,56`（长度5 > 3）。\n- **优势**：\n- 减少初始归并段数量`r`，从而降低归并趟数`S=⌈logₖr⌉`（`k`为归并路数）。\n- **局限**：依赖WA大小，需额外维护败者树结构。\n- **记忆提示**：\n- \"置换-选择≈动态筛选：输出最小可行记录，补充新记录，直到无法继续\"。\n- 对比传统方法：归并段长度固定，置换-选择可生成变长归并段。"
    },
    {
        "id": "kc0875",
        "title": "最佳归并树",
        "chapter_id": "08",
        "description": "文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等\n的初始归并段的归并顺序，使得1/O次数最少。假设由置换-选择排序得到9个初始归并段，其长\n度（记录数）依次为9,30,12，18,3,17.2，6,24。现做3路平衡归并，其归并树如图8.18所示。\n在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根\n的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的\n归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数=2xWPL=484。\n\n第8章排\n391\n38\n121\n图8.183路平衡归并的归并树\n命题追踪构造三叉哈夫曼树及相关的分析和计算（2013）\n显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O次数）亦不同。为了优化\n归并树的WPL，可以将哈夫曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始\n归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的1/O次数最少的最佳归并树。\n上述9个初始归并段可构造成一棵如图8.19所示的归并树，按此树进行归并，仅需对外存进行\n446次读/写，这棵归并树称为最佳归并树。\n121\n图8.193路平衡归并的最佳归并树\n图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归\n并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，\n即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的1/0次数为386。显然，\n这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格k叉树（也称正则k叉树）\n时，则需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。因此，\n最佳归并树应如图8.20所示，此时的1/0次数仅为326。\n图8.208个归并段的最佳归并树\n如何判定添加虚段的数目？\n设度为0的结点有no个，度为k的结点有nk个，归并树的结点总数为n，则有：\nn=nk+no\n（总结点数=度为k的结点数+度为0的结点数）\nn=knk+1\n（总结点数=所有结点的度数之和+1）\n因此，对严格k叉树有no=(k-1)nk+1，由此可得nk=(no-1)/(k-1)。\n若(n。-1)%(k-1)=0（%为取模运算)，则说明这ng个叶结点（初始归并段）正好可以\n构造k叉归并树。此时，内结点有nk个。\n若(ng-1)%（k-1)=u≠0，则说明对于这no个叶结点，其中有u个多余，不能包含在k\n叉归并树中。为构造包含所有no个初始归并段的k叉归并树，应在原有nk个内结点的\n\n392\n2026年数据结构考研复习指导\n基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加\n上刚才多出的u个叶结点，即再加上k-u-1个空归并段，就可以建立归并树。\n命题追踪实现最佳归并时需补充的虚段数量的分析（2019）\n以图8.20为例，用8个归并段构成3叉树，（ng-1)%(k-1)=(8-1)%(3-1)=1，说明7个归\n并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子）。为此，将叶子5变成\n一个内结点，再添加3-1-1=1个空归并段，就可以构成一棵严格3叉树。",
        "related_points": [
            {
                "id": "kc0513",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0551",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0811",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0847",
                "relation_type": "extension"
            },
            {
                "id": "kc0851",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0852",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0862",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0871",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0873",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0874",
                "relation_type": "prerequisite"
            },
            {
                "id": "kc0872",
                "relation_type": "prerequisite"
            }
        ],
        "questions": [],
        "summry": "**最佳归并树**\n- **定义**：基于哈夫曼树思想的m叉归并树，用于组织长度不等的初始归并段，使归并过程中的I/O次数（总读记录数=2×WPL）最少。\n- **核心原理**：\n- **贪心策略**：让记录数少的归并段优先归并，减少其重复参与归并的趟数。\n- **严格k叉树**：归并树需满足非叶结点度为k（如3路归并则度为3），否则需补**虚段**（长度为0的归并段）使其正则化。\n- **虚段判定公式**：\n- 设初始归并段数=no，k路归并时：\n- 若 `(no-1)%(k-1)=0`：无需补虚段，直接构造严格k叉树。\n- 若余数 `u≠0`：需补 `(k-1-u)` 个虚段（确保 `(no+虚段数-1)%(k-1)=0`）。\n- **示例**：\n- 8个归并段做3路归并：`(8-1)%(3-1)=1`，需补 `(3-1-1)=1` 个虚段。\n- 9个归并段做3路归并：无需补虚段（`(9-1)%(3-1)=0`）。\n- **关键计算**：\n- **WPL**（带权路径长度）= 所有归并段长度 × 其路径长度（归并趟数）之和。\n- **I/O次数** = `2×WPL`（读+写）。\n- **应用场景**：外排序中优化多阶段归并的磁盘访问效率。\n- **记忆提示**：\n- **“短先合并”**：类比哈夫曼编码，最短路径优先。\n- **“缺虚补零”**：通过虚段将树补成严格k叉树。"
    }
]