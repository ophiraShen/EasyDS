[
    {
        "id": "kc0811",
        "title": "排序的定义",
        "chapter_id": "c08",
        "description": "排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，\n通常希望计算机中的表是按关键字有序的。排序的确切定义如下：\n输入：n个记录R，R2,.…，R，对应的关键字为k，k2.…，kn。\n输出：输入序列的一个重排R'，R'，…,R”，使得K≤k≤.·≤k’（其中“≤”可以换成其他\n的比较大小的符号）。\n算法的稳定性。若待排序表中有两个元素 R,和 R，其对应的关键字相同，即key,=key，且\n在排序前R在R的前面，若使用某一排序算法排序后，R仍然在R的前面，则称这个排序算法\n是稳定的，否则称这个排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一\n个算法的优劣，它主要是对算法的性质进行描述。若待排序表中的关键字不允许重复，排序结果\n是唯一的，则对于排序算法的选择，稳定与否无关紧要。\n注意\n对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。\n在排序过程中，根据数据元素是否完全存放在内存中，可将排序算法分为两类：①内部排序，\n是指在排序期间元素全部存放在内存中的排序：②外部排序，是指在排序期间元素无法全部同时\n存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。\n一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关\n键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部\n排序算法都要基于比较操作，事实上，基数排序就不基于比较操作。\n每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出\n一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序\n和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂\n度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。\n注意\n大多数的内部排序算法都更适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0821",
        "title": "直接插入排序?",
        "chapter_id": "c08",
        "description": "过程中，待排序表L[1..n］在某次排序过程中的某一时刻状态如下：\n有序序列L[1..i-1]L（i）无序序列L[i+1..n]\n要将元素L（i)插入已有序的子序列L[1..i-1]，需要执行以下操作（为避免混淆，下面用\nL[表示一个表，而用L（）表示一个元素）：\n1）查找出L（i）在L[1..i-1]中的插入位置k。\n2）将L[k..i-1]中的所有元素依次后移一个位置。\n3）将L(i)复制到L(k)。\n为了实现对L[1..n]的排序，可以将L（2）～L（n）依次插入前面已排好序的子序列，初始L[1]\n上通常采用原地排序（空间复杂度为0（1)），因而在从后往前的比较过程中，需要反复把已排序\n元素逐步向后挪位，为新元素提供插入空间。\n①在本书中，凡是没有特殊注明的，通常默认排序结果为非递减有序序列。\n\n340\n2026年数据结构考研复习指导\n下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）。\nvoid InsertSort(ElemType A[],int n)(\nint i,j;\nfor(i=2;i<=n;i++)\n//依次将A[2]~A[n]插入前面已排序序列\nif(A[i]<A[i-1]){\n若A[i]关键码小于其前驱，将A[i]插入有序表\nA[O]=A[i];\n/复制为哨兵，A[0]不存放元素\nfor（j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置\nA[j+1]=A[j];\n//向后挪位\nA[j+1]=A[0];\n/复制到插入位置\n假定初始序列为49，3",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc086597",
        "title": "，76.13,27.49，初始时49可以视为一个已排好序的子序列，",
        "chapter_id": "c08",
        "description": "按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。\n[初始关键字]：\n(49)\n65\n97\n76\n13\n27\n49\ni=2:\n(38)\n49)\n97\n76\n13\n27\n49\ni=3:\n(65)\n(38\n49\n65)\n97\n76\n13\n27\n49\ni=4:\n(97)\n(38\n49\n65\n97)\n76\n13\n27\n49\ni=5:\n(76)\n(38\n49\n65\n76\n97)\n13\n27\n49\n(1#\ni=6:\n38\n49\n65\n(13)\n97)\n27\n49\n#\ni=7:\n(27)\n(13\n38\n49\n65\n76\n97)\n49\ni=8:\n(49)\n(13\n27\n38\n49\n65\n76\n97)\n监视哨L.R[0]\n图8.1直接插入排序示例\n直接插入排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为0（1)。\n时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作\n都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。\n在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，\n因而时间复杂度为O(n)。\n在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达\n到最大，总的移动次数也达到最大，总的时间复杂度为O(²)。\n平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为\n平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n²/4。\n因此，直接插入排序算法的时间复杂度为O(²)。\n稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置\n发生变化的情况，即直接插入排序是一个稳定的排序算法。\n适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0822",
        "title": "折半插入排序",
        "chapter_id": "c08",
        "description": "从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：①从前面的有序子\n表中查找出待插入元素应该被插入的位置：②给插入位置腾出空间，将待插入元素复制到表中的\n插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半\n\n第8章排\n序\n341\n查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，\n可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折\n半查找来实现。确定待插入位置后，就可统一地向后移动元素。\n折半插入排序算法的排序过程举例见本书配套课程，其代码如下：\nvoid InsertSort（ElemType A[l,int n)(\nint i，j,low,high,mid;\nfor（i=2;i<=n;i++）{\n//依次将A[2]～A[n]插入前面的已排序序列\nA[0]=A[i];\n//将A[i]暂存到A[0]\nlow=1;high=i-1;\n//设置折半查找的范围\nwhile(low<=high）{\n//折半查找（默认递增有序）\nmid=(1ow+high)/2;\n/取中间点\nif（A[mid] >A[0]）high=mid-1；//查找左半子表\nelse low=mid+1;\n//查找右半子表\nfor(j=i-1;j>=high+l;--j)\nA[j+1]=A[j];\n/统一后移元素，空出插入位置\nA[high+1]=A[0];\n//插入操作\n命题追踪\n直接插入排序和折半插入排序的比较（2012）\n从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为O(nlog2n)，\n该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，\n它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(r²），但对于数据量不算\n很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。\n折半插入排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0823",
        "title": "希尔排序",
        "chapter_id": "c08",
        "description": "从前面的分析可知，直接插入排序算法的时间复杂度为O（n²)，但若待排序列为“正序”时，\n其时间效率可提高至O（n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔\n排序正是基于这两点分析对直接插入排序进行改进而得来的，也称缩小增量排序。\n命题追踪希尔排序中各子序列采用的排序算法（2015）\n希尔排序的基本思想是：先将待排序表分割成若干形如L[i,i+d,i+2d.·，i+kd]的“特殊”\n子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个\n表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。\n命题追踪根据希尔排序的中间过程判断所采用的增量（2014、2018）\n希尔排序的过程如下：先取一个小于n的增量d，把表中的全部记录分成d组，所有距离为d\n的倍数的记录放在同一组，在各组内进行直接插入排序：然后取第二个增量d<d，重复上述过程，\n直到所取到的d=1，即所有记录已放在同一组中，再进行直接插入排序，此时已经具有较好的局部\n有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0821",
        "title": "节的",
        "chapter_id": "c08",
        "description": "关键字为例，假定第一趟取增量d=5，将该序列分成5个子序列，即图中第2行至第6行，分别对\n直接插入排序，结果如第11行所示；最后对整个序列进行一趟直接插入排序，整个排序过程如\n图8.2所示。\n\n342\n2026年数据结构考研复习指导\n[初始关键字]：\n49\n38659776132749\n55\n04\n[49\n13\n38\n27\n65\n49\n97\n55\n76\n0\n第一趟排序结果：\n1327\n49\n5504\n49\n38\n65\n97\n76\n13\n55\n76\n27\n65\n04\n49\n49\n97\n第二趟排序结果：\n13\nt0\n49\n38\n27\n49\n55\n65\n97\n76\n第三趟排序结果：\n04\n13\n27\n38\n49\n49\n5565\n7697\n图8.2希尔排序示例\n希尔排序算法的代码如下：\nvoid ShellSort(ElemType A[l,int n)(\n//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到\nint dk，i，j;\nfor(dk=n/2;dk>=1;dk=dk/2)\n/增量变化（无统一规定）\nfor（i=dk+1;i<=n;++i)\nif(A[i]<A[i-dk]){\n//需将A[i]插入有序增量子表\n//暂存在A[0]\nA[O]=A[i];\nfor(j=i-dk;j>0&&A[0]<A[j];j-=dk)\nA[j+dk]=A[j];\n/记录后移，查找插入的位置\nA[j+dk]=A[0];\n/插入\n希尔排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为0（1)。\n时间效率：因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难\n题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度约为O（n3)。\n在最坏情况下希尔排序的时间复杂度为O（n²)。\n稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因\n此希尔排序是一种不稳定的排序算法。例如，图8.2中49与49的相对次序已发生了变化。\n适用性：希尔排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0839",
        "title": ".11.2,1.4.7.5.10.6",
        "chapter_id": "c08",
        "description": "第一趟：\n1.3,7.5,2,6.4,9,11,10.8\n第二趟：\n126437581.10.9\n第一趟分组：8,1,6；3,4；9,7；11,5；2,10：间隔为5，排序后组内递增。\n第二趟分组：1,5,4,10：3,2,9,8：7.6,11；间隔为3，排序后组内递增。\n因此，选择选项D。\n二、综合应用题\n01.【解答】\n直接插入排序过程如下。\n初始序列：\n4,5,1,2,6,3\n第一趟：\n4,5,1,2,6,3\n（将5插入{4}）\n第二趟：\n1,4,5,2,6,3\n(将1插入{4,5})\n第三趟：\n1,2,4,5,6,3\n（将2插入{1,4,5}）\n第四趟：\n1,2,4,5,6,3\n（将6插入{1,2,4,5}）\n第五趟：\n1,2,3,4,5,6\n（将3插入{1,2,4,5,6})\n02.【解答】\n原始序列：\n50,26,38,80,70,90,8,30,40,20\n第一趟（增量5）：\n50,8,30,40,20,90,26,38,80,70\n第二趟（增量3）：\n26,8,30,40,20,80,50,38,90,70\n第三趟（增量1)：\n8,20,26,30,38,40, 50, 70, 80, 90\n8.3交换排序\n所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。\n\n第8章排\n序\n347\n基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，\n般很少直接考查，通常会重点考查快速排序算法的相关内容。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0831",
        "title": "冒泡排序",
        "chapter_id": "c08",
        "description": "冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序\n（A[i-1]>A[i])，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元\n素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最\n小的元素如气泡一般逐渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。\n下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或\n最大元素）放到了序列的最终位置.…·这样最多做n-1趟冒泡就能把所有元素排好序。\n图8.3所示为冒泡排序的过程，第一趟冒泡时：27<49，不交换；13<27，不交换；76>13，\n交换：97>13，交换：65>13，交换；38>13，交换；49>13，交换。通过第一趟冒泡后，最小\n元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排\n序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。\n49\n13\nB\n3\n3\n13\n3\n38\n49\n27\n27\n27\n27\n27\n65\n38\n49\n38\n38\n38\n38\n97\n65\n38\n49\n49\n49\n49\n76\n97\n65\n49\n49\n49\n49\n13\n76\n97\n65\n65\n65\n65\n27\n27\n76\n97\n76\n76\n76\n49\n49\n49\n76\n97\n97\n97\n初\n第\n第\n第\n第\n第\n最\n始\n二\n三\n一\n五\n终\n状\n趟\n趟\n趟\n趟\n趟\n状\n态\n后\n后\n后\n后\n后\n态\n图8.3\n冒泡排序示例\n冒泡排序算法的代码如下：\nvoid BubbleSort(ElemType A[],int n)(\nfor（inti=0;i<n-l;i++){\nbool flag=false;\n//表示本趟冒泡是否发生交换的标志\nfor(int j=n-1;j>i;j--)\n//一趟冒泡过程\nif(A[j-1]>A[j]){\n//若为逆序\nswap(A[j-1],A[j]);\n//使用封装的swap函数交换?\nflag=true;\nif(flag==false)\nreturn;\n//本趟遍历后没有发生交换，说明表已经有序\n冒泡排序的性能分析如下：\n空间效率：仅使用了常数个辅助单元，因而空间复杂度为O（1)。\n时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换），\n①本章有多处要两两交换元素，为使代码更简洁，使用函数swap（int&a，int&b），其代码如下：\nint temp=a;a=b;b=temp;\n\n348\n2026年数据结构考研复习指导\n初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，而且每次比\n较后都必须移动元素3次来交换元素位置。这种情况下，\nn(n-1)\n3n(n-1)\n移动次数=\n3（n-i)=\ni=1\n2\n2\n从而，最坏情况下的时间复杂度为 O(n²)，平均时间复杂度为 O(n²)。\n稳定性：i>j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序算法。\n适用性：冒泡排序适用于顺序存储和链式存储的线性表。\n注意\n冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的\n所有元素的关键字一定小于（或大于）无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置\n到其最终的位置上。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0832",
        "title": "快速排序",
        "chapter_id": "c08",
        "description": "命题追踪快速排序的思想（2024）\n快速排序的基本思想：在待排序表L[l..n]中任取一个元素pivot作为枢轴（或称基准，\n通常取首元素)，通过一趟排序将待排序表划分为独立的两部分L[1..k-1]和L[k+1.n]，使得\nL[1l..k-1]中的所有元素小于pivot，L[k+l..n]中的所有元素大于或等于pivot，则pivot\n放在了其最终位置L（k）上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，\n直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。\n一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针i\n和j，初值分别为low和high，取第一个元素49为枢轴赋值到变量pivot。\n指针j从high往前搜索找到第一个小于枢轴的元素27，将27交换到i所指位置。\npivot\n49\n38\n65\n97\n76\n13\n27\n49\n指针i从1ow往后搜索找到第-\n个大于枢轴的元素65，将65交换到j所指位置。\n27\n38\n65\n97\n76\n13\n49\n指针j继续往前搜索找到小于枢轴的元素13，将13交换到i所指位置。\n27\n38\n97\n76\n13\n$9\n49\n指针i继续往后搜索找到大于枢轴的元素97，将97交换到j所指位置。\n27\n38\n13\n97\n6\n65\n49\n指针」继续往前搜索小于枢轴的元素，直至i==j。\n27\n38\n13\n76\n97\n65\n49\n\n第8章排\n序\n349\n命题追踪\n快速排序的中间过程的分析（2014、2019、2023）\n此时，指针i（==j）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放\n在i所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。\n第一趟后：\n127\n38\n13}\n49\n76\n97\n65\n按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。\n第二趟后：\n113)\n27\n[38)\n49\n149\n65}\n76\n1971\n第三趟后：\n13\n27\n38\n49\n49\n1651\n76\n97\n第四趟后：\n13\n27\n49\n49\n65\n76\n97\n用二叉树的形式描述这个快速排序示例的递归调用过程，如图8.4所示。\n第一层快排处理后：\n9\n第一层快排处理后：\n第二层快排要\n273813\n65926 9\n第二层快排处理后：\n处理的部分：\n第三层快排要\n13\n38\n处理的部分：\n(a)第一层快排处理后\n(b)第二层快排处理后\n第一层快排处理后：\n49\n第一层快排处理后：\n第二层快排处理后：\n第二层快排处理后：\n第三层快排处理后：13\n38\n第三层快排处理后：\n13\n38\n第四层快排要处理的部分：\n65\n第四层快排处理后：\n65\n(c)第三层快排处理后\n(d）第四层快排处理后：最终结果\n图8.4快速排序的递归执行过程\n假设划分算法已知，记为Partition（），返回的是上述的k，则L（k）已放在其最终位置。\n因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：\nif(low<high)(\n//递归跳出的条件\n/lPartition（）就是划分操作，将表A[lowhigh]划分为满足上述条件的两个子表\nint pivotpos=Partition(A，low,high）;/划分\nQuickSort（A，low,pivotpos-1）;//依次对两个子表进行递归排序\nQuickSort(A,pivotpos+l,high);\n命题追踪（算法题）快速排序中划分操作的应用（2016）\n快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总\n以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的\n元素向左移动，使得一趟Partition（）操作后，表中的元素被枢轴一分为二。代码如下：\nint Partition（ElemType A[],int low,int high){ //一趟划分\nElemType pivot=A[low]；//将当前表中第一个元素设为枢轴，对表进行划分\n\n350\n2026年数据结构考研复习指导\nwhile(low<high)(\n//循环跳出条件\nwhile(low<high&&A[high]>=pivot)--high;\nA[low]=A[high]；/将比枢轴小的元素移动到左端\nwhile(low<high&&A[low]<=pivot) ++low;\nA[high]=A[low]；//将比枢轴大的元素移动到右端\nA[low]=pivot;\n/枢轴元素存放到最终位置\nreturn low;\n//返回存放枢轴的最终位置\n快速排序算法的性能分析如下：\n命题追踪）快速排序中递归次数的影响因素分析（2010）\n空间效率：快速排序是递归的，因此需要借助一个递归工作栈来保存每层递归调用的必要信\n息，其容量与递归调用的最大层数一致。最好情况下为O(log2n)：最坏情况下，要进行n-1次递\n归调用，因此栈的深度为 O(n)：平均情况下，栈的深度为O(log2n)。\n时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域\n始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(㎡²)。\n有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如\n从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素：或者随机地\n从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。\n在最理想的状态下，即Partition（）能做到最平衡的划分，得到的两个子问题的大小都不\n可能大于 n/2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog2n)。\n下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。\n稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换\n到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序算法。例如，表L=\n{3,2.2}，经过一趟排序后L={2,2,3}，最终排序序列也是L={2,2,3}，显然，2与2的相对次\n序已发生了变化。\n命题追踪快速排序适合采用的存储方式（2011）\n适用性：快速排序仅适用于顺序存储的线性表。\n注意\n在快速排序算法中，并不产生有序子序列，但每一趟排序后会将上一趟划分的各个无序子表的枢轴（基\n准）元素放到其最终的位置上。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0841",
        "title": "简单选择排序",
        "chapter_id": "c08",
        "description": "根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为\nL[1..]，第i趟排序即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟排序可以确定\n一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。\n简单选择排序算法的过程较为简单，相关举例见本书配套课程，其代码如下：\nvoid SelectSort(ElemType A[],intn)(\nfor（int i=0;i<n-l;i++）{\n//一共进行n-1趟\nint min=i;\n/记录最小元素位置\nfor（int j=i+1;j<n;j++)\n//在A[i.n-1]中选择最小的元素\nif(A[j]<A[min]） min=j;\n//更新最小元素位置\nif（min!=i) swap(A[i],A[min]);\n//封装的swap（）函数共移动元素3次\n简单选择排序算法的性能分析如下：\n空间效率：仅使用常数个辅助单元，所以空间效率为O（1)。\n时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不\n会超过3（n-1)次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列\n的初始状态无关，始终是n（n-1)/2次，因此时间复杂度始终是O（n²)。\n稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与含有相同关\n键字的元素的相对位置发生改变。例如，表L={2,2,1}，经过一趟排序后L={1,2,2}，最终排\n序序列也是L={1，2，2}，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳\n定的排序算法。\n适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0842",
        "title": "堆排序",
        "chapter_id": "c08",
        "description": "堆的定义如下，n个关键字序列L[1..n]称为堆，当且仅当该序列满足：\n①L(i)≥L(2i)且L(i)≥L(2i+1）或\n②L(i)≤L(2i)且L(i)≤L(2i+1）(1≤i≤Ln/2」)\n命题追踪堆的性质与特点（2020）\n可以将堆视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆），大根堆的最大元素\n存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件②的堆称为小根\n堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。\n图8.5一个大根堆示意图\n\n第8章排\n序\n359\n最新408统考大纲增加了考点“堆的应用”，堆的应用只有两个：堆排序和优先队列（见本\n节综合题7），优先队列也利用了堆排序的思想，因此本节仅介绍堆排序。\n堆排序的思路很简单：首先将存放在L[1..n]中的n个元素建成初始堆，因为堆本身的特点\n（以大顶堆为例），所以堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时\n根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再\n输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见，堆排序需要解决两个问题：①如\n何将无序序列构造成初始堆？②输出堆顶元素后，如何将剩余元素调整成新的堆？\n命题追踪初始建堆的操作（2018、2021）\n堆排序的关键是构造初始堆。建堆思路是从后往前检查所有分支结点，看是否满足堆的要求，\n若不满口，则对以该分支结点为根的子树进行调整。Ⅱ个结点的完全二叉树，最后一个结点是第\nLn/2」个结点的孩子。对以第Ln/2」个结点为根的子树筛选（对于大根堆，若根结点的关键字小于\n左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对以各结点（Ln/2」-1～1）\n为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的\n较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到\n以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。\n如图8.6所示，初始时调整L（4)子树，09<32，交换，交换后满足堆的定义；向前继续调整\nL(3)子树，78<左右孩子的较大者87，交换，交换后满足堆的定义；向前调整L(2)子树，17<左\n右孩子的较大者45，交换后满足堆的定义；向前调整至根结点L（1），53<左右孩子的较大者87，\n交换，交换后破坏了L(3)子树的堆，采用上述方法对L(3)进行调整，53<左右孩子的较大者78,\n交换，至此该完全二叉树满足堆的定义。\n）初始i\n（b)i=\n（c)i=2\n09\n(d)i=1\n(e)结果\n图8.6自下往上逐步调整为大根堆\n命题追踪堆的删除操作及调整操作分析（2015、2024）\n输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进\n行筛选。将09和左右孩子的较大者78交换，交换后破坏了L(3)子树的堆，继续对L(3)子树向下\n筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.7所示。\n\n360\n2026年数据结构考研复习指导\n78\n53\n32\n65\n（53）\n32\n（17）\n图8.7输出堆顶元素后再将剩余元素调整成新堆\n下面是建立大根堆的算法：\nvoid BuildMaxHeap(ElemType A[],int len){\nfor（inti=len/2;i>0;i--)\n//从i=[n/2]~1，反复调整堆\nHeadAdjust(A,i,len);\nvoid HeadAdjust(ElemType A[],int k,int len){\n//函数HeadAdjust对以元素k为根的子树进行调整\nA[0]=A[k];\nI/A[0]暂存子树的根结点\nfor（inti=2*k;i<=len;i*=2）{//沿key较大的子结点向下筛选\nif(i<len&&A[i]<A[i+1])\ni++;\n//取key较大的子结点的下标\nif(A[O]>=A[i])break;\n//筛选结束\nelset\nA[k]=A[i];\n/将A[i]调整到双亲结点上\nk=i;\n/修改k值，以便继续向下筛选\nA[k]=A[0];\nI被筛选结点的值放入最终位置\n调整的时间与树高有关，为O(h)。在建含n个元素的堆时，关键字的比较总次数不超过4n，\n时间复杂度为O（n)，这说明可以在线性时间内将一个无序数组建成一个堆。\n下面是堆排序算法：\nvoid HeapSort(ElemType A[l,int len)(\nBuildMaxHeap(A,len);\n//初始建堆\nfor（inti=len;i>1;i--){\n//n-1趟的交换和建堆过程\nSwap(A[i],A[l]);\n//输出堆顶元素（和堆底元素交换）\nHeadAdjust(A,1,i-1);\n//调整，把剩余的i-1个元素整理成堆\n公众号：小兔网盘免费分享无水印PDF\n命题追踪\n堆的插入操作及调整操作分析（2009、2011）\n同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结\n点向上执行调整操作。大根堆的插入操作示例如图8.8所示。\n87\n87\n(a)初始，尾部加63\n（b)父结点关键字32下降\n（c)父结点关键字45下降\n(d)调整完成\n图8.8大根堆的插入操作示例\n\n第8章排序\n361\n命题追踪堆在海量数据中选出最小k个数的应用及效率分析（2022）\n堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值。首先使用一个大\n小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，\n否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数为所求。\n堆排序算法的性能分析如下：\n空间效率：仅使用了常数个辅助单元，所以空间复杂度为O(1)。\n时间效率：建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h)，\n所以在最好、最坏和平均情况下，堆排序的时间复杂度为O(nlog2n)。\n稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种\n不稳定的排序算法。例如，表L={1,2,2}，构造初始堆时可能将2交换到堆顶，此时L={2,1,2}，\n最终排序序列为L={1,2,2}，显然，2与2的相对次序已发生变化。\n适用性：堆排序仅适用于顺序存储的线性表。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0847",
        "title": "直接调整成堆，则会误选选项C。",
        "chapter_id": "c08",
        "description": "21.B\n该序列已调整成大根堆，接下来进行第一次删除操作：删除28后，将5放入堆顶：然后自上而\n下调整。22和20比较，较大者22与5比较，交换：19和8比较，较大者19与5比较，交换。\n5\n22\n19）\n（12）（15\n接下来进行第二次删除操作：删除22后，将15放入堆顶；然后自上而下调整。19和20比\n较，较大者20与15比较，交换；15直接与其仅有的左孩子12比较，不交换。\n15\n20\n5\n(12\n因此，进行两次删除操作后，得到的新堆是20，19，15，5，8,12。\n二、综合应用题\n01.【解答】\n以小根堆为例，堆的特点是双亲结点的关键字必然小于或等于该孩子结点的关键字，而两个\n孩子结点的关键字没有次序规定。在二叉排序树中，每个双亲结点的关键字均大于左子树结点的\n关键字，均小于右子树结点的关键字，也就是说，每个双亲结点的左、右孩子的关键字有次序关\n系。这样，当对两种树执行中序遍历后，二叉排序树会得到一个有序的序列，而堆则不一定能得\n到一个有序的序列。\n02.【解答】\n大根堆要求根结点的关键字值既大于或等于左子女的关键字值，又大于或等于右子女的关键\n字值。二叉排序树要求根结点的关键字值大于左子女的关键字值，同时小于右子女的关键字值。\n两者的交集是：根结点的关键字值大于左子女的关键字值。这意味着它是一棵左斜单支树，但大\n根堆要求是完全二叉树，因此最后得到的只能是如下图所示的两个结点的二叉树。\n2\n\n368\n2026年数据结构考研复习指导\n读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子\n是为了体现出排序树与大根堆的区别。\n03.【解答】\n在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才\n能得到前k个最小的元素序列，算法的效率不高。\n冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。\n采用堆排序最合适，对于n个元素的序列，建立初始堆的时间不超过4n，取得第k个最小元素之\n的时间为kn，当k≥5时，通过比较可以得出堆排序最优。\n注意\n求前k个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序。\n04.【解析】\n1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插\n入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。\n0\n88\n90)\n图1插入65后的树形\n88\n90\n图2删除堆顶元素后的树形\n2）父结点的编号为（k-1)/4，第i个孩子的编号为4xk+i，i=1,2,3,4。\n3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有\n关。因此，插入和删除操作的时间复杂度都为O(logmn)，其中n为元素个数。\n05.【解答】\n算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端，\n在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形\n成的结果链表中的结点将按关键字非递减的顺序有序链接。\n单链表的定义如第2章所述，假设它不带表头结点。\nvoid selectSort(LinkedList& L)(\nI对不带表头结点的单链表L执行简单选择排序\nLinkNode *h=L,*p,*g,*r,*s;\nL=NULL;\nwhile(h!=NULL){\n/持续扫描原链表\np=s=h;q=r=NULL;\n//指针s和r记忆最大结点和其前驱；p为工作指针，q为其前驱\n\n第8章排\n序\n369\nwhile(p!=NULL){\n//扫描原链表寻找最大结点s\n(b=!d=s}(eep<-s<eep<-d)\n/找到更大的，记忆它和它的前驱\nut<-d=d!d=b\n//继续寻找\nif(s==h)\nh=h->link;\n//最大结点在原链表前端\nelse\nr->link=s->link;\n//最大结点在原链表表内\ns->link=L;L=s;\nl/结点s插入结果链前端\n06.【解答】\n将顺序表L[1..n］视为一个完全二叉树，扫描所有分支结点，遇到孩子结点的关键字小于根\n结点的关键字时返回false，扫描完后返回true。算法的实现如下：\nbool IsMinHeap(ElemType A[l,int len)(\nif（len%2==0）{\n//len为偶数，有一个单分支结点\nif(A[len/2]>A[len])\n1//判断单分支结点\nreturn false;\nfor（i=len/2-1;i>=1；i--）//判断所有双分支结点\nif(A[i]>A[2*i]1|A[i]>A[2*i+1])\nreturn false;\nelser\n//len为奇数时，没有单分支结点\nfor(i=len/2;i>=1;i--)\n1/判断所有双分支结点\nif(A[i]>A[2*i]l|A[i]>A[2*i+1])\nreturn false;\n?\nreturn true;\n07.【解答】\n1）题目要求整个队列所占用的空间不变，入队操作和出队操作的时间复杂度始终保持为\nO(log2n)，则应采用顺序存储结构，即用数组实现大根堆。\n2）优先队列的数据结构定义如下：\ntypedef struct{\nPriorityQueueElement heap[MAx_SIzE];\n//用数组实现堆\nint size;\n//当前堆中元素的数量\n)PriorityQueue\n3）入队操作：\nvoid enqueue(PriorityQueue*\n*pq,int value,int priority)(\nif(pq->size>=MAx_SIzE){\n队列已满，无法入队；\nreturn;\n将新元素添加到堆的末尾；\n向上调整堆；\n出队操作：\nPriorityQueueElement dequeue(PriorityQueue *pq)(\nif(pq->size==0){\n队列为空时直接退出；\n获取堆顶元素（优先级最高的元素）；\n将堆的最后一个元素放到堆顶；\n\n370\n2026年数据结构考研复习指导\n向下调整堆;\n返回出队元素；\n08.【解答】\n1）算法思想。\n【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。\nforM中的每个元素s\nif（s<A[9]）丢弃A[9]并将s按升序插入A;\n当数据全部扫描完毕，数组A[0]～A[9]保存的就是最小的10个数。\n【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。\nforM中的每个元素s\nif（s<H的堆顶元素）删除堆顶元素并将s插入H;\n当数据全部扫描完毕，堆H中保存的就是最小的10个数。\n2）算法平均情况下的时间复杂度是O(n)，空间复杂度是O(1)。\n8.5归并排序、基数排序和计数排序",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0851",
        "title": "归并排序",
        "chapter_id": "c08",
        "description": "命题追踪\n二路归并操作的功能（2022）\n归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有\n序表合并成一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表，每个\n子表的长度为1，然后两两归并，得到「n/2|个长度为2或1的有序表；继续两两归并如此重\n复，直到合并成一个长度为n的有序表为止，这种排序算法称为二路归并排序。\n图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。\n初始关键字\n[49]\n[38]\n[65]\n[97]\n[76][13]\n[27]\nL\nL\nL\n第一趟归并后\n[38\n“49]\n[65\n97]\n[13\n76]\n[27]\n#\n第二趟归并后\n[38\n49\n65\n971\n[13\n27\n76]\n第三趟归并后\n[13\n27\n38\n49\n65\n76\n97]\n图8.9\n二路归并排序示例\n命题追踪（算法题）归并排序思想的应用（2011）\nMerge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表\nA[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B\n中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下\n标超出其对应的表长（该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A\n中。算法如下：\nElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));//辅助数组 B\nvoid Merge（ElemType A[],int low,int mid,int high)(\n\n第8章排序\n371\n//表A的两段A[low..mid]和A[mid+1...high]各自有序，将它们合并成一个有序表\nint i,j,k;\nfor(k=low;k<=high;k++)\nB[k]=A[k];\n//将A中所有元素复制到B中\nfor（i=low,j=mid+1,k=i;i<=mid&&j<=high;k++）{\nif(B[i]<=B[j])\n//比较B的两个段中的元素\nA[k]=B[i++];\n/将较小值复制到A中\nelse\nA[k]=B[j++];\nwhile(i<=mid)\nA[k++]=B[i++]；/若第一个表未检测完，复制\nwhile(j<=high)\nA[k++]=B[j++]；//若第二个表未检测完，复制\n注意\n在上面的代码中，最后两个while循环只有一个会执行。\n有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行log2n趟。\n递归形式的二路归并排序算法是基于分治的，其过程如下。\n分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用二路归并排序算法对两\n个子表递归地进行排序。\n合并：合并两个已排序的子表得到排序结果。\nvoid MergeSort(ElemType A[l,int low,int high)(\nif(low<high）(\nint mid=（low+high)/2;\n//从中间划分两个子序列\nMergeSort(A,low,mid);\n/对左侧子序列进行递归排序\nMergeSort(A,mid+l,high);\n//对右侧子序列进行递归排序\nMerge(A,low,mid,high);\n//归并\n命题追踪\n归并排序和插入排序的对比（2017）\n命题追踪\n二路归并比较次数的分析（2024）\n路归并排序算法的性能分析如下：\n空间效率：Merge（）操作中，辅助空间刚好为n个单元，因此算法的空间复杂度为O(n)。\n时间效率：每趟归并的时间复杂度为O（n)，共需进行「1og2n趟归并，因此算法的时间复杂\n度为 O(nlog2n)。\n稳定性：Merge（）操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种\n稳定的排序算法。\n适用性：归并排序适用于顺序存储和链式存储的线性表。\n注意\n一般而言，对于N个元素进行k路归并排序时，排序的趟数m满足k\"=N，从而m=logkN，又考虑到m\n为整数，因此m=「logkV。这和前面的二路归并排序算法是一致的。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0852",
        "title": "基数排序",
        "chapter_id": "c08",
        "description": "基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大\n\n372\n2026年数据结构考研复习指导\n小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。\n假设长度为n的线性表中每个结点a,的关键字由d元组（k,kg-²，,},k）组成，满足\n0≤k≤r-1（0≤j<n,0≤i≤d-1)。其中kg-为最高位关键字，k²为最低位关键字。\n为实现多关键字排序，通常有两种方法：第一种是最高位优先（MSD）法，按关键字位权重\n递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列：第二种是\n最低位优先（LSD）法，按关键字位权重递增依次进行排序，最后形成一个有序序列。\n下面描述以r为基数的最低位优先基数排序的过程，在排序过程中，使用r个队列Qo，Q,，\nQ~1。基数排序的过程如下：\n对i=0，1,，d-1，依次做一次分配和收集（其实是一次稳定的排序过程）。\n①分配：开始时，把Ωo,Q,…，Q-各个队列置成空队列，然后依次考察线性表中的每个结\n点a（j=0,1,…，n-1），若a的关键字k=k，就把a放进Qk队列中。\n②收集：把Qo,Q1…,Q-1各个队列中的结点依次首尾相接，得到新的结点序列，从而组成\n新的线性表。\n命题追踪）基数排序的中间过程的分析（2013、2021）\n通常采用链式基数排序，假设对如下10个记录进行排序：\n每个关键字是1000以下的正整数，基数r=10，在排序过程中需借助10个链队列，每个关\n键字由3位子关键字构成一一KK²K’，分别代表百位、十位和个位，一共进行三趟“分配”和“收\n集”操作。第一趟分配用最低位子关键字K?进行，将所有最低位子关键字（个位）相等的记录分\n配到同一个队列，如图8.10(a)所示，然后进行收集操作。第一趟收集后的结果如图8.10(b)所示。\nlo]b\n[n]b\nq[2]\nq[3]\n+]b\nq[6]\nq[7]\nq[8]\n[6]b\n086\n063\n184505\n[27809]\n083\n008\n589\n269\n（a）第趟分配后\n930063083184505278008109589269\n（b）第一趟收集后\n图8.10第一趟链式基数排序操作\n第二趟分配用次低位子关键字K进行，将所有次低位子关键字（十位）相等的记录分配到\n同一个队列，如图8.11(a)所示。第二趟收集后的结果如图8.11(b)所示。\n[o]b\nq[1]\nq[2]\nq[3]\n[+]b\nq[5]\n[9]b\nq[7]\nq[8]\n[6]b\n[505\n930\n063\n278\n083\n08\n269\n184\n601\n589\n(a）第二趟分配后\n505008109930063269278083184589\n（b）第二趟收集后\n图8.11第二趟链式基数排序操作\n\n第8章排\n373\n第三趟分配用最高位子关键字K进行，将所有最高位子关键字（百位）相等的记录分配到\n同一个队列，如图8.12(a)所示，第三趟收集后的结果如图8.12(b)所示，至此整个排序结束。\n[o]b\n[1]b\nq[2]\nq[3]\n[+]b\nq[5]\n[9]b\nq[7]\n[8]b\n[6]b\n008\n[09]\n269\n505\n930\n063\n184\n278\n589\nY\n083\n(a）第三趟分配后\n008063083109184269278505589930\n(b）第三趟收集后\n图8.12第三趟链式基数排序操作\n基数排序算法的性能分析如下。\n空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针），但\n以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r)。\n命题追踪）元素的移动次数与序列初态无关的排序算法（2015）\n时间效率：基数排序需要进行d趟“分配”和”收集”操作。一趟分配需要遍历所有关键字，\n度为O（d（n+r))，它与序列的初始状态无关。\n稳定性：每一趟分配和收集都是从前往后进行的，不会交换相同关键字的相对位置，因此基\n数排序是一种稳定的排序算法。\n适用性：基数排序适用于顺序存储和链式存储的线性表。\n*",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0853",
        "title": "计数排序",
        "chapter_id": "c08",
        "description": "命题追踪（算法题）计数排序思想的应用（2013、2015、2018）\n计数排序也是一种不基于比较的排序算法。计数排序的思想是：对每个待排序元素x，统计\n小于x的元素个数，利用该信息就可确定x的最终位置。例如，若有8个元素小于x，则x就排\n在第9号位置上。当有几个元素相同时，该排序方案还需做一定的优化。\n注意\n计数排序并不在统考大纲的范围内，但其排序思想在历年真题中多次涉及。\n在计数排序算法的实现中，假设输入是一个数组A[n]，序列长度为n，我们还需要两个数\n引），而该元素出现的次数存储在该元素作为下标的数组C中。算法如下：\n命题追踪计数排序相关的思想和代码的分析（2021）\nvoid CountSort(ElemType A[],ElemType B[],int n,int k)(\nint i,c[k];\nfor（i=0;i<k;i++)\nC[i]=0;\n1//初始化计数数组\nfor（i=0;i<n;i++)\n//遍历输入数组，统计每个元素出现的次数\nC[A[i]]++;\nIIC[A[i]]保存的是等于A[i]的元素个数\n\n374\n2026年数据结构考研复习指导\nfor(i=1;i<k;i++)\nC[i]=C[i]+C[i-1];\n//C[x]保存的是小于或等于x的元素个数\nfor（i=n-1;i>=0;i--){\n//从后往前遍历输入数组\nB[C[A[i]]-1]=A[i];\n//将元素A[i]放在输出数组B[]的正确位置上\nC[A[i]]=C[A[i]]-1;\n第一个for循环执行完后，数组c的值初始化为O。第二个for循环遍历输入数组A，若\n个输入元素的值为x，则将C[x]值加1，该for循环执行完后，C[x]中保存的是等于x的元\n素个数。第三个for循环通过累加计算后，C[x］中保存的是小于或等于×的元素个数。第四个\nfor循环从后往前遍历数组A，把每个元素A[i]放入它在输出数组B的正确位置上。若数组A\n中不存在相同的元素，则C[A[i]]-1就是A[i]在数组B中的最终位置，这是因为共有C[A[i]]\n个元素小于或等于A[i]。若数组A中存在相同的元素，将每个元素A[i]放入数组B[]后，都要\n将C[A[i]]减1，这样，当遇到下一个等于A[i]的输入元素（若存在）时，该元素就可放在数\n组B中A[i]的前一个位置上。\n假设输入数组A[]={2，4,3，0，2，3}，第二个for循环执行完后，辅助数组c的情况如图8.13(a)\n所示：第三个for循环执行完后，辅助数组c的情况如图8.13（b）所示。图8.13（c)至图8.13（h)分别是\n第四个for循环每迭代一次后，输出数组B和辅助数组c的情况。\n012345\n012345\n012345\n012345\nA2]430|213\nA2|4302|3\nA2]43023\nA214]3|0]213\n01234\n012345\nA3\nA213\n01234\n01234\n01234\n01234\nc102|21\nc111356\nC111346\nc1246\n(a)\n(b)\n(c)\n(d)\n012345\n012345\n012345\n012345\nA2|4302|3\nA2|43023\nA2|43023\n012345\n012345\nB023\nB0233\nB02334\nB022334\n01234\n01234\n01234\n01234\nc01246\nc01121316\nc0121315\nc01135\n(e)\n(f\n(g)\n(h)\n图8.13计数排序的过程\n由上面的过程可知，计数排序的原理是：数组的索引（下标）是递增有序的，通过将序列中\n的元素作为辅助数组的索引，其个数作为值放入辅助数组，遍历辅助数组来排序。\n计数排序算法的性能分析如下。\n空间效率：计数排序是一种用空间换时间的做法。输出数组的长度为n；辅助的计数数组的\n长度为k，空间复杂度为O(n+k)。若不把输出数组视为辅助空间，则空间复杂度为O(k)。\n环所花的时间为O（n)，总时间复杂度为O（n+k)。因此，当k=O(n)时，计数排序的时间复杂度为\nO(n)：但当k>O(nlog2n)时，其效率反而不如一些基于比较的排序（如快速排序、堆排序等）。\n稳定性：上述代码的第4个for循环从后往前遍历输入数组，相同元素在输出数组中的相对\n位置不会改变，因此计数排序是一种稳定的排序算法。\n适用性：计数排序更适用于顺序存储的线性表。计数排序适用于序列中的元素是整数且元素\n范围（0～k-1）不能太大，否则会造成辅助空间的浪费。\n\n第8章排\n375",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0861",
        "title": "内部排序算法的比较",
        "chapter_id": "c08",
        "description": "前面讨论的排序算法很多，对各种排序算法的比较是考研常考的内容。一般基于五个因素进\n行对比：时间复杂度、空间复杂度、稳定性、适用性和过程特征。\n命题追踪各种排序算法的特点、比较和适用场景（2017、2020、2022）\n从时间复杂度看：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为\nO(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的\n数据都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据\n结构，可以在线性时间内完成建堆，且在O(nlog2n)内完成排序过程。快速排序基于分治的思想，\n虽然最坏情况下的时间复杂度会达到O(n²)，但快速排序的平均性能可以达到O(nlog2n)，在实际\n应用中常常优于其他排序算法。归并排序同样基于分治的思想，但其分割子序列与初始序列的排\n列无关，因此它的最好、最坏和平均时间复杂度均为O(mlog2n)。\n丛空问复杂度看：简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需借助常数\n个辅助空间。快速排序需要借助一个递归工作栈，平均大小为O(log2n)，当然在最坏情况下可能\n会增长到O（m)。二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为O（n)，\n虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。\n命题追踪排序算法的稳定性判断及改进（2021、2023）\n从稳定性看：插入排序、冒泡排序、归并排序和基数排序是稳定的排序算法，而简单选择排\n序、快速排序、希尔排序和堆排序都是不稳定的排序算法。平均时间复杂度为O(nlog2n)的稳定排\n序算法只有归并排序，对于不稳定的排序算法，只需举出一个不稳定的实例即可。对于排序算法\n的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。\n命题追踪更适合采用顺序存储的排序算法（2017）\n从适用性看：折半插入排序、希尔排序、快速排序和堆排序适用于顺序存储。直接插入排序、\n\n第8章排\n序\n381\n冒泡排序、简单选择排序、归并排序和基数排序既适用于顺序存储，又适用于链式存储。\n命题追踪\n根据排序的中间过程判断所采用的排序算法（2009、2010）\n从过程特征看：采用不同的排序算法，在一趟或几趟处理后的排序结果通常是不同的，考研\n生当前的最大值或最小值，而快速排序一趟处理至少能确定一个元素的最终位置等。\n的复杂度，因为希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。\n表8.1各种排序算法的性质\n算法种类\n时间复杂度\n空间复杂度\n是否稳定\n最好情况\n平均情况\n最坏情况\n直接插入排序\nO(n)\n(u)o\nO(n)\n0(1)\n是\n冒泡排序\nO(n)\nO(n²)\n0(n²)\n0(1)\n是\n简单选择排序\nO(n²)\nO(n²)\nO(n²)\n0(1)\n否\n希尔排序\n0(1)\n否\n快速排序\nO(nlog2n)\nO(nlog2n)\nO(nr²)\nO(log2n)\n否\n堆排序\nO(nlogan)\nO(nlog2n)\nO(nlogan)\n0(1)\n香\n路归并排序\nO(nlog2n)\nO(nlog2n)\nO(nlog2n)\nO(n)\n是\n基数排序\nO(d(n+r)\nO(d(n+r))\nO(d(n+r))\n(0)0\n是",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0862",
        "title": "",
        "chapter_id": "c08",
        "description": "内部排序算法的应用\n通常情况，对排序算法的比较和应用应考虑以下情况。\n命题追踪）选取排序算法时需要考虑的因素（2019）\n1.选取排序算法需要考虑的因素\n1）待排序的元素个数n。\n2）待排序的元素的初始状态。\n3）关键字的结构及其分布情况。\n4）稳定性的要求。\n5）存储结构及辅助空间的大小限制等。\n2.排序算法小结\n1）若n较小，可采用直接插入排序或简单选择排序。直接插入排序所需的记录移动次数较\n简单选择排序的多，因此当记录本身信息量较大时，用简单选择排序较好。\n2）若n较大，应采用时间复杂度为O（nlog2n）的排序算法：快速排序、堆排序或归并排序。\n当待排序的关键字随机分布时，快速排序被认为是目前基于比较的内部排序算法中最好\n的算法。堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能的最坏情况，\n这两种排序都是不稳定的。若要求稳定且时间复杂度为O（nlog2n)，可选用归并排序。\n3）若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。\n4）在基于比较的排序算法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，\n\n382\n2026年数据结构考研复习指导\n因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机\n分布时，任何借助于“比较”的排序算法，至少需要O（nlog2n)的时间。\n5）若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。\n6）当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0871",
        "title": "外部排序的基本概念",
        "chapter_id": "c08",
        "description": "前面介绍过的排序算法都是在内存中进行的（称为内部排序）。而在许多应用中，经常需要\n对大文件进行排序，因为文件中的记录很多，无法将整个文件复制进内存中进行排序。因此，需\n要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过\n程中需要多次进行内存和外存之间的交换。这种排序算法就称为外部排序。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0872",
        "title": "外部排序的方法",
        "chapter_id": "c08",
        "description": "文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读/写的。因为磁盘\n读/写的机械动作所需的时间远远超过在内存中进行运算的时间（相比而言可以忽略不计），因此\n在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。\n命题追踪）对大文件排序时使用的排序算法（2016）\n外部排序通常采用归并排序算法。它包括两个阶段：①根据内存缓冲区大小，将外存上的文\n件分成若干长度为（的子文件，依次读入内存并利用内部排序算法对它们进行排序，并将排序后\n得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串；②对这些归并段进行逐趟\n\n388\n2026年数据结构考研复习指导\n归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。\n例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排\n序得到8个初始归并段R1～R8，每段都含250条记录。然后对该文件做如图8.15所示的两两归\n并，直至得到一个有序文件。可以把内存工作区等分为三个缓冲区，如图8.14所示，其中的两个\n输入缓冲区1和输入缓冲区2中。然后，在内存中进行二路归并，归并后的对象顺序存放在输出\n缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段（R1）中，再清空输出缓冲区，\n继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下\n块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。\n当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上\n趟的结果R1和R2'、R3'和R4'两两归并，这又是一趟归并。最后把R1\"和R2\"两个归并段归并，\n得到最终的有序文件，一共进行了3趟归并。\n输入缓冲区1\n输出缓冲区\nRI\n输入缓冲区2\n有序文件\n图8.14\n二路归并\n图8.15二路归并的排序过程\n在外部排序中实现两两归并时，不可能将两个有序段及归并结果段同时存放在内存中，因此\n需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下：\n外部排序的总时间=内部排序的时间+外存信息读/写的时间+内部归并的时间\n显然，外存信息读/写的时间远大于内部排序和内部归并的时间，因此应着力减少1/O次数。\n外存信息的读/写是以“磁盘块”为单位的，因此可知每趟归并需进行16次读和16次写，3趟归\n并加上内部排序时所需进行的读/写，使得总共需进行32×3+32=128次读/写。\n若改用4路归并排序，则只需2趟归并，外部排序时的总读/写次数便减至32×2+32=96。\n因此，增大归并路数，可减少归并趟数，进而减少总的磁盘1/0次数，如图8.16所示。\nRL\nR2\nR3\nR4\nR\nR6R7R8\nRI'\nR2'\n有序文件\n图8.164路归并的排序过程\n一般地，对r个初始归并段，做k路归并（每趟将k个或k个以下的有序子文件归并成一个\n有序子文件）。第一趟可将r个初始归并段归并为r/k个归并段，以后每趟归并将m个归并段归\n并成[m/k个归并段，直至最后形成一个大的归并段为止。树的高度-1=「logkr=归并趟数S。可\n见，只要增大归并路数k，或减少初始归并段个数r，都能减少归并趟数S，进而减少读/写磁盘的\n次数，达到提高外部排序速度的目的。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0873",
        "title": "多路平衡归并与败者树",
        "chapter_id": "c08",
        "description": "增加归并路数k能减少归并趟数S，进而减少I/O次数。然而，增加归并路数k时，内\n部归并的时间将增加。做内部归并时，在k个元素中选择关键字最小的元素需要k-1次比较。\n\n第8章排序\n389\n每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并总共需要的比较次数为\nS(n- 1)(k- 1)=[1ogzr (n- 1)(k- 1)=[1og2r(n- 1)(k - 1)/[1og2k]\n式中，（k-1）/log2k随k增长而增长，因此内部归并时间亦随k的增长而增长。这将抵消因增大\nk而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。\n为了使内部归并不受k的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，\n可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的元素，内\n部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比\n较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。\n命题追踪败者树的实现原理（2024）\n如图8.17（a）所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，\n此时，根结点ls[0]所指的段的关键字最小。对于k路归并，初始构造败者树需要k-1次比较。\nb3中的6输出后，将下一关键字填入b3，继续比较。\n12\n15\n12\n20\n40\n(a)\n(b)\n图8.17实现5路归并的败者树\n因为k路归并的败者树深度为「log2k+1，所以从k个记录中选择最小关键字，仅需进行[log2k]\n次比较。因此总的比较次数约为\nS(n-1) [1og2k]=[logkr](n-1)[1og2k]=(n-1)[1og2r]\n可见，使用败者树后，内部归并的比较次数与k无关了。因此，只要内存空间允许，增大归\n并路数k将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。\n值得说明的是，归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓\n冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外\n存交换数据的次数增大。当k值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0874",
        "title": "置换-选择排序（生成初始归并段）",
        "chapter_id": "c08",
        "description": "从",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0872",
        "title": "节的讨论可知，减少初始归并段个数r也可以减少归并趟数S。若总的记录个数为n，",
        "chapter_id": "c08",
        "description": "每个归并段的长度为（，则归并段的个数r=「n/C]。采用内部排序算法得到的各个初始归并段长\n①本节中出现的关于比较次数的公式只是为了帮助读者理解相关原理，无须死记硬背。\n\n390\n2026年数据结构考研复习指导\n度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的\n方法，用来产生更长的初始归并段，这就是本节要介绍的置换-选择算法。\n命题追踪置换-选择排序生成初始归并段的实例（2023）\n设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状\n态为空，WA可容纳w个记录。置换-选择算法的步骤如下：\n1）从FI输入w个记录到工作区WA。\n2）从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。\n3）将MINIMAX记录输出到FO中去。\n4）若FI不空，则从FI输入下一个记录到WA中。\n5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为\n新的MINIMAX记录。\n6）重复3）～5），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并\n段，输出一个归并段的结束标志到FO中去。\n7）重复2）～6），直至WA为空。由此得到全部初始归并段。\n设待排文件FI={17,21,05,44,10,12,56,32,29}，WA容量为3，排序过程如表8.2所示。\n表8.2置换-选择排序过程示例\n输出文件FO\n工作区WA\n输入文件FI\n17,21,05,44,10,12,56,32,29\n17215\n44,10,12,56,32,29\n05\n2144\n10,12,56,32,29\n0517\n1044\n12,56, 32,29\n1012\n05 1721\n56,32, 29\n10 12\n32,29\n05172144\n0517214456\n10 1232\n29\n0517214456#\n1232\n29\n10\n2932\n一\n10 12\n29\n32\n一\n10 1229\n10 122932\n一\n一\n10122932#\n上述算法，在WA中选择MINIMAX记录的过程需利用败者树来实现。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0875",
        "title": "最佳归并树",
        "chapter_id": "c08",
        "description": "文件经过置换-选择排序后，得到的是长度不等的初始归并段。下面讨论如何组织长度不等\n的初始归并段的归并顺序，使得1/O次数最少。假设由置换-选择排序得到9个初始归并段，其长\n度（记录数）依次为9,30,12，18,3,17.2，6,24。现做3路平衡归并，其归并树如图8.18所示。\n在图8.18中，各叶结点表示一个初始归并段，上面的权值表示该归并段的长度，叶结点到根\n的路径长度表示其参加归并的趟数，各非叶结点代表归并成的新归并段，根结点表示最终生成的\n归并段。树的带权路径长度WPL为归并过程中的总读记录数，所以I/O次数=2xWPL=484。\n\n第8章排\n391\n38\n121\n图8.183路平衡归并的归并树\n命题追踪构造三叉哈夫曼树及相关的分析和计算（2013）\n显然，归并方案不同，所得归并树不同，树的带权路径长度（I/O次数）亦不同。为了优化\n归并树的WPL，可以将哈夫曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始\n归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的1/O次数最少的最佳归并树。\n上述9个初始归并段可构造成一棵如图8.19所示的归并树，按此树进行归并，仅需对外存进行\n446次读/写，这棵归并树称为最佳归并树。\n121\n图8.193路平衡归并的最佳归并树\n图8.19中的哈夫曼树是一棵严格3叉树，即树中只有度为3或0的结点。若只有8个初始归\n并段，如上例中少了一个长度为30的归并段。若在设计归并方案时，缺额的归并段留在最后，\n即除最后一次做二路归并外，其他各次归并仍是3路归并，此归并方案的1/0次数为386。显然，\n这不是最佳方案。正确的做法是：若初始归并段不足以构成一棵严格k叉树（也称正则k叉树）\n时，则需添加长度为0的“虚段”，按照哈夫曼树的原则，权为0的叶子应离树根最远。因此，\n最佳归并树应如图8.20所示，此时的1/0次数仅为326。\n图8.208个归并段的最佳归并树\n如何判定添加虚段的数目？\n设度为0的结点有no个，度为k的结点有nk个，归并树的结点总数为n，则有：\nn=nk+no\n（总结点数=度为k的结点数+度为0的结点数）\nn=knk+1\n（总结点数=所有结点的度数之和+1）\n因此，对严格k叉树有no=(k-1)nk+1，由此可得nk=(no-1)/(k-1)。\n若(n。-1)%(k-1)=0（%为取模运算)，则说明这ng个叶结点（初始归并段）正好可以\n构造k叉归并树。此时，内结点有nk个。\n若(ng-1)%（k-1)=u≠0，则说明对于这no个叶结点，其中有u个多余，不能包含在k\n叉归并树中。为构造包含所有no个初始归并段的k叉归并树，应在原有nk个内结点的\n\n392\n2026年数据结构考研复习指导\n基础上再增加1个内结点。它在归并树中代替了一个叶结点的位置，被代替的叶结点加\n上刚才多出的u个叶结点，即再加上k-u-1个空归并段，就可以建立归并树。\n命题追踪实现最佳归并时需补充的虚段数量的分析（2019）\n以图8.20为例，用8个归并段构成3叉树，（ng-1)%(k-1)=(8-1)%(3-1)=1，说明7个归\n并段刚好可以构成一棵严格3叉树（假设把以5为根的树视为一个叶子）。为此，将叶子5变成\n一个内结点，再添加3-1-1=1个空归并段，就可以构成一棵严格3叉树。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    }
]