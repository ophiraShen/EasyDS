[
    {
        "id": "kc0511",
        "title": "树的定义",
        "chapter_id": "c05",
        "description": "树是n（n≥0）个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：\n1）有且仅有一个特定的称为根的结点。\n\n第5章树与二叉树\n125\n2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T，T2,·\"，Tm，其中每个集\n合本身又是一棵树，并且称为根的子树。\n显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树\n作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：\n1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。\n2）树中所有结点都可以有零个或多个后继。\n树适用于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个\n结点（其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边。\n而树中每个结点与其下一层的零个或多个结点（其孩子结点）都有直接关系。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q051001"
        ]
    },
    {
        "id": "kc0512",
        "title": "基本术语",
        "chapter_id": "c05",
        "description": "下面结合图5.1中的树来说明一些基本术语和概念。\n第1层\n第2层\n高度为4\n第3层\n第4层\n图5.1树的树形表示\n1）祖先、子孙、双亲、孩子、兄弟和堂兄弟。\n考虑结点K，从根A到结点K的唯一路径上的所有其他结点，称为结点K的祖先。如结\n点B是结点K的祖先，而K是B的子孙，结点B的子孙包括E，F，K，L。路径上最接近\n结点K的结点E称为K的双亲，而K为E的孩子。根A是树中唯一没有双亲的结点。有\n相同双亲的结点称为兄弟，如结点K和结点L有相同的双亲E，即K和L为兄弟。双亲\n在同一层的结点互为堂兄弟，结点G与E，F,H,I,J互为堂兄弟。\n2）结点的层次、深度和高度。\n结点的层次从树根开始定义，根结点为第1层，它的孩子为第2层，以此类推。结点的\n深度就是结点所在的层次。树的高度（或深度）是树中结点的最大层数。结点的高度是\n以该结点为根的子树的高度。图5.1中树的高度为4。\n3）结点的度和树的度。\n树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。如结点B\n的度为2，结点D的度为3，树的度为3。\n4）分支结点和叶结点。\n度大于0的结点称为分支结点（也称非终端结点）：度为0（没有孩子结点）的结点称为\n叶结点（也称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。\n5）有序树和无序树。\n树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。\n假设图5.1为有序树，若将子结点位置互换，则变成一棵不同的树。\n6）路径和路径长度。\n树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是\n路径上所经过的边的个数。\n\n126\n2026年数据结构考研复习指导\n注意\n因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩\n子之间不存在路径。\n7）森林。\n命题追踪森林中树的数量、边数和结点数的关系（2016）\n森林是m（m≥0）棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要\n把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵\n树作为该结点的子树，则森林就变成了树。\n注意\n上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题\n目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q051001"
        ]
    },
    {
        "id": "kc0513",
        "title": "树的性质",
        "chapter_id": "c05",
        "description": "树具有如下最基本的性质：\n命题追踪树中结点数和度数的关系的应用（2010、2016）\n1）树的结点数n等于所有结点的度数之和加1。\n结点的度是指该结点的孩子数量，每个结点与其每个孩子都由唯一的边相连，因此树中\n所有结点的度数之和等于树中的边数之和。树中的结点（除根外）都有唯一的双亲，因\n此结点数n等于边数之和加1，即所有结点的度数之和加1。\n2）度为m的树中第i层上至多有m-1个结点（i≥1）。\n第1层至多有1个结点（根结点），第2层至多有m个结点，第3层至多有m²个结点，\n以此类推。使用数学归纳法可推出第i层至多有㎡-!个结点。\n3）高度为h的m叉树至多有（m-1）/（m-1)个结点。\n当各层结点数达到最大时，树中至多有1+m+㎡²+…+m-1=（m-1)/（m-1)个结点。\n命题追踪指定结点数的三叉树的最小高度分析（2022）\n4）度为m、具有n个结点的树的最小高度h为[logm(n(m-1)+ 1)]。\n为使树的高度最小，在前h-1层中，每层的结点数都要达到最大，前h-1层最多有\n(m-1-1)/(m-1)个结点，前h层最多有(m²-1)/(m-1)个结点。因此（m²--1)/(m-1)<n≤\n(m-1) /(m-1)，即h-1 <logm(n(m-1)+ 1)≤h，解得hmin=[1ogm(n(m-1)+ 1)]。\n5）度为m、具有n个结点的树的最大高度h为n-m+1。\n树的度为m，因此至少有一个结点有㎡个孩子，它们处于同一层。为使树的高度最大，\n其他层可仅有一个结点，因此最大高度（层数）为n-m+1。由此，也可逆推出高度为h、\n度为m的树至少有h+m-1个结点。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q051001"
        ]
    },
    {
        "id": "kc0521",
        "title": "二叉树的定义及其主要特性",
        "chapter_id": "c05",
        "description": "1.二叉树的定义\n二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（二叉树中不存在度大\n于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。\n与树相似，二叉树也以递归的形式定义。二叉树是n（n≥0）个结点的有限集合：\n①或者为空二叉树，即n=0。\n②或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树\n又分别是一棵二叉树。\n二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有\n一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图5.2所示。\n(a)空二义树(b)只有根结点\n(c)只有左子树\n(d)左右子树都有\n(e)只有右子树\n图5.2二叉树的5种基本形态\n二叉树与度为2的有序树的区别：\n①度为2的树至少有3个结点，而二叉树可以为空。\n②度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩\n子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左\n右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。\n2.几种特殊的二叉树\n1）满二叉树。一棵高度为h，且有2\"-1个结点的二叉树称为满二叉树，即二叉树中的每层\n都含有最多的结点，如图5.3（a）所示。满二叉树的叶结点都集中在二叉树的最下一层，并\n且除叶结点之外的每个结点度数均为2。\n可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左\n向右。这样，每个结点对应一个编号，对于编号为i的结点，若有双亲，则其双亲为i/2」，\n若有左孩子，则左孩子为2i；若有右孩子，则右孩子为2i+1。\n\n第5章树与二叉树\n131\n命题追踪完全二叉树中结点数和叶结点数的关系（2009、2011、2018）\n2）完全二叉树。高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的\n满二叉树中编号为1～n的结点一一对应时，称为完全二叉树，如图5.3（b)所示。\n(a)满二叉树\n(b)完全二叉树\n图5.3两种特殊形态的二叉树\n3）二叉排序树。左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的\n关键字均大于根结点的关键字：左子树和右子树又各是一棵二叉排序树。\n4）平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。关于二\n叉排序树和平衡二叉树的详细介绍，见本书中的7.3节。\n命题追踪正则k叉树树高和结点数的关系的应用（2016）\n5）正则二叉树。树中每个分支结点都有2个孩子，即树中只有度为0或2的结点。\n3.二叉树的性质\n1）非空二叉树上的叶结点数等于度为2的结点数加1，即no=n2+1。\n证明：设度为0,1和2的结点个数分别为no,n和n2，结点总数n=no+n+n2。\n再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设B为分支总数，\n则n=B+1。这些分支是由度为1或2的结点射出的，因此又有B=n+2n2。\n于是得no+n+n2=n+2n+1，则no=n2+1。\n注意\n该性质经常在选择题中涉及，希望读者牢记并灵活应用。\n2）非空二叉树的第k层最多有2k-1个结点（k≥1)。\n第1层最多有2-1=1个结点（根），第2层最多有22-1=2个结点，以此类推，可以证明\n其为一个公比为2的等比数列21。\n3）高度为h的二叉树至多有2-1个结点（h≥1）。\n该性质利用性质2求前h项的和，即等比数列求和的结果。\n注意\n性质2和性质3还可以拓展到m叉树的情况，即m叉树的第k层最多有m个个结点，高度为h的m\n叉树至多有（m-1）/（m-1）个结点。\n4）对完全二叉树按从上到下、从左到右的顺序依次编号1,2,,n，则有以下关系：\n①最后一个分支结点的编号为[n/2]，若i≤Ln/2]，则结点i为分支结点，否则为叶结点。\n①完全二叉树可视为从满二叉树中删去若干最底层、最右边的一些连续叶结点后所得到的二叉树。\n\n132\n2026年数据结构考研复习指导\n②叶结点只可能在最后两层上出现（相当于在相同高度的满二叉树的最底层、最右边减\n③若有度为1的结点，则最多只可能有一个，且该结点只有左孩子而无右孩子（度为1\n的分支结点只可能是最后一个分支结点，其结点编号为[n/2」）。\n④按层序编号后，一旦出现某结点（如编号i）为叶结点或只有左孩子的情况，则编号\n大于i的结点均为叶结点（与结论①和结论③是相通的）。\n若n为奇数，则每个分支结点都有左、右孩子：若n为偶数，则编号最大的分支结点\n（编号为n/2）只有左孩子，没有右孩子，其余分支结点都有左、右孩子。\n当i>1时，结点i的双亲结点的编号为i/2]。\n若结点i有左、右孩子，则左孩子编号为2i，右孩子编号为2i+1。\n⑧结点i所在层次（深度）为[log2i+1。\n5）具有n个（n>0）结点的完全二叉树的高度为「log2（n+1)]或Llog2n」+1。\n设高度为h，根据性质3和完全二叉树的定义有\n2\"-l-1<n≤2-1或者2\"-1≤n<2h\n得21<n+ 1≤2\"，即h-1<log2(n+1)≤h，因为h为正整数，所以h=[log2(n+ 1)]，\n或者得h-1≤log2n<h，所以h=Llog2n」+1。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q052002",
            "q052003",
            "q052005",
            "q052006",
            "q052008",
            "q052009",
            "q052011",
            "q052012",
            "q052013",
            "q052014",
            "q052015",
            "q052017",
            "q052019",
            "q052021",
            "q052022",
            "q052023",
            "q052025",
            "q052026",
            "q052027",
            "q052028",
            "q052029"
        ]
    },
    {
        "id": "kc0522",
        "title": "二叉树的存储结构",
        "chapter_id": "c05",
        "description": "1.顺序存储结构\n二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的\n结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中。\n依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯\n地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值\n确定结点在二叉树中的位置，以及结点之间的关系。\n命题追踪特定条件下二叉树树形及占用存储空间的分析（2020）\n但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些\n并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量\n中。然而，在最坏情况下，一个高度为h且只有h个结点的单支树却需要占据近2\"-1个存储单\n元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。\n123456789\n[9 0l0 s 0 + 0 e1\n(a)完全二叉树的顺序存储结构\n(b)一般二叉树的顺序存储结构\n图5.4二叉树的顺序存储结构\n注意\n建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。\n\n第5章树与二叉树\n133\n2.链式存储结构\n顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉\n树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含\n3个域：数据域data、左指针域1child和右指针域rchild，如图5.5所示。\nlchild\ndata\nrchild\n图5.5\n二叉树链式存储的结点结构\n图5.6所示为一棵二叉树及其对应的二叉链表。而实际上在不同的应用中，还可以增加某些\n指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。\n4\n图5.6\n二叉链表的存储结构\n二叉树的链式存储结构描述如下：\ntypedef struct BiTNodet\nElemType data;\n//数据域\nstruct BiTNode\n*1child,*rchild;\nⅡ/左、右孩子指针\n)BiTNode,*BiTree;\n使用不同的存储结构时，实现二叉树操作的算法也会不同，因此要根据实际应用场合（二叉\n树的形态和需要进行的运算）来选择合适的存储结构。\n容易验证，在含有n个结点的二叉链表中，含有n+1个空链域（重要结论，经常出现在选\n择题中）。在下一节中，我们将利用这些空链域来组成另一种链表结构一一线索链表。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q052002",
            "q052003",
            "q052005",
            "q052006",
            "q052008",
            "q052009",
            "q052011",
            "q052012",
            "q052013",
            "q052014",
            "q052015",
            "q052017",
            "q052019",
            "q052021",
            "q052022",
            "q052023",
            "q052025",
            "q052026",
            "q052027",
            "q052028",
            "q052029"
        ]
    },
    {
        "id": "kc0531",
        "title": "二叉树的遍历",
        "chapter_id": "c05",
        "description": "二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅\n被访问一次。二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，\n以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。\n命题追踪二叉树遍历方式的分析（2009、2011、2012）\n命题追踪（算法题）二叉树遍历的相关应用（2014、2017、2022）\n由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访\n问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）\n和后序（LRN）三种遍历算法，其中序指的是根结点在何时被访问。\n\n第5章树与二叉树\n141\n1．先序遍历（PreOrder）\n若二叉树为空，则什么也不做：否则，公众号：小兔网盘免费分享无水印PDF\n1）访问根结点；\n2）先序遍历左子树：\n3）先序遍历右子树。\n图5.7中的虚线表示对该二叉树进行先序遍历的路径，得到先序遍历序列为124635。\n开始\n图5.7二叉树的先序遍历\n对应的递归算法如下：\nvoid PreOrder(BiTreeT){\nif(T!=NULL）{\nvisit(T);\n/访问根结点\nPreOrder(T->lchild);\n//递归遍历左子树\nPreOrder(T->rchild);\n//递归遍历右子树\n2.中序遍历（InOrder）\n若二叉树为空，则什么也不做；否则，\n1）中序遍历左子树；\n2）访问根结点；\n3）中序遍历右子树。\n命题追踪\n中序序列中结点关系的分析（2017、2024）\n图5.8中的虚线表示对该二叉树进行中序遍历的路径，得到中序遍历序列为264135。\n开始（\n结束\n图5.8二叉树的中序遍历\n对应的递归算法如下：\nvoid InOrder(BiTree T){\nif（T!=NULL）{\nInOrder(T->lchild);\n/递归遍历左子树\n\n142\n2026年数据结构考研复习指导\nvisit(T);\n/访问根结点\nInOrder(T->rchild);\n/递归遍历右子树\n3.后序遍历（PostOrder）\n若二叉树为空，则什么也不做：否则，\n1）后序遍历左子树；\n2）后序遍历右子树；\n3）访问根结点。\n图5.9中的虚线表示对该二叉树进行后序遍历的路径，得到后序遍历序列为642531。\n结束\n开始\n图5.9二叉树的后序遍历\n对应的递归算法如下：\nvoid PostOrder(BiTree T){\nif（T!=NULL){\nPostOrder(T->lchild);\n/递归遍历左子树\nPostOrder(T->rchild);\n/递归遍历右子树\nvisit(T);\n/访问根结点\n上述三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。\n不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，所以时间复杂度都是O(n)。在递归\n遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为\nn的单支树，遍历算法的空间复杂度为O（n)。\n4.层次遍历\n图5.10所示为二叉树的层次遍历，即按照箭头所指方向，按照1,2，3，4的层次顺序，自上而\n下、从左至右对二叉树中的各个结点进行逐层访问。\n图5.10二叉树的层次遍历\n进行层次遍历时，需要借助一个队列。层次遍历的思想如下：①首先将根结点入队。②若队\n\n第5章树与二叉树\n143\n列非空，则队头结点出队，访问该结点，若它有左孩子，则将其左孩子入队；若它有右孩子，则\n将其右孩子入队。③重复步骤②，直至队列为空。\n二叉树的层次遍历算法如下：\nvoid LevelOrder(BiTree T){\nInitQueue(Q);\n//初始化辅助队列\nBiTree p;\nEnQueue(Q,T);\n/将根结点入队\nwhile(!IsEmpty(Q))(\n/队列不空则循环\nDeQueue(Q,p);\n/队头结点出队\nvisit(p);\n/访问出队结点\nif(p->lchild!=NULL)\nEnQueue(Q,p->lchild);\n//若左孩子不空，则左孩子入队\nif(p->rchild!=NULL)\nEnQueue(Q,p->rchild);\n//若右孩子不空，则右孩子入队\n在复习过程中，读者应将上述二叉树层次遍历的算法作为一个模板，熟练掌握其执行过程，\n并达到熟练手写的程度。\n注意\n遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树\n的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此\n必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。\n5.由遍历序列构造二叉树\n命题追踪\n先序序列对应的不同二叉树的分析（2015）\n对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是确定的。然而，\n只给出四种遍历序列中的任意一种，却不能唯一地确定一棵二叉树。若已知中序序列，再给出其\n他三种遍历序列中的任意一种，就可以唯一地确定一棵二叉树。\n（1）由先序序列和中序序列构造二叉树\n命题追踪先序序列和中序序列相同时确定的二叉树（2017）\n命题追踪由先序序列和中序序列构造一棵二叉树（2020、2021）\n在先序序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序\n列分割成两个子序列，前一个子序列是根的左子树的中序序列，后一个子序列是根的右子树的中\n序序列。左子树的中序序列和先序序列的长度是相等的，右子树的中序序列和先序序列的长度是\n相等的。根据这两个子序列，可以在先序序列中找到左子树的先序序列和右子树的先序序列，如\n图5.11所示。如此递归地分解下去，便能唯一地确定这棵二叉树。\n先序序列\n根\n（左子树的先序序列\n【右子树的先序序列\n左子树\n右子树\n中序序列\n【左子树的中序序列\n根\n【右子树的中序序列\n图5.11由先序序列和中序序列构造二叉树\n\n144\n2026年数据结构考研复习指导\n例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。首先，由\n先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列，EDGHFI为\n右子树的中序序列。然后，由先序序列可知B是左子树的根结点，D是右子树的根结点。以此类\n推，就能将剩下的结点继续分解下去，最后得到的二叉树如图5.12（c）所示。\n(a)\n(b)\n(c)\n图5.12\n2一棵二叉树的构造过程\n（2）由后序序列和中序序列构造二叉树\n命题追踪由后序序列和树形构造一棵二叉树（2017、2023）\n同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。因为后序序列的最后\n一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，如图5.13所示，然\n后采用类似的方法递归地进行分解，进而唯一地确定这棵二叉树。\n后序序列\n左子树的后序序列\n右子树的后序序列\n根\n1/\n左子树\n右子树\n中序序列\n左子树的中序序列\n右子树的中序序列\n图5.13由后序序列和中序序列构造二叉树\n请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。\n（3）由层序序列和中序序列构造二叉树\n在层序遍历中，第一个结点一定是二叉树的根结点，这样就将中序序列分割成了左子树的中\n序序列和右子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可进\n步划分左子树；若存在右子树，则层序序列中紧接着的下一个结点一定是右子树的根，可进一\n步划分右子树，如图5.14所示。采用这种方法继续分解，就能唯一确定这棵二叉树。\n层序序列\n根\n【左子树的根】[右子树的根】\n左子树\n右子树\n中序序列\n左子树的中序序列\n右子树的中序序列\n图5.14由层序序列和中序序列构造二叉树\n请读者分析层序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。\n注意，先序序列、后序序列和层序序列的两两组合，无法唯一确定一棵二叉树。例如，图5.15\n所示的两棵二叉树的先序序列都为AB，后序序列都为BA，层序序列都为AB。\n\n第5章\n树与二叉树\n145\n(a)\n(b)\n图5.15两棵不同的二叉树",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q053001",
            "q053002",
            "q053003",
            "q053004",
            "q053005",
            "q053006",
            "q053007",
            "q053008",
            "q053011",
            "q053012",
            "q053013",
            "q053014",
            "q053015",
            "q053016",
            "q053017",
            "q053018",
            "q053020",
            "q053021",
            "q053022",
            "q053023",
            "q053024",
            "q053025",
            "q053026",
            "q053027",
            "q053028",
            "q053029",
            "q053030",
            "q053032",
            "q053034",
            "q053035",
            "q053036"
        ]
    },
    {
        "id": "kc0532",
        "title": "线索二叉树",
        "chapter_id": "c05",
        "description": "1.线索二叉树的基本概念\n遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序\n列，使得该序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。\n命题追踪线索二叉树的定义（2010）\n传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提\n到，在含n个结点的二叉树中，有n+1个空指针。这是因为每个叶结点都有2个空指针，每个度为1\n的结点都有1个空指针，空指针总数为2ng+n，又no=n+1，所以空指针总数为ng+n+n+1=n+1。\n由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地\n遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。\n规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。\n如图5.16所示，还需增加两个标志域，以标识指针域指向左（右）孩子或前驱（后继）。\nlchild\nltag\ndata\nrtag\nrchild\n图5.16线索二叉树的结点结构\n其中，标志域的含义如下：\n[0,\nlchild域指示结点的左孩子\nltag\n[1,\nlchild域指示结点的前驱\n[0,\nrchild域指示结点的右孩子\n[1，\nrchild域指示结点的后继\n线索二叉树的存储结构描述如下：\ntypedef struct ThreadNode{\nElemType data;\n//数据元素\nstruct ThreadNode *lchild,*rchild;\n//左、右孩子指针\nint ltag,rtag;\n//左、右线索标志\n)ThreadNode,*ThreadTree;\n以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表，其中指向结点前驱\n和后继的指针称为线索。加上线索的二叉树称为线索二叉树。\n2.中序线索二叉树的构造\n二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息\n只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。\n命题追踪\n中序线索二叉树中线索的指向（2014）\n以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针p指向正在访\n问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就\n将它指向pre；检查pre的右指针是否为空，若为空就将它指向p，如图5.17所示。\n\n146\n2026年数据结构考研复习指导\n|1Di]\n1EL\n图5.17中序线索二叉树及其二叉链表示\n通过中序遍历对二叉树线索化的递归算法如下：\nvoid InThread(ThreadTree &p,ThreadTree&pre)(\nif（p!=NULL){\nInThread(p->lchild,pre);\n/递归，线索化左子树\nif (p->lchild==NULL){\n//当前结点的左子树为空\np->lchild=pre;\n/建立当前结点的前驱线索\np->ltag=l;\nif（pre!=NULL&&pre->rchild==NULL）（//前驱结点非空且其右子树为空\npre->rchild=p;\n/建立前驱结点的后继线索\npre->rtag=l;\npre=p;\n/标记当前结点成为刚刚访问过的结点\nInThread(p->rchild,pre);\n//递归，线索化右子树\n通过中序遍历建立中序线索二叉树的主过程算法如下：\nvoid CreateInThread(ThreadTree T)(\nThreadTree pre=NULL;\nif（T!=NULL){\n/非空二叉树，线索化\nInThread(T,pre);\n//线索化二叉树\npre->rchild=NULL;\nⅡ/处理遍历的最后一个结点\npre->rtag=1;\n为方便起见，可在二叉树的线索链表上也添加一个头结点，令其1child域的指针指向二叉\n树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点：令二叉树中序序列中的\n第一个结点的1child域指针和最后一个结点的rchild域指针均指向头结点。这好比为二叉树\n建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历，如图5.18所示。\nHead\nD\nE\n图5.18带头结点的中序线索二叉树\n\n第5章树与二叉树\n147\n3.中序线索二叉树的遍历\n中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先\n找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结\n点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访\n问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。\n1）求中序线索二叉树的中序序列下的第一个结点：\nThreadNode *Firstnode(ThreadNode *p){\nwhile（p->ltag==0）p=p->lchild;//最左下结点（不一定是叶结点）\nreturn p;\n2）求中序线索二叉树中结点p在中序序列下的后继：\nThreadNode*Nextnode(ThreadNode*p)(\nif(p->rtag==0）return Firstnode(p->rchild）；//右子树中最左下结点\nelse return p->rchild;\nl//若rtag==1则直接返回后继线索\n请读者自行分析并完成求中序线索二叉树的最后一个结点和结点p前驱的运算?。\n3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法：\nvoid Inorder(ThreadNode *T){\nfor（ThreadNode*p=Firstnode（T);p!=NULL;p=Nextnode(p))\nvisit(p);\n4.先序线索二叉树和后序线索二叉树\n上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码\n类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。\n以图5.19(a)的二叉树为例给出手工求先序线索二叉树的过程：先序序列为ABCDF，然后依\n次判断每个结点的左右链域，若为空，则将其改造为线索。结点A，B均有左右孩子；结点C无左\n孩子，将左链域指向前驱B，无右孩子，将右链域指向后继D：结点D无左孩子，将左链域指向\n前驱C，无右孩子，将右链域指向后继F；结点F无左孩子，将左链域指向前驱D，无右孩子，\n也无后继，所以置空，得到的先序线索二叉树如图5.19（b)所示。求后序线索二叉树的过程：后序\n序列为CDBFA，结点C无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继D；结\n点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B；结点F无左孩子，将左\n链域指向前驱B，无右孩子，将右链域指向后继A，得到的后序线索二叉树如图5.19（c）所示。\n小兔网盘\n免费网课+无水印PDF\n(a)一颗二叉树\n(b)先序线索二叉树\n(c)后序线索二叉树\n图5.19先序线索二叉树和后序线索二叉树\n如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但\n有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。\nltag和1child，此外调用函数改为求左了树的中序线索二叉树的最后个结点，即求中序线索二叉树中结点p的前驱。\n\n148\n2026年数据结构考研复习指导\n命题追踪后序线索二叉树中线索的指向（2013）\n在后序线索二叉树中找结点的后继较为复杂，可分三种情况：①若结点x是二叉树的根，则\n其后继为空：②若结点x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后\n继即双亲：③若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后\n序遍历列出的第一个结点。图5.19（c)中找结点B的后继无法通过链域找到，可见在后序线索二叉\n树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q053001",
            "q053002",
            "q053003",
            "q053004",
            "q053005",
            "q053006",
            "q053007",
            "q053008",
            "q053011",
            "q053012",
            "q053013",
            "q053014",
            "q053015",
            "q053016",
            "q053017",
            "q053018",
            "q053020",
            "q053021",
            "q053022",
            "q053023",
            "q053024",
            "q053025",
            "q053026",
            "q053027",
            "q053028",
            "q053029",
            "q053030",
            "q053032",
            "q053034",
            "q053035",
            "q053036"
        ]
    },
    {
        "id": "kc0541",
        "title": "树的存储结构",
        "chapter_id": "c05",
        "description": "树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存\n储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍3种常用的存储结构。\n1.双亲表示法\n这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示\n其双亲结点在数组中的位置。如图5.20所示，根结点下标为0，其伪指针域为-1。\n双亲表示法的存储结构描述如下：\n#define MAX_TREE_SIZE 100\n/树中最多结点数\n//树的结点定义\ntypedef struct{\nElemType data;\n//数据元素\nint parent;\n//双亲位置域\n)PTNode;\ntypedef struct{\n//树的类型定义\nPTNode nodes[MAX_TREE_SIZE];\nI/双亲表示\nint n;\n//结点数\n)PTree;\ndata\nparent\nR\n-1\nA\n0\n2\nB\n0\nC\n0\nD\nE\n1\nF\n6\nH\n6\nK\n6\n(a)一棵树\n（b）双亲表示\n(c)双亲指针图示\n图5.20树的双亲表示法\n双亲表示法利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点\n的双亲结点，但求结点的孩子时则需要遍历整个结构\n\n172\n2026年数据结构考研复习指导\n注意\n区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编\n号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点\n的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构\n来存储，但树却不都能用二叉树的存储结构来存储。\n2.孩子表示法\n找，可采用顺序存储结构。图5.21（a)是图5.20（a)中的树的孩子表示法。\n3\nR\nB\nE\nD\nM\n(a）孩子表示法\n（b）孩子兄弟表示法\n图5.21树的孩子表示法和孩子兄弟表示法\n与双亲表示法相反，孩子表示法寻找孩子的操作非常方便，而寻找双亲的操作则需要遍历n\n个结点中孩子链表指针域所指向的n个孩子链表。\n3.孩子兄弟表示法\n孩子兄弟表示法也称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每\n个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结\n点的指针（沿此域可以找到结点的所有兄弟结点），如图5.21(b）所示。\n孩子兄弟表示法的存储结构描述如下：\ntypedef struct CsNodet\nElemType data;\n/数据域\nstruct CSNode\n*firstchild,*nextsibling;\n/第一个孩子和右兄弟指针\n)CSNode,*CSTree;\n孩子兄弟表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查\n找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent\n域指向其父结点，则查找结点的父结点也很方便。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ]
    },
    {
        "id": "kc0542",
        "title": "树、森林与二叉树的转换",
        "chapter_id": "c05",
        "description": "二叉树和树都可以用二叉链表作为存储结构。从物理结构上看，树的孩子兄弟表示法与二叉\n树的二叉链表表示法是相同的，因此可以用同一存储结构的不同解释将一棵树转换为二叉树。\n\n第5章树与二叉树\n173\n1.树转换为二叉树\n命题追踪树和二叉树的转换及相关性质的推理（2009、2011）\n树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子，右指针指向它在树中的相\n邻右兄弟，这个规则也称左孩子右兄弟。根结点没有兄弟，因此树转换得到的二叉树没有右子树，\n如图5.22所示。\nG\n图5.22树与二叉树的对应关系\n树转换为二叉树的画法：\n1）在兄弟结点之间加一连线：\n2）对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；\n3）以树根为轴心，顺时针旋转45°。\n2.森林转换为二叉树\n命题追踪）森林和二叉树的转换及相关性质的推理（2014）\n将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任意一棵树\n对应的二叉树的右子树必空，森林中各棵树的根也可视为兄弟关系，将第二棵树对应的二叉树当\n作第一棵二叉树根的右子树…·以此类推，就可以将森林转换为二叉树。\n森林转换为二叉树的画法：\n1）将森林中的每棵树转换成相应的二叉树；\n2）每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；\n3）以第一棵树的根为轴心顺时针旋转45°。\n或者先在森林中每棵树的根之间加一根连线，然后再采用树转换为二叉树的方法。\n3.二叉树转换为森林\n命题追踪由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）\n二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形\n式，所以将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉\n树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后将每棵二叉树依次转换\n\n174\n2026年数据结构考研复习指导\n成树，就得到了原森林，如图5.23所示。二叉树转换为树或森林是唯一的。\n森林与\n叉树对应\n叉树对应\nH\n树根相连并旋转\n图5.23森林与二叉树的对应关系",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ]
    },
    {
        "id": "kc0543",
        "title": "树和森林的遍历",
        "chapter_id": "c05",
        "description": "1.树的遍历\n命题追踪树与二叉树遍历方法的对应关系（2019）\n树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式：\n1）先根遍历。若树非空，则按如下规则遍历：\n·先访问根结点。\n·再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。\n其遍历序列与这棵树相应二叉树的先序序列相同。\n2）后根遍历。若树非空，则按如下规则遍历：\n·先依次遍历根结点的每棵子树，遍历子树时仍遵循先子树后根的规则。\n·再访问根结点。\n其遍历序列与这棵树相应二叉树的中序序列相同。\n图5.22的树的先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA。\n另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。\n2.森林的遍历\n按照森林和树相互递归的定义，可得到森林的两种遍历方法。\n1）先序遍历森林。若森林为非空，则按如下规则遍历：\n·访问森林中第一棵树的根结点。\n）先序遍历第一棵树中根结点的子树森林。\n·先序遍历除去第一棵树之后剩余的树构成的森林。\n2）中序遍历森林。森林为非空时，按如下规则遍历：\n·中序遍历森林中第一棵树的根结点的子树森林。\n·访问第一棵树的根结点。\n·中序遍历除去第一棵树之后剩余的树构成的森林。\n图5.23的森林的先序遍历序列为ABCDEFGHI，中序遍历序列为BCDAFEHIG。\n命题追踪森林与二叉树遍历方法的对应关系（2020）\n当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，\n\n第5章树与二叉树\n175\n可知森林的先序和中序遍历即其对应二叉树的先序和中序遍历。\n树和森林的遍历与二叉树的遍历关系见表5.1。\n表5.1树和森林的遍历与二叉树遍历的对应关系\n树\n森\n林\n二叉树\n先根遍历\n先序遍历\n先序遍历\n后根遍历\n中序遍历\n中序遍历\n注意\n森林的遍历方法的命名按照严蔚敏老师的经典教材。有些教材也将森林的中序遍历称为后序遍历，\n称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q054002",
            "q054004",
            "q054005",
            "q054006",
            "q054007",
            "q054008",
            "q054009",
            "q054010",
            "q054011",
            "q054012",
            "q054013",
            "q054014",
            "q054015",
            "q054016",
            "q054017"
        ]
    },
    {
        "id": "kc0551",
        "title": "哈夫曼树和哈夫曼编码",
        "chapter_id": "c05",
        "description": "1.哈夫曼树的定义\n在介绍哈夫曼树之前，先介绍几个相关的概念：\n在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。\n从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。\n树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为\nWPL=\ni=1\n式中，w是第i个叶结点所带的权值，1是该叶结点到根结点的路径长度。\n在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，\n也称最优二叉树。例如，图5.24中的3棵二叉树都有4个叶结点α,b,c,d，分别带权7，5，2,4，\n它们的带权路径长度分别为\n\n184\n2026年数据结构考研复习指导\n(a)\n(b)\n(C)\n图5.24具有不同带权长度的二叉树\n(a)WPL=7×2+5×2+2×2+4×2=36。\n(b）WPL=4×2+7×3+5×3+2×1=46。\n(c)WPL=7×1+5×2+2×3+4×3=35。\n其中，图5.24(c)树的WPL最小。可以验证，它恰好为哈夫曼树。\n2.哈夫曼树的构造\n给定n个权值分别为w,W2,\",W,的结点，构造哈夫曼树的算法描述如下：\n1）将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。\n命题追踪分析哈夫曼树的路径上权值序列的合法性（2010）\n2）构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且\n将新结点的权值置为左、右子树上根结点的权值之和。公众号：小兔网盘免费分享无水印PDF\n3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n4）重复步骤2）和3），直至F中只剩下一棵树为止。\n命题追踪哈夫曼树的性质（2010、2019）\n从上述构造过程中可以看出哈夫曼树具有如下特点：\n1）每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。\n2）构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。\n3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。\n例如，权值7.5,2,4的哈夫曼树的构造过程如图5.25所示。\n(a)\n(b)\n(c)\n(P\n图5.25哈夫曼树的构造过程\n3.哈夫曼编码\n在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。\n若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。可变长度编码\n比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较\n长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。\n\n第5章树与二叉树\n185\n命题追踪根据哈夫曼编码对编码序列进行译码（2017）\n若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。举例：设计字符A，B\n和C对应的编码0，10和110是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他\n编码的前缀。所以识别出第一个编码，将它翻译为原字符，再对剩余的码中执行同样的解码操作。\n例如，码串0010110可被唯一地翻译为A，A，B和C。另举反例：若再将字符D的编码设计为11，\n此时11是110的前缀，则上述码串的后三位就无法唯一翻译。\n命题追踪哈夫曼树的构造及相关的分析（2012、2018、2021、2023）\n命题追踪前缀编码的分析及应用（2014、2020）\n可以利用二叉树来设计二进制前缀编码。假设为A，B，C，D四个字符设计前缀编码，可以用\n图5.26所示的二叉树来表示，4个叶结点分别表示4个字符，且约定左分支表示0，右分支表示\n1，从根到叶结点的路径上用分支标记组成的序列作为该叶结点字符的编码，可以证明如此得到\n的必为前缀编码。由图5.26得到字符A，B,C，D的前缀编码分别为0,10,110，111。\n编码A(0)\nB(10)\nC(110)\nD(I11)\n图5.26前缀编码示例\n命题追踪哈夫曼编码和定长编码的差异（2022）\n哈夫曼编码是一种非常有效的数据压缩编码。由哈夫曼树得到哈夫曼编码是很自然的过程。\n首先，将每个字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫\n曼树。然后，将从根到叶结点的路径上分支标记的字符串作为该字符的编码。图5.27所示为一个\n由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。\n各字符编码为\na:0\nb:101\nc:100\nd:111\ne:1101\nf:1100\n图5.27由哈夫曼树构造哈夫曼编码\n这棵哈夫曼树的WPL为\nWPL=1×45+3×（13+12+16)+4×(5+9）=224\n此处的WPL可视为最终编码得到二进制编码的长度，共224位。若采用3位固定长度编码，则\n得到的二进制编码长度为300位，因此哈夫曼编码共压缩了25%的数据。利用哈夫曼树可以设计\n出总长度最短的二进制前缀编码。\n\n186\n2026年数据结构考研复习指导\n注意\n左分支和右分支究竟是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈\n夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可\n能不同，但WPL必然相同且为最优。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q055001",
            "q055002",
            "q055003",
            "q055004",
            "q055005",
            "q055006",
            "q055007",
            "q055009",
            "q055010",
            "q055011",
            "q055012",
            "q055013",
            "q055014",
            "q055015",
            "q055016",
            "q055017",
            "q055018"
        ]
    },
    {
        "id": "kc0552",
        "title": "并查集",
        "chapter_id": "c05",
        "description": "1.并查集的概念\n并查集是一种简单的集合表示，它支持以下3种操作：\n1）Initial（S）：将集合s中的每个元素都初始化为只有一个单元素的子集合。\n2）Union（S,Root1,Root2）：把集合s中的子集合Root2并入子集合Rootl。要求Root1\n和Root2互不相交，否则不执行合并。\n3）Find（S，x）：查找集合S中单元素x所在的子集合，并返回该子集合的根结点。\n2.并查集的存储结构\n树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根\n结点的下标代表子集合名，根结点的双亲域为负数（可设置为该子集合元素数量的相反数）。\n例如，若设有一个全集合为S={0,1,2,3,4,5,6,7,8,9}，初始化时每个元素自成一个单元素\n子集合，每个子集合的数组值为-1，如图5.28所示。\n(a)全集合S初始化时形成一个森林\n01234567\n|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|\n(b)初始化时形成的(森林)双亲表示\n图5.28并查集的初始化\nS={2.3,5}，此时并查集的树形和存储结构如图5.29所示。\n集合的树形表示\n2\n-3|-31211|210|\n(b)集合S、S和S的（森林）双亲表示\n图5.29用树表示并查集\n为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根结\n点。因此，SUS可以具有如图5.30所示的表示。\n0101\n图5.30SUS可能的表示方法\n\n第5章树与二叉树\n187\n在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。\n其中SIZE是最大元素的个数。\n3.并查集的基本实现\n并查集的结构定义如下：\n#define SIZE 100\nint\nUFSets[SIZE];\n//集合元素数组（双亲指针数组）\n下面是并查集主要运算的实现。\n（1）并查集的初始化操作\nvoid Initial(int S[]){\nI/s即并查集\nfor（int i=0;i<SIzE;i++)\n//每个自成单元素集合\nS[i]=-1;\n（2）并查集的Find操作\n在并查集s中查找并返回包含元素×的树的根。\nint Find(int S[],int x）{\n//循环寻找×的根\nwhile(S[x]>=0)\nx=S[x];\nreturn x;\n/根的S[]小于0\n判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。\n（3）并查集的Union操作\n求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个\n元素的根，再令一棵子集树的根指向另一棵子集树的根。\nvoid Union(int S[l,int Rootl,int Root2){\nif(Root1==Root2) return;\n//要求Root1与Root2是不同的集合\nS[Root2]=Rootl;\n/将根Root2连接到另一根Root1下面\nFind操作和Union操作的时间复杂度分别为O（d和O（1)，其中d为树的深度。\n4.并查集实现的优化\n在极端情况下，n个元素构成的集合树的深度为n，则Find操作的最坏时间复杂度为O(n)。\n改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成\n员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。\n（1）改进的 Union 操作\nvoid Union(int S[],int Rootl,int Root2){\nif(Rootl==Root2) return;\nif(S[Root2]>S[Root1]){\n//Root2结点数更少\nS[Root1]+=S[Root2];\n//累加集合树的结点总数\nS[Root2]=Root1;\n//小树合并到大树\n1\nelset\n//Root1结点数更少\nS[Root2]+=S[Root1];\n//累加结点总数\nS[Root1]=Root2;\n//小树合并到大树\n采用这种方法构造得到的集合树，其深度不超过log2n」+1。\n随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还\n可进一步对上述Find操作进行优化，当所查元素×不在树的第二层时，在算法中增加一个压缩\n\n188\n2026年数据结构考研复习指导\n路径的功能，即将从根到元素×路径上的所有元素都变成根的孩子。\n（2）改进的Find操作\nint Find(int S[],int x）{\nint root=x;\nwhile(s[root]>=0)\n//循环找到根\nroot=s[root];\nwhile(x!=root){\n/压缩路径\nint t=S[x];\n//t指向x的父结点\nS[x]=root;\n/lx直接挂到根结点下面\nx=t;\nreturn root;\n//返回根结点编号\n通过Find操作的压缩路径优化后，可使集合树的深度不超过O（α（n))，其中α（n)是一个增长\n极其缓慢的函数，对于常见的正整数n，通常α(n)≤4。\n并查集应用的相关举例见本书配套课程。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "q055001",
            "q055002",
            "q055003",
            "q055004",
            "q055005",
            "q055006",
            "q055007",
            "q055009",
            "q055010",
            "q055011",
            "q055012",
            "q055013",
            "q055014",
            "q055015",
            "q055016",
            "q055017",
            "q055018"
        ]
    }
]