[
    {
        "id": "kc0721",
        "title": "顺序查找",
        "chapter_id": "c07",
        "description": "顺序查找也称线性查找，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增\n来顺序扫描每个元素；对于链表，可通过指针next来依次扫描每个元素。顺序查找通常分为对\n一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。下面分别进行讨论。\n1.一般线性表的顺序查找\n作为一种最直观的查找方法，其基本思想：①从线性表的一端开始，逐个检查关键字是否满\n足给定的条件：②若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表\n中的位置；③若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败\n的信息。下面给出其算法，后面说明了算法中引入的“哨兵”的作用。\ntypedef struct{\n//查找表的数据结构（顺序表）\nElemType *elem;\n/动态数组基址\nint TableLen;\n/表的长度\n)SSTable;\nint Search_Seq(SSTable ST,ElemType key){\nST.elem[0]=key;\n》“哨兵”\nfor(int i=ST.TableLen;ST.elem[i]!=key;--i);//从后往前找\nreturni;/\n/若查找成功，则返回元素下标；若查找失败，则返回0\n上述算法中，将sT.elem[O］称为哨兵，引入它的目的是使得Search_Seq内的循环不必\n判断数组是否会越界。算法从尾部开始查找，若找到 sT.elem[i]==key则返回i值，查找成\n功。否则一定在查找到sT.elem[0］==key时跳出循环，此时返回的是0，查找失败。在程序中\n引入“哨兵”，可以避免很多不必要的判断语句，从而提高程序效率。\n对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需进行n-i+1\n\n第7章查\n找\n271\n次关键字的比较，即C，=n-i+1。查找成功时，顺序查找的平均长度为\n>P(n-i+1)\nj=l\n当每个元素的查找概率相等，即P=1/n时，有\nASL成功\n=1\n查找不成功时，与表中各关键字的比较次数显然是n+1次，即ASL不成功=n+1。\n通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记\n录的查找概率进行排序，使表中记录按查找概率由小至大重新排列。\n综上所述，顺序查找的缺点是当n较大时，平均查找长度较大，效率低：优点是对数据元素\n的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按\n关键字有序，均可应用。同时还需注意，对链表只能进行顺序查找。\n2.有序线性表的顺序查找\n若在查找之前就已知表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返\n回查找失败的信息，从而降低查找失败的平均查找长度。假设表L是按关键字从小到大排列的，\n的关键字小于key，但第i+1个元素的关键字大于key，这时就可返回查找失败的信息，因为第\ni个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素。\n命题追踪?有序线性表的顺序查找的应用（2013）\n可以用如图7.1所示的判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性\n表中存在的元素；矩形结点称为失败结点（若有n个结点，则相应地有n+1个查找失败结点），\n它描述的是那些不在表中的数据值的集合。若查找到矩形结点，则说明查找失败。\n查找序列（10.20.30.40.50.60)\n10\n40>10\n查找25\n查找40\n25>10\n(-00,10)\n25>20(10.20)\n25<30(20.30)\n(30.40)\n(40.50)\n(50.60)\n(60.00)\n图7.1有序顺序表上的顺序查找判定树\n在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找\n失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存\n在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的\n平均查找长度在相等查找概率的情形下为\n1+2+..+n+n=n+-n\nASL不成功=\nZq;(l-1)=\nn+1\n2n+1\nj=1\n式中，α,是到达第j个失败结点的概率，在相等查找概率的情形下，它为1/(n+1)；I是第j个失\n败结点所在的层数。当n=6时，ASL不成功=6/2+6/7=3.86，比一般的顺序查找好一些。\n\n272\n2026年数据结构考研复习指导\n注意，有序线性表的顺序查找和后面的折半查找的思想是不一样的，且有序线性表的顺序查\n找中的线性表可以是链式存储结构，而折半查找中的线性表只能是顺序存储结构。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0722",
        "title": "折半查找",
        "chapter_id": "c07",
        "description": "折半查找也称二分查找，它仅适用于有序的顺序表。\n命题追踪分析对比给定查找算法与折半查找的效率（2016）\n折半查找的基本思想：①首先将给定值key与表中中间位置的元素比较，若相等，则查找成\n功，返回该元素的存储位置：②若不等，则所需查找的元素只能在中间元素以外的前半部分或后\n半部分（例如，在查找表升序排列时，若key大于中间元素，则所查找的元素只可能在后半部分），\n然后在缩小的范围内继续进行同样的查找。重复上述步骤，直到找到为止，或确定表中没有所需\n要查找的元素，则查找不成功，返回查找失败的信息。算法如下：\nint Binary_Search(SsTable L,ElemType key) (\nint low=0,high=L.TableLen-1,mid;\nwhile(low<=high)(\nmid=（low+high)/2;\n/取中间位置\nif(L.elem[mid]==key)\nreturn mid;\n//查找成功则返回所在位置\nelse if(L.elem[mid]>key)\nhigh=mid-1;\n//从前半部分继续查找\nelse\nlow=mid+1;\n1//从后半部分继续查找\nreturn-1;\n//查找失败，返回-1\n当折半查找算法选取中间结点时，既可以采用向下取整，又可以采用向上取整。但每次查找\n的取整方式必须相同，这部分内容请读者结合本节部分习题来理解。\n命题追踪折半查找的查找路径的判断（2015）\n例如，已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}，要查找值为11和32的元\n素，指针1ow和high分别指向表的下界和上界，mid则指向表的中间位置l（low+high）/2]。\n下面来说明查找11的过程（查找32的过程请读者自行分析）：\n71013\n16\n192932\n33\n41\n43\nlow\n↑mid\n↑high\n第一次查找时，将中间位置元素与key比较。因为11<29，说明待查元素若存在，则必在范围\n[low，mid-1]内，令high指向位置mid-1，high=mid-1=5，mid=（1+5）/2=3，第二次查找范\n围为[1,5]。\n7101316\n19293233374143\n↑low\n↑mid\n↑high\n第二次查找时，将中间位置元素与key比较。因为11<13，说明待查元素若存在，则必在范围\n[low，mid-1]内，令high指向位置mid-1，high=mid-1=2，mid=（1+2）/2=1，第三次查找范\n围为[1,2]。\n7\n101316\n19293233374143\nlow ↑\n↑high\nmid ↑\n第三次查找时，将中间位置元素与key比较。因为11>7，说明待查元素若存在，则必在范围\n[mid+1,high]内。令1ow=mid+1=2，mid=（2+2）/2=2，第四次查找范围为[2，2]。\n\n第7章查\n找\n273\n7101316\n192\n2932\n33\n37\n4143\nlow↑ thigh\n↑mid\n第四次查找，此时子表只含有一个元素，且10≠11，所以表中不存在待查元素。\n命题追踪分析给定二叉树树形能否构成折半查找判定树（2017）\n折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。树中每个圆形结点表示一个\n记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找失败的区\n间。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查\n找失败时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数：每个结点值均大于\n其左子结点值，且均小于其右子结点值。若有序序列有n个元素，则对应的判定树有n个圆形的\n非叶结点和n+1个方形的叶结点。显然，判定树是一棵平衡二叉树（见",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0732",
        "title": "节）。",
        "chapter_id": "c07",
        "description": "(13,16)\n(37,41)\n(7.10)\n（10,13)\n(16,19)\n(19.29)\n(33.37)\n图7.2描述折半查找过程的判定树\n命题追踪折半查找的最多比较次数的分析（2010、2023）\n由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率\n查找时，查找成功的平均查找长度为\nn+1\nASL=\n(1x1+2×2+..+h×2-l)=\n-log(n+1)-1≈log2(n+1)-1\n=1\nn\n式中，h是树的高度，并且元素个数为n时树高h=[log2（n+1）l。所以，折半查找的时间复杂度\n为O(log2n)，平均情况下比顺序查找的效率高。\n在图7.2所示的判定树中，在等概率情况下，查找成功（圆形结点）的ASL=（1×1+2×2+3×4+\n4×4)/11=3，查找失败（方形结点）的ASL=（3×4+4×8)/12=11/3。\n命题追踪折半查找的适用场景（2024）\n因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，\n该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0723",
        "title": "分块查找",
        "chapter_id": "c07",
        "description": "分块查找也称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又\n适于快速查找。\n分块查找的基本思想：将查找表分为若干子块。块内的元素可以无序，但块间的元素是有序\n的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字\n小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有\n\n274\n2026年数据结构考研复习指导\n各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。\n分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折\n半查找索引表：第二步是在块内顺序查找。\n例如，关键码集合为{88,24,72,61,21,6,32,11,8,31,22,83,78,54}，按照关键码值24,54,78,\n88，分为4个块和索引表，如图7.3所示。\n24\n索引表\n查找表24216118223231547261788883\n图7.3分块查找示意图\n分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的\n平均查找长度分别为L和Ls，则分块查找的平均查找长度为\nASL=L+Ls\n将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引\n表中均采用顺序查找，则平均查找长度为\nb+1s+1s²+2s+n\nASL=L+Ls\n2\n2\n2s\n此时，若s=√n，则平均查找长度取最小值√n+1。\n虽然索引表占用了额外的存储空间，索引查找也增加了一定的系统开销，但由于其分块结构，\n使得在块内查找时的范围较小，与顺序查找相比，分块查找的总体效率提升了不少。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0731",
        "title": "二叉排序树 (BST)",
        "chapter_id": "c07",
        "description": "构造一棵二叉排序树的目的并不是排序，而是提高查找、插入和删除关键字的速度，二叉排\n序树这种非线性结构也有利于插入和删除的实现。\n1.二叉排序树的定义\n命题追踪二叉排序树的应用（2013）\n二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：\n1）若左子树非空，则左子树上所有结点的值均小于根结点的值。\n2）若右子树非空，则右子树上所有结点的值均大于根结点的值。\n\n284\n2026年数据结构考研复习指导\n3）左、右子树也分别是一棵二叉排序树。\n命题追踪二叉排序树中结点值之间的关系（2015、2018、2024）\n根据二叉排序树的定义，左子树结点值<根结点值<右子树结点值，因此对二叉排序树\n进行中序遍历，可以得到一个递增的有序序列。例如，图7.4所示二叉排序树的中序遍历序列\n为123468。\n图7.4\n一棵二叉排序树\n2.二叉排序树的查找\n二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，\n先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，若小于根结点的关键字，则\n在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。\n二叉排序树的非递归查找算法：\nBSTNode *BST_Search(BiTree T,ElemType key){\nwhile(T!=NULL&&key!=T->data){\n/若树空或等于根结点值，则结束循环\nif(key<T->data) T=T->lchild;\n//小于，则在左子树上查找\nelse T=T->rchild;\n//大于，则在右子树上查找\nreturn T;\n例如，在图7.4中查找值为4的结点。首先4与根结点6比较。因为4小于6，所以在根结\n点6的左子树中继续查找。因为4大于2，所以在结点2的右子树中查找，查找成功。\n同样，二叉排序树的查找也可用递归算法实现，递归算法比较简单，但执行效率较低。具体\n的代码实现，留给读者思考。\n3.二叉排序树的插入\n二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，\n当树中不存在关键字值等于给定值的结点时再进行插入的。\n插入结点的过程如下：若原二叉排序树为空，则直接插入：否则，若关键字k小于根结点值，\n则插入到左子树，若关键字k大于根结点值，则插入到右子树。新插入的结点一定是一个叶结点，\n且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。如图7.5所示在一棵二叉\n排序树中依次插入结点28和结点58，虚线表示的边是其查找的路径。\n20\n28\n28\n(a)插入28\n(b)插入58\n图7.5向二叉排序树中插入结点\n\n第7章查\n找\n285\n二叉排序树插入操作的算法描述如下：\nint BST_Insert(BiTree &T,KeyType k){\nif（T==NULL）{\n//原树为空，新插入的记录为根结点\nT=(BiTree)malloc(sizeof(BsTNode));\nT->data=k;\nT->lchild=T->rchild=NULL;\nreturn1;\n//返回1，插入成功\nelse if(k==T->data)\n//树中存在相同关键字的结点，插入失败\nreturn0;\nelse if(k<T->data)\n/插入T的左子树\nreturn BsT_Insert(T->lchild,k);\nelse\n//插入T的右子树\nreturn\nBST_Insert(T->rchild,k);\n4.二叉排序树的构造\n命题追踪构造二叉排序树的过程（2020）\n从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设插入的关键字序\n列为{45,24,53,45,12.24}，则生成的二叉排序树如图7.6所示。\n45\n(a）空树\n(b）插入45\n（c）插入24\n（d）插入53\n(e）插入12\n图7.6二叉排序树的构造过程\n构造二叉排序树的算法描述如下：\nvoid Creat_BsT(BiTree &T,KeyType str[],int n){\nT=NULL;\n//初始时T为空树\nint i=0;\nwhile(i<n){\n//依次将每个关键字插入二叉排序树\nBST_Insert(T,str[i]);\ni++;\n5.二叉排序树的删除\n在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被\n删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时\n确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：\n①若被删除结点：是叶结点，则直接删除，不会破坏二叉排序树的性质。\n②若结点：只有一棵左子树或右子树，则让=的子树成为=父结点的子树，替代=的位置。\n③若结点=有左、右两棵子树，则令=的直接后继（或直接前驱）替代=，然后从二叉排序\n树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。\n图7.7显示了在3种情况下分别删除结点45，78，78的过程。\n\n286\n2026年数据结构考研复习指导\n右子树空，用左子女填补\n23\na\n删除78\n左子树空，用右子女填补\n23\n88\n23\n(b)\n53\n53\n删除78\n78\n左、有子树均不空，\n在右子树上找中序第\n个子女填补\n转换为删除81\n23\n88\n(c)\n图7.73种情况下的删除过程\n命题追踪二叉排序树中删除并插入某结点的分析（2013）\n思考：若在二叉排序树中删除并插入某结点，得到的二叉排序树是否和原来的相同？\n6．二叉排序树的查找效率分析\n二叉排序树的查找效率，主要取决于树的高度。若二叉排序树的左、右子树的高度之差\n的绝对值不超过1（平衡二叉树，下一节)，它的平均查找长度和O(log2n)成正比。在最坏情\n况下，即构造二叉排序树的输入序列是有序的，则会形成一个只有右孩子的单支树，此时二叉排\n序树的性能显著变坏，树的高度为n，则其平均查找长度为（n+1)/2，如图7.8(b)所示。\nQ12\nQ28\nQ37\nQ40\nQ45\n053\n055\nQ60\n070\n(a)\n(b)\n图7.8相同关键字组成的不同二叉排序树\n\n第7章查找\n287\n在等概率情况下，图7.8(a)查找成功的平均查找长度为\nASLa=(1 + 2×2+ 3x4 + 4×3)/10 = 2.9\n而图7.8(b)查找成功的平均查找长度为\nASL,=(1+2+3+4+5+6+7+8+9+10)10=5.5\n从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和\n二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入\n顺序不同可能生成不同的二叉排序树，如图7.8所示。\n就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，\n平均执行时间为O(log2)。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的\n代价是O（n)。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查\n找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0732",
        "title": "平衡二叉树",
        "chapter_id": "c07",
        "description": "1.平衡二叉树的定义\n为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保\n证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced\nBinaryTree），也称AVL树。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡\n二叉树结点的平衡因子的值只可能是-1、0或1。\n命题追踪平衡二叉树的定义（2009）\n因此，平衡二叉树可定义为或是一棵空树，或是具有下列性质的二叉树：它的左子树和右子\n图7.9（b）所示是不平衡的二叉树。结点中的数字为该结点的平衡因子。\n(a)平衡二义树\n(b)不平衡的二义树\n图7.9平衡二叉树和不平衡的二叉树\n2.平衡二叉树的插入\n二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首\n先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入\n路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉\n排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。\n命题追踪平衡二叉树中插入操作的特点（2015）\n注意，每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的\n绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。\n\n288\n2026年数据结构考研复习指导\n插入51\n对最小不平衡树\n执行LR旋转\n插入27、16、75、38\n之后的二叉排序树\n图7.10最小不平衡子树示意\n命题追踪）平衡二叉树的插入及调整操作的实例（2010、2019、2021）\n平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径\n上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：\n1）LL平衡旋转（右单旋转）。由于在结点A的左孩子（L）的左子树（L）上插入了新结点，\nA的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将\nA的左孩子B向右上旋转代替A成为根结点，将A向右下旋转成为B的右孩子，而B的\n原右子树则作为4的左子树。如图7.11所示，结点旁的数值代表结点的平衡因子，而用\n方块表示相应结点的子树，下方数值代表该子树的高度。\nA\nBL.\nBR\n(a)插入结点前\n(b)插入结点导致不平衡\n(c)LL旋转（右单旋转）\n图7.11LL平衡旋转\n2）RR平衡旋转（左单旋转）。由于在结点A的右孩子（R）的右子树（R）上插入了新结点，\nA的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。\n将A的右孩子B向左上旋转代替A成为根结点，将A向左下旋转成为B的左孩子，而B\n的原左子树则作为4的右子树，如图7.12所示。\nBL\n(a）插入结点前\n(b)插入结点导致不平衡\n(c)RR旋转（左单旋转）\n图7.12RR平衡旋转\n3）LR平衡旋转（先左后右双旋转）。由于在结点A的左孩子（L）的右子树（R）上插入新\n结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，\n先左旋转后右旋转。先将A的左孩子B的右子树的根结点C向左上旋转提升到B的位置，\n\n第7章查\n找\n289\n然后把C向右上旋转提升到A的位置，如图7.13所示。\n(a)插入结点前\n(b)插入结点导致不平衡\n（c)LR旋转（双旋转）\n图7.13LR平衡旋转\n4）RL平衡旋转（先右后左双旋转）。由于在结点A的右孩子（R）的左子树（L）上插入新\n结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操\n作，先右旋转后左旋转。先将A的右孩子B的左子树的根结点C向右上旋转提升到B的\n位置，然后把C向左上旋转提升到A的位置，如图7.14所示。\n(a)插入结点前\n(b)插入结点导致不平衡\n(c)RL旋转（双旋转)\n图7.14RL平衡旋转\n注意\n公众号：小兔网盘免费分享无水印PDF\nLR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树不影响旋转过程，而图7.13\n和图7.14中以插入C的左子树中为例。\n命题追踪构造平衡二叉树的过程（2013）\n以关键字序列{15,3，7,10，9，8构造一棵平衡二叉树的过程为例，图7.15（d)插入7后导致不\n平衡，最小不平衡子树的根为15，插入位置为其左孩子的右子树，所以执行LR旋转，先左后右\n双旋转，调整后的结果如图7.15(e)所示。图7.15(g)插入9后导致不平衡，最小不平衡子树的根为\n15，插入位置为其左孩子的左子树，所以执行LL旋转，右单旋转，调整后的结果如图7.15(h)所\n示。图7.15（1插入8后导致不平衡，最小不平衡子树的根为7，插入位置为其右孩子的左子树，\n所以执行RL旋转，先右后左双旋转，调整后的结果如图7.15(所示。\n3.平衡二叉树的删除\n与平衡二叉树的插入操作类似，以删除结点v为例来说明平衡二叉树删除操作的步骤：\n1）用二叉排序树的方法对结点w执行删除操作。\n2）若导致了不平衡，则从结点w开始向上回溯，找到第一个不平衡的结点=（最小不平衡子\n树）：y为结点=的高度最高的孩子；x是结点y的高度最高的孩子。\n\n290\n2026年数据结构考研复习指导\n15\n15\n10\n(a)空树\n(b)插入15\n(c)插入3\n(d)插入7\n(e)LR旋转\n(f)插入10\nG\nG\n9\n10\n(g)插入9\n(h)LL旋转\n(i)插入8\n(i)RL旋转\n图7.15平衡二叉树的生成过程\n3）然后对以=为根的子树进行平衡调整，其中x、y和=可能的位置有4种情况：\n·y是=的左孩子，x是y的左孩子（LL，右单旋转);\n·y是=的左孩子，x是y的右孩子（LR，先左后右双旋转);\n·y是=的右孩子，x是y的右孩子（RR，左单旋转);\n·y是=的右孩子，x是y的左孩子（RL，先右后左双旋转)。\n这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以：为根的子树\n进行平衡调整；而删除操作就不一样，先对以=为根的子树进行平衡调整，若调整后子树的高度\n减1，则可能需要对：的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减1）。\n以删除图7.16(a)的结点32为例，由于32为叶结点，直接删除即可，向上回溯找到第一个不\nRL情况，先右后左双旋转，调整后的结果如图7.16(c)所示。\n右旋\n左旋\n(a)删除32前\n(b)右旋\n(c）左旋\n图7.16平衡二叉树的删除\n4.平衡二叉树的查找\n命题追踪）指定条件下平衡二叉树的结点数的分析（2012）\n在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，进行关键字的\n比较次数不超过树的深度。假设以n表示深度为h的平衡二叉树中含有的最少结点数。显然，有\n\n第7章查\n找\n291\nno=0,n=1,n2=2，并且有n=nh-2+n-i+1，如图7.17所示，依次推出n=4,n4=7,ns=12,·\n含有n个结点的平衡二叉树的最大深度为O(log2n)，因此平均查找效率为O(log2n)。\n图7.17结点个数n最少的平衡二叉树\n注意\n该结论可用于求解给定结点数的平衡二叉树的查找所需的最多比较次数（或树的最大高度）。如在含\n有12个结点的平衡二叉树中查找某个结点的最多比较次数？\n深度为h的平衡二叉树中含有的最多结点数显然是满二叉树的情况。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0733",
        "title": "红黑树",
        "chapter_id": "c07",
        "description": "1.红黑树的定义\n为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构，\n代价较大。为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构。\n棵红黑树是满足如下红黑性质的二叉排序树：\n①每个结点或是红色，或是黑色的。\n②根结点是黑色的。\n③叶结点（虚构的外部结点、NULL结点）都是黑色的。\n④不存在两个相邻的红结点（红结点的父结点和孩子结点均是黑色的）。\n③对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。\n与折半查找树和B树类似，为了便于对红黑树的实现和理解，引入了n+1个外部叶结点，\n以保证红黑树中每个结点（内部结点）的左、右孩子均非空。图7.18所示是一棵红黑树。\n空结点\n黑结点\n红结点\n图7.18\n一棵红黑树\n从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结\n点的黑高（记为bh），黑高的概念是由性质5确定的。根结点的黑高称为红黑树的黑高。\n结论1：从根到叶结点的最长路径不大于最短路径的2倍。\n由性质，当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。\n\n292\n2026年数据结构考研复习指导\n黑结点的数量相同。图7.18中的6-2和6-15-18-20就是这样的两条路径。\n结论2：有n个内部结点的红黑树的高度h≤2log2（n+1)。\n证明：由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是\n黑结点，因此，根的黑高至少为h/2，于是有n≥2h㎡2-1，即可求得结论。\n由结论2也可推出，黑高为h的红黑树的内部结点数最少是2\"-1，最多是22\"-1。\n可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任意一个结点左右子\n树的高度，相差不超过2倍”，也降低了动态操作时调整的频率。对于一棵动态查找树，若插入\n和删除操作比较少，查找操作比较多，则采用AVL树比较合适，否则采用红黑树更合适。但由\n于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C++中的\nmap和set（Java中的TreeMap和TreeSet）就是用红黑树实现的。\n2.红黑树的插入\n红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新\n结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。\n结论3：新插入红黑树中的结点初始着为红色。\n假设新插入的结点初始着为黑色，则这个结点所在的路径比其他路径多出一个黑结点（几乎\n每次插入都破坏性质），调整起来也比较麻烦。若插入的结点是红色的，则此时所有路径上的\n黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。\n设结点：为新插入的结点。插入过程描述如下：\n1)用二叉查找树插入法插入，并将结点：着为红色。若结点z的父结点是黑色的，无须做任\n何调整，此时就是一棵标准的红黑树，结束。\n2）若结点=是根结点，则将=着为黑色（树的黑高增1），结束。\n3）若结点=不是根结点，且=的父结点=.p是红色的，则分为下面三种情况，区别在于=的\n叔结点y的颜色不同，因=.p是红色的，插入前的树是合法的，根据性质②和④，爷结点\n=.p.p 必然存在且为黑色。性质④只在=和=.p之间被破坏了。\n情况1：=的叔结点y是黑色的，且=是一个右孩子。\n情况2：=的叔结点y是黑色的，且=是一个左孩子。\n每棵子树T、T、T和T4都有一个黑色根结点，且具有相同的黑高。\n情况1（LR，先左旋，再右旋），即=是其爷结点的左孩子的右孩子。先做一次左旋将此情\n形转变为情况2（变为情况2后再做一次右旋），左旋后=和父结点=.p交换位置。因为=和=.p\n都是红色的，所以左旋操作对结点的黑高和性质5都无影响。\n情况2（LL，右单旋），即=是其爷结点的左孩子的左孩子。做一次右旋，并交换=的原父\n结点和原爷结点的颜色，就可以保持性质，也不会改变树的黑高。这样，红黑树中也不再有连\n续两个红结点，结束。情况1和情况2的调整方式如图7.19所示。\n注：p表示父结点；p.p表示爷结点\n情况1\n情况2\n红结点\n黑结点\n图7.19情况1和情况2的调整方式\n\n第7章查\n找\n293\n若父结点=.p是爷结点=.p.p的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和\nRR（左单旋），这里不再赘述。红黑树的调整方法和AVL树的调整方法有异曲同工之妙。\n情况3：=的叔结点y是红色的。\n情况3（=是左孩子或右孩子无影响），=的父结点=.p和叔结点y都是红色的，因为爷结点\n=.p.p 是黑色的，将=.p 和y 都着为黑色，将=.p.p 着为红色，以在局部保持性质④和③。然后，把\n=.p.p作为新结点=来重复循环，指针=在树中上移两层。调整方式如图7.20所示。\n新结点\n(a)\nR\n黑结点\n红结点\n图7.20情况3的调整方式\n若父结点=.p是爷结点=.P.p的右孩子，也还有两种对称的情况，不再赘述。\n只要满足情况3的条件，就会不断循环，每次循环指针z都会上移两层，直到满足2）（表示\n=上移到根结点）或情况1或情况2的条件。\n可能的疑问：虽然插入的初始位置一定是红黑树的某个叶结点，但因为在情况3中，结点=\n存在不断上升的可能，所以对于三种情况，结点：都有存在子树的可能。\n以图7.21(a)中的红黑树为例（虚线表示插入后的状态），先后插入5、4和12的过程如图7.21\n所示。插入5，为情况3，将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时\n因为7已是根，所以又重新着为黑色，树的黑高加1，结束。插入4，为情况1的对称情况（RL），\n此时特别注意虚构黑色空结点的存在，先对以5为根的子树做右旋；转变为情况2的对称情况\n（RR），交换3和4的颜色，再对以4为根的子树做左旋，结束。插入12，父结点是黑色的，无\n须任何调整，结束。\n空结点\n情况3\n因7为根\n黑结点\n(10\n3\n10\n将7着为黑色\n红结点\n将3和10着为黑色\n树的黑高加！\n5\n将7着为红色\n(a)插入5\n(b）第一步调整\n（c)第二步调整，插入4\n情况1的对称情况（RL）\n情况2的对称情况（RR）\n对5做右旋\n交换3和4的颜色\n对3做左旋\n(d）第一步调整\n(e)第二步调整，插入12\n图7.21红黑树的插入过程\n\n294\n2026年数据结构考研复习指导\n*3.红黑树的删除\n注意\n本节难度较大，考查概率较低，读者可根据自身情况决定是否学习或学习的时机。\n红黑树的插入操作容易导致连续的两个红结点，破坏性质④。而删除操作容易造成子树黑高\n的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质。\n删除过程也是先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找\n到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后\n继结点至多只有一个孩子，这样就转换为待删结点是终端结点或仅有一个孩子的情况。\n最终，删除一个结点有以下两种情况：\n·待删结点只有右子树或左子树。\n·待删结点没有孩子。\n1）若待删结点只有右子树或左子树，则只有两种情况，如图7.22所示。\n删除Y\n删除Y\n或\n黑结点\nYR\n红结点\n图7.22只有右子树或左子树的删除情况\n只有这两种情况存在。子树只有一个结点，且必然是红色，否则会破坏性质5。\n2）待删结点无孩子，且该结点是红色的，这时可直接删除，而不需要做任何调整。\n3）待删结点无孩子，且该结点是黑色的，这时设待删结点为y，x是用来替换y的结点（注\n意，当y是终端结点时，x是黑色的NULL结点）。删除y后将导致先前包含y的任何路\n径上的黑结点数量减1，因此y的任何祖先都不再满足性质，简单的修正办法就是将替\n换y的结点x视为还有额外一重黑色，定义为双黑结点。也就是说，若将任何包含结点x\n的路径上的黑结点数量加1，则在此假设下，性质5得到满足，但破坏了性质①。于\n是，删除操作的任务就转化为将双黑结点恢复为普通结点。\n分为以下四种情况，区别在于x的兄弟结点w及w的孩子结点的颜色不同。\n情况1：x的兄弟结点w是红色的。\n情况1，w必须有黑色左右孩子和父结点。交换w和父结点x.p的颜色，然后对x.p做一次左\n旋，而不会破坏红黑树的任何规则。现在，x的新兄弟结点是旋转之前w的某个孩子结点，其颜\n色为黑色，这样，就将情况1转换为情况2、3或4处理。调整方式如图7.23所示。\n黑结点\n情况1\n红结点\n图7.23情况1的调整方式\n情况2：x的兄弟结点w是黑色的，且w的右孩子是红色的。\n情况3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。\n情况2（RR，左单旋），即这个红结点是其爷结点的右孩子的右孩子。交换w和父结点x.p\n\n第7章查\n找\n295\n的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，将x变为单重黑色，此时不\n再破坏红黑树的任何性质，结束。调整方式如图7.24所示。\n情况2\n黑结点红结点\n图7.24情况2的调整方式\n情况3（RL，先右旋，再左旋），即这个红结点是其爷结点的右孩子的左孩子。交换w和其\n左孩子的颜色，然后对w做一次右旋，而不破坏红黑树的任何性质。现在，x的新兄弟结点v的\n右孩子是红色的，这样就将情况3转换为了情况2。调整方式如图7.25所示。\n情况3\n新结点\n注：白色结点表示既可为黑色也可为红色，对操作没有影响\n黑结点\n红结点\n图7.25情况3的调整方式\n情况4：x的兄弟结点w是黑色的，且w的两个孩子结点都是黑色的。\n在情况4中，因为w也是黑色的，所以可从x和w上去掉一重黑色，使得x只有一重黑色而\nw变为红色。为了补偿从x和w中去掉的一重黑色，把x的父结点x.p额外着一层黑色，以保持\n局部的黑高不变。通过将x.p作为新结点x来循环，x上升一层。若是通过情况1进入情况4的，\n因为原来的x.p是红色的，将新结点x变为黑色，终止循环，结束。调整方式如图7.26所示。\n新结点x\n情况4\n黑结点红结点\n图7.26情况4的调整方式\n若x是父结点x.p的右孩子，则还有四种对称的情况，处理方式类似，不再赘述。\n归纳总结：在情况4中，因x的兄弟结点w及左右孩子都是黑色，可以从x和w中各提取\n重黑色（以让x变为普通黑结点），不会破坏性质④，并把调整任务向上“推”给它们的父结点\nx.p。在情况1、2和3中，因为x的兄弟结点w或w左右孩子中有红结点，所以只能在x.p子树\n内用调整和重新着色的方式，且不能改变x原根结点的颜色（否则向上可能破坏性质④）。情况1\n虽然可能会转换为情况4，但因为新x的父结点x.p是红色的，所以执行一次情况4就会结束。情\n况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯\n\n296\n2026年数据结构考研复习指导\n一情况，每执行一次指针x上升一层，至多O(log2n)次。\n以图7.27(a)中的红黑树为例（虚线表示删除前的状态），依次删除5和15的过程如图7.27\n所示。删除5，用虚构的黑色NULL结点（图中为N结点）替换，视为双黑NULL结点，为情况\n1，交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4，从双黑NULL结点和\n10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），\n因原父结点8是红色，所以将8变为黑色，结束。删除15，为情况3的对称情况（LR），交换8\n和10的颜色，对8做左旋：转变为情况2的对称情况（LL），交换10和12的颜色（两者颜色一\n样，无变化），将10的左孩子8着为黑色，对12做右旋，结束。\n删除5\n情况1\n黑结点\n空叶结点替换\n交换8和12的颜色\n）红结点\n视为双黑结点\n对8做一次左旋\n新结点\n（a）删除5\n(b）删除后，空叶结点替换\n（c）第一步调整后\n交换10和12的颜色\n情况4\n对12做右旋\n情况3的对称情况（LR）\nN和10各提取一重黑色\n0的左孩子8着为黑色\n8变为黑色\n交换8和10的颜色\n对8做左旋\n10\n(d)第二步调整后，删除15\n(e)第一步调整后\n(第二步调整后\n图7.27红黑树的删除过程",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0741",
        "title": "B树及其基本操作",
        "chapter_id": "c07",
        "description": "所谓m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。\n命题追踪B树的定义和特点（2009）\n一棵m阶B树或为空树，或为满足如下特性的m叉树：\n1）树中每个结点至多有m棵子树，即至多有m-1个关键字。\n2）若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字。\n3）除根结点外的所有非叶结点至少有「m/2]棵子树，即至少有「m/2]-1个关键字。\n4）所有非叶结点的结构如下：\nnPoKPK2P2KP\n其中，K，（i=1,2,…，n）为结点的关键字，且满足K<K2<.….<Kn；P（i=0,1,……·，n）\n为指向子树根结点的指针，且指针P所指子树中所有结点的关键字均小于K，P所指子\n树中所有结点的关键字均大于K；n（「m/2l-1≤n≤m-1）为结点中关键字的个数。\n5）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查\n找判定树的失败结点，实际上这些结点并不存在，指向这些结点的指针为空）。\n命题追踪B树中关键字数和结点数的分析（2013、2014、2018、2021）\n图7.28所示为一棵5阶B树，可以借助该实例来分析上述性质：\n22\n3645\n内部结点\n13689131530354042\n图7.28一棵5阶B树的实例\n1）结点的孩子个数等于该结点中关键字个数加1。\n2）若根结点没有关键字就没有子树，则此时B树为空；若根结点有关键字，则其子树个数\n必然大于或等于2，因为子树个数等于关键字个数加1。\n3）除根结点外的所有非叶结点至少有m/2]=「5/2]=3棵子树（至少有m/2]-1=[5/2]-1=2\n个关键字）：至多有5棵子树（至多有4个关键字）。\n4）结点中的关键字从左到右递增有序，关键字两侧均有指向子树的指针，左侧指针所指子\n树的所有关键字均小于该关键字，右侧指针所指子树的所有关键字均大于该关键字。或\n者看成下层结点的关键字总是落在由上层结点的关键字所划分的区间内，如第二层最左\n结点的关键字划分成了3个区间：（-，5)，（5,11),（11,+∞），该结点中的3个指针所指子\n树的关键字均分别落在这3个区间内。\n5）所有叶结点均在第4层，代表查找失败的位置。\n1.B树的查找\n在B树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，在每个结\n①多数教材将B树的叶结点定义为失败结点，本书也采用这种定义，但408真题将B树的叶结点定义为最底层的终端结点。\n\n312\n2026年数据结构考研复习指导\n点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。\nB树的查找包含两个基本操作：①在B树中找结点：②在结点内找关键字。B树常存储在\n磁盘上，因此前一查找操作是在磁盘上进行的，而后一查找操作是在内存中进行的，即在磁盘上\n找到目标结点后，先将结点信息读入内存，然后再采用顺序查找法或折半查找法。因此，在磁盘\n上进行查找的次数即目标结点在B树上的层次数，决定了B树的查找效率。\n在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的\n点只有一个关键字，且42>22，若存在，必在关键字22的右边子树上，右孩子结点有两个关键\n字，而36<42<45，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查\n找成功）。查找到叶结点时（对应指针为空），则说明树中没有对应的关键字，查找失败。\n2.B树的高度（磁盘存取次数）\n由上一节得知，B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。\n下面来分析B树在不同情况下的高度。当然，首先应该明确B树的高度不包括最后的不带任\n何信息的叶结点所处的那一层（有些书对B树的高度的定义中，包含最后的那一层）。\n若n≥1，则对任意一棵包含n个关键字、高度为h、阶数为m的B树：\n1）若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。\n因为B树中每个结点最多有m棵子树，m-1个关键字，所以在一棵高度为h的m阶B\n树中关键字的个数应满足n≤（m-1)(1+m+m²+..·+m²-)=m-1，因此有\nh≥1ogm(n+1)\n2）若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。\n第一层至少有1个结点；第二层至少有2个结点；除根结点外的每个非叶结点至少有「m/2]\n棵子树，则第三层至少有2m/2|个结点……··第h+1层至少有2（m/21）-1个结点，注意\n到第h+1层是不包含任何信息的叶结点。对于关键字个数为n的B树，叶结点即查找不\n成功的结点为n+1，由此有n+1≥2(「m/2])²1，即h≤log[m/2]((n+ 1)/2)+ 1。\n例如，假设一棵3阶B树共有8个关键字，则其高度范围为2≤h≤3.17，取整数。\n3.B树的插入\n命题追踪通过插入操作构造一棵初始为空的B树（2020）\n与二叉排序树的插入操作相比，B树的插入操作要复杂得多。在B树中查找到插入的位置后，\n并不能简单地将其添加到终端结点（最底层的非叶结点）中，因为此时可能会导致整棵树不再满\n足B树定义中的要求。将关键字key插入B树的过程如下：\n1）定位。利用前述的B树查找算法，找出插入该关键字的终端结点（在B树中查找key时，\n会找到表示查找失败的叶结点，因此插入位置一定是最底层的非叶结点）。\n2）插入。每个非根结点的关键字个数都在[m/2｜-1，m-1]。若结点插入后的关键字个数小\n于m，可以直接插入；若结点插入后的关键字个数大于m-1，必须对结点进行分裂。\n分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置（「m/2]）将其中的关\n键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间\n位置（m/21）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则\n继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。\n对于m=3的B树，所有结点中最多有m-1=2个关键字，若某结点中已有两个关键字，则\n所示，此时必须进行结点分裂，分裂的结果如图7.29（c）所示。\n\n第7章\n找\n313\n结点分裂\n20\n5052\n20\n505260\n2050\n60\n(a)插入前\n(b)插入后，结点溢出\n(c）结点分裂\n图7.29结点的“分裂”示意\n4.B树的删除\nB树的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个\n数≥[m/2]-1，因此将涉及结点的“合并”问题。\n命题追踪B树的删除操作的实例（2012、2022）\n当被删关键字k不在终端结点中时，可以用k的前驱（或后继）k，即k的左侧子树中“最\n右下”的元素（或右侧子树中“最左下”的元素），来替代k，然后在相应的结点中删除k，关键\n字k必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30的4阶B\n树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。\n6080\n删除80\n6878\n...\n68\n图7.30B树中删除非终端结点关键字的取代\n因此只需讨论被删关键字在终端结点中的情形，有下列三种情况：\n1）直接删除关键字。若被删关键字所在结点删除前的关键字个数≥「m/2]，表明删除该关键\n字后仍满足B树的定义，则直接删去该关键字。\n2）兄弟够借。若被删关键字所在结点删除前的关键字个数=「m/2]-1，且与该结点相邻的右\n（或左）兄弟结点的关键字个数≥「m/2]，则需要调整该结点、右（或左）兄弟结点及其双\n亲结点（父子换位法），以达到新的平衡。在图7.31(a)中删除4阶B树的关键字65，右\n兄弟关键字个数≥[m/2]=2，将71取代原65的位置，将74调整到71的位置。\n删除65\n6074\n7486\n71\n86\n(a)兄弟够借\n6071\n删除5\n71\n60\n65\n7486\n(b)兄弟不够借\n图7.314阶B树中删除终端结点关键字的示意图\n3）兄弟不够借。若被删关键字所在结点删除前的关键字个数=「m/2]-1，且此时与该结点相\n邻的左、右兄弟结点的关键字个数都=「m/2]-1，则将关键字删除后与左（或右）兄弟结\n点及双亲结点中的关键字进行合并。在图7.31（b)中删除4阶B树的关键字5，它及其右\n兄弟结点的关键字个数=「m/21-1=1，所以在5删除后将60合并到65结点中。\n\n314\n2026年数据结构考研复习指导\n命题追踪非空B树的查找、插入、删除操作的特点（2023）\n在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少\n至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根；\n若双亲结点不是根结点，且关键字个数减少到「m/21-2，则又要与它自已的兄弟结点进行调整或\n合并操作，并重复上述步骤，直至符合B树的要求为止。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0742",
        "title": "B+树的基本概念",
        "chapter_id": "c07",
        "description": "命题追踪B+树的应用场合（2017）\nB+树是应数据库所需而出现的一种B树的变形树。\n一棵m阶B+树应满足下列条件：\n1）每个分支结点最多有m棵子树（孩子结点）。\n2）非叶根结点至少有两棵子树，其他每个分支结点至少有「m/2］棵子树。\n3）结点的子树个数与关键字个数相等。\n4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，\n并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）。\n5）所有分支结点（可视为索引的索引）中仅包含它的各个子结点（下一级的索引块）中关\n键字的最大值及指向其子结点的指针。\n命题追踪B树和B+树的差异的分析（2016）\nm阶B+树与m阶B树的主要差异如下：\n1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树：而在\nB树中，具有n个关键字的结点含有n+1棵子树。\n2）在B+树中，每个结点（非根内部结点）的关键字个数n的范围是「m/2≤n≤m（非叶根\n结点：2≤n≤m）；而在B树中，每个结点（非根内部结点)的关键字个数n的范围是「m/2]-1\n≤n≤m-1（根结点：1≤n≤m-1）。\n3）在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而\n在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。\n4）在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含\n有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使\n一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快。\n5）在B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表。\n图7.32所示为一棵4阶B+树。可以看出，分支结点的关键字是其子树中最大关键字的副本。通\n常在B+树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对B+树\n进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。\n10205060\n7785\n81016204050556069778085\n图7.32B+树结构示意图\n\n第7章查\n找\n315\nB+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键\n字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。因此，在B+\n树中查找成功或失败（≤最大关键字）时，每次查找都是一条从根结点到叶结点的路径。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0751",
        "title": "散列表的基本概念",
        "chapter_id": "c07",
        "description": "在前面介绍的线性表和树表的查找中，查找记录需进行一系列的关键字比较，记录在表中的\n位置与记录的关键字之间不存在映射关系，因此在这些表中的查找效率取决于比较的次数。\n散列函数（也称哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，\n记为Hash(key）=Addr（这里的地址可以是数组下标、索引或内存地址等）。\n\n324\n2026年数据结构考研复习指导\n散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些\n方面，因为这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。\n散列表（也称哈希表）：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了\n关键字和存储地址之间的一种直接映射关系。\n理想情况下，对散列表进行查找的时间复杂度为0（1)，即与表中元素的个数无关。下面分别\n介绍常用的散列函数和处理冲突的方法。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0752",
        "title": "散列函数的构造方法",
        "chapter_id": "c07",
        "description": "在构造散列函数时，必须注意以下几点：\n1）散列函数的定义域必须包含全部关键字，而值域的范围则依赖于散列表的大小。\n2）散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能地减少冲突。\n3）散列函数应尽量简单，能在较短的时间内计算出任意一个关键字对应的散列地址。\n下面介绍常用的散列函数。\n1.直接定址法\n直接取关键字的某个线性函数值为散列地址，散列函数为\nH(key)=key或H(key)=axkey +b\n式中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的\n情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。\n2.除留余数法\n这是一种最简单、最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m\n的质数p，利用以下公式把关键字转换成散列地址。散列函数为\nH(key) = key % p\n除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上\n的任意一个地址，从而尽可能减少冲突的可能性。\n3.数字分析法\n设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某\n些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经\n常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集\n合，若更换了关键字，则需要重新构造新的散列函数。\n4.平方取中法\n顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情\n况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，\n适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。\n在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。\n在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0753",
        "title": "处理冲突的方法",
        "chapter_id": "c07",
        "description": "应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲\n突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。用H表示处理冲突\n\n第7章查\n找\n325\n中第i次探测得到的散列地址，假设得到的另一个散列地址H仍然发生冲突，只得继续求下一个\n地址H，以此类推，直到H不发生冲突为止，则H为关键字在表中的地址。\n1．开放定址法\n所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非\n同义词表项开放。其数学递推公式为\nH,=(H(key) +d)% m\n式中，H(key)为散列函数；i=1,2,··，k（k≤m-1)；m表示散列表表长；d为增量序列。\n取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：\n命题追踪?堆积现象导致的结果（2014）\n1）线性探测法，也称线性探测再散列法。d=1,2,…，m-1。它的特点是：冲突发生时，顺\n序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址是表首地址0），直\n到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n线性探测法可能使第i个散列地址的同义词存入第1+1个散列地址，这样本应存入第i+\n1个散列地址的元素就争夺第1+2个散列地址的元素的地址从而造成大量元素在相\n邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。\n2）平方探测法，也称二次探测法。d=1²,-1²,2²,-2²,.…,k²,-k²，其中k≤m/2，散列表长度\nm必须是一个可以表示成4k+3的素数。\n平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能\n探测到散列表上的所有单元，但至少能探测到一半单元。\n3）双散列法。d=ixHash2(key)。需要使用两个散列函数，当通过第一个散列函数H(key)得\n到的地址发生冲突时，则利用第二个散列函数Hashz（key)计算该关键字的地址增量。它的\n具体散列函数形式如下：\nH,=(H(key) + ixHash2(key)) % m\n初始探测位置H=H(key)%m。i是冲突的次数，初始为0。\n4）伪随机序列法。d=伪随机数序列。\n命题追踪\n散列表中删除部分元素后的查找效率分析（2023）\n注意\n采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径，删\n除元素时可以做一个删除标记，进行逻辑删除，具体举例见本书配套课程。但这样做的副作用是：执行\n多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。\n2.拉链法（链接法，chaining）\n显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，\n可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地\n址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入和删除操作主要在\n同义词链中进行。拉链法适用于经常进行插入和删除的情况。\n用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可尝试计算本例的平均ASL）。\n\n326\n2026年数据结构考研复习指导\n01142779\n1\n2\n3\n5568\n4\n5\n5\n1984\n7\nM\n8\n6\n10\n公众号：小兔网盘\n11\n免费网课+无水印PDF\n12\n图7.33拉链法处理冲突的散列表",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0754",
        "title": "散列查找及性能分析的应用",
        "chapter_id": "c07",
        "description": "命题追踪散列表的构造及查找效率的分析（2010、2018、2019、2024）\n散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函\n数可以计算出其散列地址，执行步骤如下：\n初始化：Addr=Hash(key);\n①检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，\n比较它与key的值，若相等，则返回查找成功标志，否则执行步骤②。\n②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤①。\n和线性探测处理冲突构造所得的散列表L如图7.34所示。\n0\n2345678\n9\n10\n11\n12\n13\n14\n15\n140168275519208479231110\n图7.34用线性探测法得到的散列表L\n给定值84的查找过程为：首先求得散列地址H（84）=6，因L[6]不空且L[6]≠84，则找第\n一次冲突处理后的地址H=（6+1）%16=7，而L[7]不空且L[7]≠84，则找第二次冲突处理后的\n地址H2=（6+2）%16=8，L[8]不空且L[8]=84，查找成功，返回记录在表中的序号8。\n给定值38的查找过程为：先求散列地址H（38）=12，L[12]不空且L[12]≠38，则找下一\n地址H=（12+1）%16=13，因为L[13]是空记录，所以表中不存在关键字为38的记录。\n查找各关键字的比较次数如图7.35所示。\n关键字\n14\n01\n682755\n192084\n79\n比较次数\n一\n2\n1114\n13\n3\n9\n3\n图7.35查找各关键字的比较次数\n平均查找长度ASL为\nASL=（1x6+2+3x3+4+9)/12=2.5\n对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们\n的平均查找长度也不同，本例与上节采用拉链法的平均查找长度不同。\n从散列表的查找过程可见：\n1）虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，\n\n第7章查\n找\n327\n使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程，因此仍然需要以平\n均查找长度作为衡量散列表的查找效率的度量。\n命题追踪】影响散列表查找效率的因素（2011、2022）\n2）散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。\n装填因子。散列表的装填因子一般记为α，定义为一个表的装满程度，即\n表中记录数n\nα=\n散列表长度m\n散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观地看，α\n越大，表示装填的记录越“满”，发生冲突的可能性越大；反之发生冲突的可能性越小。\n读者应能在给出散列表的长度、元素个数及散列函数和解决冲突的方法后，在求出散列表的\n基础上计算出查找成功时的平均查找长度和查找不成功的平均查找长度。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    }
]