[
    {
        "id": "kc0611",
        "title": "图的定义",
        "chapter_id": "c06",
        "description": "图G由顶点集V和边集E组成，记为G=（V，E)，其中V(G)表示图G中顶点的有限非空\n集；E(G)表示图G中顶点之间的关系（边）集合。若V={v，V2,，v)，则用IV表示图G中顶\n点的个数，E={（u,v)|ueV，veV}，用lE表示图G中边的条数。\n\n第6章图\n199\n注意\n线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图\n的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。\n下面是图的一些基本概念及术语。\n1.有向图\n若E是有向边（也称弧）的有限集合，则图G为有向图。弧是顶点的有序对，记为<v，w>，\n其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从v到w的弧，也称v邻接到w。\n图6.1(a)所示的有向图G,可表示为\nG=(V, El)\nV={1,2,3}\nE={<1,2>，<2,1>，<2,3>}\n2.无向图\n若E是无向边（简称边）的有限集合，则图G为无向图。边是顶点的无序对，记为（v，w）或\n(w,v)。可以说w和v互为邻接点。边(v,w)依附于w和v，或称边(v,w)和v,w相关联。\n图6.1（b)所示的无向图G2可表示为\nG2 = (V2, E2)\nV2={1,2,3,4}\nE2={(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)}\n(a)有向图G\n(b)无向图G2\n(c)有向完全图G\n图6.1图的示例\n3.简单图、多重图\n一个图G若满足：①不存在重复边；②不存在顶点到自身的边，则称图G为简单图。图6.1\n中G和G2均为简单图。若图G中某两个顶点之间的边数大于1条，又允许顶点通过一条边和\n自身关联，则称图G为多重图。多重图和简单图的定义是相对的。本书中仅讨论简单图。\n4.顶点的度、入度和出度\n命题追踪无向图中顶点和边的关系（2009、2017）\n在无向图中，顶点v的度是指依附于顶点v的边的条数，记为TD(v)。在图6.1(b)中，每个\n顶点的度均为3。无向图的全部顶点的度之和等于边数的2倍，因为每条边和两个顶点相关联。\n在有向图中，顶点的度分为入度和出度，入度是以顶点为终点的有向边的数目，记为\nID(v)：而出度是以顶点v为起点的有向边的数目，记为OD(v)。在图6.1(a)中，顶点2的出度为\n2、入度为1。顶点v的度等于其入度与出度之和，即TD（v)=ID(v)+OD（v)。有向图的全部顶点\n的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。\n\n200\n2026年数据结构考研复习指导\n5.路径、路径长度和回路\n顶点v,到顶点vg之间的一条路径是指顶点序列v,VV\",VV，当然关联的边也可理解\n为路径的构成要素。路径上的边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径\n称为回路或环。若一个图有n个顶点，且有大于n-1条边，则此图一定有环。\n6．简单路径、简单回路\n命题追踪路径、回路、简单路径、简单回路的定义（2011）\n在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，\n其余顶点不重复出现的回路称为简单回路。\n7.距离\n从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到\nv根本不存在路径，则记该距离为无穷（∞）。\n8.子图\n设有两个图G=（V,E)和G'=（V，E')，若V是V的子集，且E是E的子集，则称G'是G的\n子图。若有满足V(G')=V(G)的子图G'，则称其为G的生成子图。图6.1中G为G的子图。\n注意\n并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即E的子集中的某些边\n关联的顶点可能不在这个V的子集中。\nl\n9.连通、连通图和连通分量\n命题追踪）图的连通性与边和顶点的关系（2010、2022）\n在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。若图G中任意两个\n顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通\n分量，在图6.2（a)中，图G4有3个连通分量如图6.2（b）所示。假设一个图有n个顶点，若边数小\n于n-1，则此图必是非连通图；思考，若该图是非连通图，则最多可以有多少条边？①\nB\n4\nB\n(a）无向图G\n(b)G的三个连通分量\n图6.2无向图及其连通分量\n10.强连通图、强连通分量\n在有向图中，若有一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点\n①非连通情况下边最多的情况：由n-1个顶点构成一个完全图，此时再加入一个顶点则变成非连通图。\n\n第6章图\n201\n是强连通的。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连\n个顶点，若该图是强连通图，则最少需要有多少条边？①\n注意\n在无向图中讨论连通性，在有向图中讨论强连通性。\n11.生成树、生成森林\n连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成\n树含有n-1条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成\n树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通\n图中，连通分量的生成树构成了非连通图的生成森林。图G2的一个生成树如图6.4所示。\n图6.3图G的强连通分量\n图6.4图G2的一个生成树\n注意\n区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和\n边；极小连通子图是既要保持子图连通又要使得边数最少的子图。\n12.边的权、网和带权路径长度\n在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上\n带有权值的图称为带权图，也称网。路径上所有边的权值之和，称为该路径的带权路径长度。\n13.完全图（也称简单完全图）\n对于无向图，[E的取值范围为0到n(n-1)/2，有n（n-1)/2条边的无向图称为完全图，在完\n全图中任意两个顶点之间都存在边。对于有向图，E的取值范围为0到n（n-1)，有n（n-1)条弧\n的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图6.1\n中G2为无向完全图，而G为有向完全图。\n14.稠密图、稀疏图\n边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠\n密图常常是相对而言的。一般当图G满足[E<IVlog2IV时，可以将G视为稀疏图。\n15.有向树\n一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0621",
        "title": "邻接矩阵法",
        "chapter_id": "c06",
        "description": "所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中\n边的信息（各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。\n顶点数为n的图G=(V,E)的邻接矩阵A是nxn的，将G的顶点编号为v,V2\",V，则\n[1,\n(v,v,)或<v,v,>是E(G)中的边\nA[]U]=\n10,\n(v,v,)或<v,v,>不是E(G)中的边\n命题追踪图的邻接矩阵存储及相互转换（2011、2015、2018）\n对带权图而言，若顶点v，和v之间有边相连，则邻接矩阵中对应项存放着该边对应的权\n值，若顶点V和V不相连，则通常用0或∞来代表这两个顶点之间不存在边：\nW'ij,\n(v,v,)或<v,v>是E(G)中的边\nA[]U]=\n0或∞，（v,v)或<v,v>不是E(G)中的边\n有向图、无向图和网对应的邻接矩阵示例如图6.5所示。\n②\n011\n0000\n000\n1000\n01100\n(a)有向图G及其邻接矩阵\n(b)无向图G及其邻接矩阵\n(c)网及其邻接矩阵（对角线元素也经常用0表示）\n图6.5有向图、无向图及网的邻接矩阵\n命题追踪（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）\n图的邻接矩阵存储结构定义如下：\n#define MaxVertexNum 100\n//顶点数目的最大值\ntypedef char VertexType;\n/顶点对应的数据类型\ntypedef int EdgeType;\n//边对应的数据类型\ntypedef struct{\nVertexType vex[MaxVertexNum];\n//顶点表\nEdgeType edge[MaxVertexNum] [MaxVertexNum];//邻接矩阵，边表\n\n第6章图\n207\nint vexnum,arcnum;\n//图的当前顶点数和边数\n)MGraph;\n注意\n①在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。\n②当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可用值为0和1的枚举类型。\n③无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。\n④邻接矩阵表示法的空间复杂度为O(n²)，其中n为图的顶点数1]。\n命题追踪邻接矩阵的遍历的时间复杂度（2021）\n图的邻接矩阵存储表示法具有以下特点：\n①无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需\n存储上（或下）三角矩阵的元素。\n命题追踪基于邻接矩阵的顶点的度的计算（2013、2021、2023）\n②对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非元素）的个数正好是顶点\ni的度TD(v)。\n③对于有向图，邻接矩阵的第i行非零元素（或非元素）的个数正好是顶点1的出度\nOD（vi)：第i列非零元素（或非o元素）的个数正好是顶点i的入度ID（v)。\n④用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图\n中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。\n③稠密图（边数较多的图）适合采用邻接矩阵的存储表示。\n命题追踪计算A并说明A\"[小V]的含义（2015）\n③设图G的邻接矩阵为A，A\"的元素A\"[]U]等于由顶点i到顶点j的长度为n的路径的数\n目。该结论了解即可，证明方法可参考离散数学教材。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0622",
        "title": "邻接表法",
        "chapter_id": "c06",
        "description": "当一个图为稀疏图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合\n了顺序存储和链式存储方法，大大减少了这种不必要的浪费。\n所谓邻接表，是指对图G中的每个顶点v建立一个单链表，第i个单链表中的结点表示依\n附于顶点v的边（对于有向图则是以顶点v为尾的弧），这个单链表就称为顶点v的边表（对于\n有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻\n接表中存在两种结点：顶点表结点和边表结点，如图6.6所示。\n顶点域\n边表头指针\n邻接点域\n指针域\ndata\nfirstarc\nadjvex\nnextarc\n顶点表结点\n边表结点\n图6.6顶点表和边表结点结构\n顶点表结点由两个域组成：顶点域（data）存储顶点v的相关信息，边表头指针域\n（firstarc）指向第一条边的边表结点。边表结点至少由两个域组成：邻接点域（adjvex）存\n储与头结点顶点v，邻接的顶点编号，指针域（nextarc）指向下一条边的边表结点。\n\n208\n2026年数据结构考研复习指导\n命题追踪\n图的邻接表存储的应用（2014）\n无向图和有向图的邻接表的实例分别如图6.7和图6.8所示。\n3\n4/\n(a）无向图G\n(b)无向图G的邻接表的表示\n图6.7无向图邻接表表示法实例\n41/\n(a)有向图G\n(b)有向图G的邻接表的表示\n图6.8有向图邻接表表示法实例\n图的邻接表存储结构定义如下：\n#define MaxVertexNum 100\n//图中顶点数目的最大值\ntypedef struct ArcNode\n//边表结点\nint adjvex;\n//该弧所指向的顶点的位置\nstruct ArcNode *nextarc;\n/指向下一条弧的指针\nI/InfoType info;\n//网的边权值\n)ArcNode;\ntypedef struct VNode\n//顶点表结点\nVertexType data;\n//顶点信息\nArcNode *firstarc;\n//指向第一条依附该顶点的弧的指针\n)VNode,AdjList[MaxVertexNum];\ntypedef struct{\nAdjList vertices;\n//邻接表\nint vexnum,arcnum;\n//图的顶点数和弧数\n)ALGraph;\nI/ALGraph是以邻接表存储的图类型\n图的邻接表存储方法具有以下特点：\n①若G为无向图，则所需的存储空间为O(IV+2|E)：若G为有向图，则所需的存储空间为\nO(IV+|E)。前者的倍数2是因为在无向图中，每条边在邻接表中出现了两次。\n命题追踪邻接矩阵法和邻接表法的适用性差异（2011）\n②对于稀疏图（边数较少的图），采用邻接表表示将极大地节省存储空间。\n③在邻接表中，给定一个顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接\n表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但是，若要确定\n给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在\n相应结点对应的边表中查找另一结点，效率较低。\n\n第6章图\n209\n④在无向图的邻接表中，求某个顶点的度只需计算其邻接表中的边表结点个数。在有向图\n的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数；但求某个顶点x\n的入度则需遍历全部的邻接表，统计邻接点（adjvex）域为x的边表结点个数。\n③图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是\n任意的，它取决于建立邻接表的算法及边的输入次序。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0623",
        "title": "十字链表",
        "chapter_id": "c06",
        "description": "十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点（弧\n结点）来表示，每个顶点也用一个结点（顶点结点）来表示。两种结点的结构如下所示。\n弧结点\n顶点结点\ntailvexheadvexhlinktlink（info)\ndatafirstinfirstout\n弧结点中有5个域：tailvex域和headvex域分别存放弧尾和弧头这两个顶点的编号；\n头链域hlink指向弧头相同的下一条弧：尾链域tlink指向弧尾相同的下一条弧：info域存\n放该弧的相关信息。这样，弧头相同的弧在同一个链表上，弧尾相同的弧也在同一个链表上。\n顶点结点中有3个域：data域存放该顶点的数据信息，如顶点名称；firstin域指向以\n该顶点为弧头的第一条弧：firstout域指向以该顶点为弧尾的第一条弧。\n图6.9为有向图的十字链表表示法。\n012\n20\n23\n303132\n(a)\n(b)\n图6.9有向图的十字链表表示（弧结点省略info域）\n注意，顶点结点之间是顺序存储的，弧结点省略了info域。\n在十字链表中，既容易找到V为尾的弧，也容易找到V为头的弧，因而容易求得顶点的出\n度和入度。图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0624",
        "title": "邻接多重表",
        "chapter_id": "c06",
        "description": "邻接多重表是无向图的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，\n但求两个顶点之间是否存在边而执行删除边等操作时，需要分别在两个顶点的边表中遍历，效\n率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。\nivex\nilink\njvex\njlink\n(info)\n其中，ivex域和jvex域存放该边依附的两个顶点的编号：ilink域指向依附于顶点ivex的\n下一条边；jlink域指向依附于顶点jvex的下一条边，info域存放该边的相关信息。\n每个顶点也用一个结点表示，它由如下所示的两个域组成。\ndata\nfirstedge\n\n210\n2026年数据结构考研复习指导\n其中，data域存放该顶点的相关信息，firstedge域指向依附于该顶点的第一条边。\n在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶\n点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅\n在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。\n命题追踪图的邻接多重表表示的分析（2024）\n图6.10为无向图的邻接多重表表示法。邻接多重表的各种基本操作的实现和邻接表类似。\n0\n3\n图6.10无向图的邻接多重表表示（边结点省略info域）\n图的四种存储方式的总结如表6.1所示。\n表6.1图的四种存储方式的总结\n邻接矩阵\n邻接表\n十字链表\n邻接多重表\n无向图：O（I+2|E)\n空问复杂度\nO(V)\nO(N+[E)\nO(IN+|E)\n有向图：O(IV+[E)\n遍历对应行或列的时间\n找有向图的入度必须遍历\n找相邻边\n很方便\n很方便\n复杂度为O(I)\n整个邻接表\n删除边很方便，删除顶\n无向图中删除边或顶点都\n删除边或顶点\n很方便\n很方便\n点需要大量移动数据\n不方便\n适用于\n稠密图\n稀疏图和其他\n只能存有向图\n只能存无向图\n表示方式\n唯\n不唯\n不唯\n不唯",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0625",
        "title": "",
        "chapter_id": "c06",
        "description": "图的基本操作\n图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会\n有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。\n图的基本操作主要包括（仅抽象地考虑，所以忽略各变量的类型）：\n·Adjacent（G,x,Y)：判断图G是否存在边<x,y>或（x,y）。\n·Neighbors（G，x)：列出图G中与结点x邻接的边。\n·InsertVertex(G,x)：在图G中插入顶点x。\n·DeleteVertex（G，x)：从图G中删除顶点x。\n·AddEdge（G，x，y)：若无向边（x，y）或有向边<x，y>不存在，则向图G中添加该边。\n·RemoveEdge(G,x,Y)：若无向边(x,y)或有向边<x,y>存在，则从图G 中删除该边。\n·FirstNeighbor（G，x)：求图G 中顶点x的第一个邻接点，若有则返回顶点号。若x\n没有邻接点或图中不存在x，则返回-1。\n·NextNeighbor（G，x，y)：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶\n点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。\n\n第6章图\n211\n·Get_edge_value(G,x,y)：获取图G 中边(x,y)或<x,y>对应的权值。\n·Set_edge_value(G,x,y,v)：设置图G 中边(x,y)或<x, y>对应的权值为v。\n此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算\n法包括深度优先遍历和广度优先遍历，具体见下一节的内容。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0631",
        "title": "广度优先搜索",
        "chapter_id": "c06",
        "description": "广度优先搜索（Breadth-First-Search，BFS）类似于树的层序遍历。基本思想是：首先访问起\n始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w，W2,，w，然后依次访问\nWi，W2,\"，w,的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访\n问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选\n图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。\nDijkstra单源最短路径算法和Prim最小生成树算法也应用了类似的思想。\n换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和v有路径相通\n且路径长度为1，2，·的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问\n批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层\n的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。\n广度优先搜索算法的伪代码如下：\nbool visited[MAx_VERTEX_NUM];\n/访问标记数组\nvoid BFsTraverse(Graph G)(\n//对图G进行广度优先遍历\nfor（i=0;i<G.vexnum;++i)\nvisited[i]=FALSE;\n/访问标记数组初始化\nInitQueue(Q);\n//初始化辅助队列Q\nfor（i=0;i<G.vexnum;++i)\n1//从0号顶点开始遍历\nif(!visited[i])\n//对每个连通分量调用一次BFS（）\nBFS(G,i);\n//若v未访问过，从v;开始调用BFS（）\n用邻接表实现广度优先搜索的算法如下：\nvoid BFS(ALGraph G,int i){\n\n220\n2026年数据结构考研复习指导\nvisit(i);\n/访问初始顶点1\nvisited[i]=TRUE;\n/对主做已访问标记\nEnQueue(Q,i);\n/顶点i入队\nwhile(!IsEmpty(Q))(\nDeQueue(Q,v);\n/队首顶点v出队\nfor(p=G.vertices[v] .firstarc;pip=p->nextarc)(//检测v的所有邻接点\nw=p->adjvex;\nif(visited[w]==FALSE){\nvisit(w);\n//w为v的尚未访问的邻接点，访问w\nvisited[w]=TRUE;\n//对w做已访问标记\n//顶点w入队\nEnQueue（Q,w);\n用邻接矩阵实现广度优先搜索的算法如下：\nvoid BFS(MGraph G,int i){\nvisit(i);\n/访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nEnQueue(Q,i）;\n//顶点i入队\nwhile(!IsEmpty(Q)){\nDeQueue(Q,v);\n//队首顶点v出队\nfor（w=0;w<G.vexnum;w++)\n/检测v的所有邻接点\nif(visited[w]==FALSE&&G.edge[v][w]==l){\nvisit(w);\n//w为v的尚未访问的邻接点，访问w\nvisited[w]=TRUE;\n//对w做已访问标记\nEnQueue(Q,w);\n//顶点w入队\n辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程\n中，一旦某个顶点v,被访问，就立即置visited[i]为TRUE，防止它被多次访问。\n命题追踪广度优先遍历的过程（2013）\n下面通过实例演示广度优先搜索的过程，给定图G如图6.11所示。假设从顶点a开始访\n问，a先入队。此时队列非空，取出队头元素α，因为b，c与a邻接且未被访问过，于是依次访\n问b，c，并将b，c依次入队。队列非空，取出队头元素b，依次访问与b邻接且未被访问的顶点\nd,e，并将d，e入队（注意：a与b也邻接，但a已置访问标记，所以不再重复访问）。此时队列\n非空，取出队头元素c，访问与c邻接且未被访问的顶点fg，并将fg入队。此时，取出队头元\n素d，但与d邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素e，将h入\n队列……·最终取出队头元素h后，队列为空，从而循环自动跳出。遍历结果为abcdefgh。\n图6.11\n一个无向图G\n\n第6章图\n221\n从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明\n了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。\n1.BFS算法的性能分析\n无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均\n需入队一次，在最坏的情况下，空间复杂度为O(IV)。\n命题追踪基于邻接表存储的BFS的效率（2012）\n遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结\n构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为O(I)，在搜索每个顶\n点的邻接点时，每条边至少访问一次，时间复杂度为O(E)，总的时间复杂度为O(V+E)。采用\n邻接矩阵存储时，查找每个顶点的邻接点所需的时间为O(IV)，总时间复杂度为O(IV)。\n2.BFS算法求解单源最短路径问题\n若图G=（V,E)为非带权图，定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路\n径中最少的边数；若从u到v没有通路，则d(u,v)=∞∞。\n使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度\n优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。\nBFS算法求解单源最短路径问题的算法如下：\nvoid BFS_MIN_Distance(Graph G,int u)(\nlld[i]表示从u到i结点的最短路径\nfor（i=0;i<G.vexnum;++i)\nd[i]=;\n//初始化路径长度\nvisited[u]=TRUE;d[u]=0;\nEnQueue(Q,u);\nwhile(!isEmpty(Q)){\n//BFS算法主过程\nDeQueue(Q,u);\n/队头元素u出队\nfor(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w))\nif(!visited[w]){\n//w为u的尚未访问的邻接顶点\nvisited[w]=TRUE;\n/设已访问标记\nd[w]=d[u]+1;\n/路径长度加1\nEnQueue (Q, w) ;\n/顶点w入队\n3.广度优先生成树\n在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。\n需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，\n但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。\n图6.12图的广度优先生成树\n\n222\n2026年数据结构考研复习指导",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0632",
        "title": "深度优先搜索",
        "chapter_id": "c06",
        "description": "与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如\n其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。\n它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访\n问的任意一个顶点w，再访问与w邻接且未被访问的任意一个顶点w重复上述过程。当不\n能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该\n点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。\n一般情况下，其递归形式的算法十分简洁，算法过程如下：\nbool visited[MAX_VERTEX_NUM];\n//访问标记数组\nvoid DFsTraverse(Graph G)(\n//对图G进行深度优先遍历\nfor(i=0;i<G.vexnum;i++)\nvisited[i]=FALSE;\n/初始化已访问标记数组\nfor（i=0;i<G.vexnum;i++)\n//本代码中是从v开始遍历\nif(!visited[i])\n//对尚未访问的顶点调用DFS（）\nDFS(G,i);\n用邻接表实现深度优先搜索的算法如下：\nvoid DFS(ALGraph G,int i）{\nvisit(i);\n//访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nfor(p=G.vertices[i].firstarc;p;p=p->nextarc)(/检测i 的所有邻接点\nj=p->adjvex;\nif(visited[j]==FALSE)\nDFS(G,j);\n//j为i的尚未访问的邻接点，递归访问j\n用邻接矩阵实现深度优先搜索的算法如下：\nvoid DFS（MGraph G,int i){\nvisit(i);\n/访问初始顶点i\nvisited[i]=TRUE;\n//对i做已访问标记\nfor（j=0;j<G.vexnum;j++）{\n/检测i的所有邻接点\nif(visited[j]==FALSE&&G.edge[i][j]==1)\nDFS(G,j);\nj为i的尚未访问的邻接点，递归访问j\n命题追踪深度优先遍历的过程（2015、2016）\n以图6.11的无向图为例，深度优先搜索的过程：首先访问a，并置a访问标记：然后访问与a\n邻接且未被访问的顶点b，置b访问标记：然后访问与b邻接且未被访问的顶点d，置d访问标\n记。此时d已没有未被访问过的邻接点，所以返回上一个访问的顶点b，访问与其邻接且未被访问\n的顶点e，置e访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。\n注意\n图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因\n此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得\n到的DFS序列和BFS序列是不唯一的。\n\n第6章图\n223\n1.DFS算法的性能分析\nDFS算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为O（IV)。\n遍历图的过程实质上是通过边查找邻接点的过程，因此两种遍历方式的时间复杂度都相\n同，不同之处仅在于对顶点访问顺序的不同。采用邻接矩阵存储时，总时间复杂度为O(IV)。\n采用邻接表存储时，总的时间复杂度为O(IV+|E)。\n2.深度优先的生成树和生成森林\n与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，\n即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林，如图6.13所\n示。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。\n图6.13图的深度优先生成森林",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0633",
        "title": "图的遍历与图的连通性",
        "chapter_id": "c06",
        "description": "图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意\n一个结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个\n顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的\n顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路\n径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。\n因此，在BFSTraverse（）或DFSTraverse（）中添加了第二个for循环，再选取初始点\n继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS（G，i）\n或DFS（G，i）的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图\n分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一\n次调用BFS（G，i）或DFS（G，i）不一定能访问到该子图的所有顶点，如图6.14所示。\n图6.14有向图的非强连通分量",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0641",
        "title": "最小生成树",
        "chapter_id": "c06",
        "description": "一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍\n去一条边，则会使生成树变成非连通图：若增加一条边，则会在图中形成一条回路。\n对于一个带权连通无向图G，生成树不同，每棵树的权（树中所有边的权值之和）也可能\n不同。权值之和最小的那棵生成树称为G的最小生成树（Minimum-Spanning-Tree,MST）。\n命题追踪最小生成树的性质（2012、2017）公众号：小兔网盘免费分享无水印PDF\n不难看出，最小生成树具有如下性质：\n1）若图G中存在权值相同的边，则G的最小生成树可能不唯一，即最小生成树的树形不\n唯一。当图G中的各边权值互不相等时，G的最小生成树是唯一的：若无向连通图G的\n边数比顶点数少1，即G本身是一棵树时，则G的最小生成树就是它本身。\n2）虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。\n3）最小生成树的边数为顶点数减1。\n命题追踪最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）\n注意\n最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间的路径是最短路径。如下图所\n示，最小生成树中A到C的路径长度为5，但图中A到C的最短路径长度为4。\n最小生成树\n\n232\n2026年数据结构考研复习指导\n构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设G=(V,E)\n是一个带权连通无向图，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值的边，其\n中ueU，veV-U，则必存在一棵包含边(u,v)的最小生成树。\n基于该性质的最小生成树算法主要有Prim算法和Kruskal算法，它们都基于贪心算法的策\n略。对这两种算法应主要掌握算法的本质含义和基本思想，并能动手模拟算法的实现步骤。\n下面介绍一个通用的最小生成树算法：\nGENERIC MST(G){\nT=NULL;\nwhileT未形成一棵生成树；\ndo找到一条最小代价边（u,v)并且加入T后不会产生回路；\nT=TU（u,v);\n通用算法每次加入一条边以逐渐形成一棵生成树，下面介绍两种实现上述通用算法的途径。\n1.Prim算法\nPrim（普里姆）算法的执行非常类似于寻找图的最短路径的Diikstra算法（见下一节）。\n命题追踪Prim算法构造最小生成树的实例（2015、2017、2018）\nPrim算法构造最小生成树的过程如图6.15所示。初始时从图中任取一顶点（如顶点1）加\n入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该\n顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶\n点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。\n图6.15Prim算法构造最小生成树的过程\nPrim算法的步骤如下：\n假设G={V,E}是连通图，其最小生成树T=(U,E)，Er是最小生成树中边的集合。\n初始化：向空树T=(U,E)中添加图G=(V,E)的任意一个顶点uo，使U={uo}，Er=。\n循环（重复下列操作直至U=V)：从图G中选择满足{（u,v)ueU,veV-U}且具有最小权值\n的边(u,v)，加入树 T，置U=UU{v}，Er=ErU{(u,v)}。\nPrim算法的简单实现如下：\nvoid Prim(G,T){\nT=O;\n/初始化空树\nU={w};\n//添加任意一个顶点w\n\n第6章图\n233\nwhile((V-U)!=O){\n若树中不含全部顶点\n设(u,v)是使ueU与v∈(V-U)，且权值最小的边;\nT=TU{（u,v）};\n/边归入树\nU=UU{v};\n/顶点归入树\nPrim算法的时间复杂度为O(IV)，不依赖于|E，因此它适用于求解边稠密的图的最小生成\n树。虽然采用其他方法能改进Prim算法的时间复杂度，但增加了实现的复杂性。\n2.Kruskal算法\n与Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合\n适的边来构造最小生成树的方法。\n命题追踪Kruskal算法构造最小生成树的实例（2015、2018、2020）\n通图T={V，，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取\n当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上（使用并查集\n判断这两个顶点是否属于同一棵集合树），则将此边加入T，否则舍弃此边而选择下一条权值\n最小的边。以此类推，直至T中所有顶点都在一个连通分量上。\nKruskal算法的步骤如下：\n假设G=(V,E)是连通图，其最小生成树T=(U,ET)。\n初始化：U=V,Er=O。即每个顶点构成一棵独立的树，T此时是一个仅含IV个顶点的森林。\n循环（重复直至T是一棵树）：按G的边的权值递增顺序依次从E-Er中选择一条边，\n若这条边加入T后不构成回路，则将其加入Er，否则舍弃，直到Er中含有n-1条边。\nV\nV\nV\n图6.16Kruskal算法构造最小生成树的过程\nKruskal算法的简单实现如下：\nvoid Kruskal(V,T)(\nT=V;\n//初始化树T，仅含顶点\nnumS=n;\n//连通分量数\nwhile(numS>1)(\n//若连通分量数大于1\n从E中取出权值最小的边（v，u）；\nif（v和u属于T中不同的连通分量）（\nT=TU((v,u）};\n//将此边加入生成树中\nnumS--;\n//连通分量数减1\n\n234\n2026年数据结构考研复习指导\n根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是\n连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。\n在Kruskal算法中，最坏情况需要对|E条边各扫描一次。通常采用堆（见第7章）来存放边\n的集合，每次选择最小权值的边需要O(logE)的时间：每次使用并查集来快速判断两个顶点是\n否属于一个集合所需的时间为O(α(IV))，α(IV1)的增长极其缓慢，可视为常数。算法的总时间复\n杂度为O(|Elog2|El)，不依赖于IV，因此Kruskal算法适合于边稀疏而J顶点较多的图。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0642",
        "title": "最短路径",
        "chapter_id": "c06",
        "description": "命题追踪）最短路径的分析与举例以及相关的算法（2009、2023）\n6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个\n顶点vo到图中其余任意一个顶点v，的一条路径所经过边上的权值之和，定义为该路径的带权路\n径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。\n求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他\n顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求\n图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解：二是\n求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。\n1.Dijkstra算法求单源最短路径问题\nDijkstra算法设置一个集合S记录已求得的最短路径的顶点，初始时把源点vo放入S，集合\nS每并入一个新顶点V，都要修改源点vo到集合V-S中顶点当前的最短路径长度值（这里可能\n不太好理解？没关系，继续往下看，相信会逐步理解）。\n在构造的过程中还设置了三个辅助数组：\n·final[]：标记各顶点是否已找到最短路径，即是否归入集合S。\n·dist[]：记录从源点vo到其他各顶点当前的最短路径长度，它的初始值为：若从vo到\nv有弧，则dist[i]为弧上的权值；否则置dist[i]为o。\n·path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。在算法结束时，可\n根据其值追溯得到源点v到顶点v的最短路径。\n假设从顶点0出发，即vo=0，集合S最初只包含顶点O，邻接矩阵arcs表示带权有向\n图，arcs[i][j]表示有向边<i>的权值，若不存在有向边<ij>，则arcs[i][j]为o。\nDijkstra算法的步骤如下（不考虑对path[]的操作）：\n1）初始化：集合S初始为{0]，dist[]的初始值dist[i]=arcs[0][i],i=1,2,\"，n-1。\n的一条从vo出发的最短路径的终点，令S=SU{}。\n3）修改从vo出发到集合V-S上任意一个顶点v可达的最短路径长度：若dist[j]+\narcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]。\n4）重复2）～3）操作共n-1次，直到所有的顶点都包含在集合S中。\n步骤3）也就是开头留下的疑问，每当一个顶点加入集合S后，可能需要修改源点vo到集\n合V-S中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为Vo，初\n始时S={vo}，dist[1]=3，dist[2]=7，当将v并入集合S后，dist[2]需要更新为4。\n\n第6章图\n235\n思考：Diikstra算法与Prim算法有何异同之处？\n命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）\n例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如\n表6.2所示。算法执行过程的说明如下。\n每轮得到的最短路径如下：\n第1轮：1→5，路径距离为5\n第2轮：1→5→4，路径距离为7\n第3轮：1→5→2，路径距离为8\n第4轮：1→5→2→3，路径距离为9\n图6.17应用Dijkstra算法图\n表6.2从v到各终点的dist值和最短路径的求解过程\n顶点\n第1轮\n第2轮\n第3轮\n第4轮\n10\n8\n8\n2\nv→V2\nV→V5→V2\nV→Vs→V2\n14\n13\n9\n3\n8\nV1-→V5-V3\nV1-Vs-→V4-→V3\nvI-Vs-→V2-→V3\n7\n4\n8\nV→V5→V4\n5\n5\nV-Vs\n集合S\n(1.5)\n(1,5,4)\n{1,5,4,2}\n{1,5,4,2,3}\n初始化：集合S初始为{v}，V可达v2和V，V不可达v和v4，因此dist[]数组各元素的\n初始值依次设置为dist[2]=10，dist[3]=∞，dist[4]=∞，dist[5]=5。\n第1轮：选出最小值dist[5]，将顶点vs并入集合S，即此时已找到v到v的最短路径。当\nvs加入S后，从v到集合V-S中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]\n数组。vs可达v2，因v→v5→v2的距离8比dist[2]=10小，更新dist[2]=8；vs可达v3，\nvi→V5→>V的距离 14，更新 dist[3]=14；vs可达v4，Vi→Vs→V4的距离 7，更新 dist[4]=7。\n第2轮：选出最小值 dist[4］，将顶点v4并入集合S。继续更新 dist[]数组。v4不可达\nV2，dist[2]不变；v4可达v3，V→v5→V4→v的距离13比dist[3]小，故更新dist[3]=13。\n第3轮：选出最小值dist[2]，将顶点v2并入集合S。继续更新 dist[]数组。v2可达v3,\nv→v5→v2→v的距离9比dist[3]小，更新dist[3]=9。\n第4轮：选出唯一最小值dist[3]，将顶点v并入集合S，此时全部顶点都已包含在S中。\n显然，Dijkstra算法也是基于贪心策略的。\n①Dijkstra算法的流程、操作与Prim算法的都很相似，都基于贪心策略。区别在于，i.目的不同：Dijkstra 算法的目的是构建单\n源点的最短路径树：Prim算法的目的是构建最小生成树。ii.算法思路略有不同：Prim算法从一个点开始，每次选择权值最小\n的边，将其连接到已构建的生成树上，直至所有顶点都已加入：而Dijkstra算法每次找出到源点距离最近且未归入集合的\n点，并把它归入集合，同时以这个点为基础更新从源点到其他所有顶点的距离。ii.适用的图不同：Pri算法只能用于带权无\n向图：Dijkstra算法可用于带权有向图或带权无向图。\n\n236\n2026年数据结构考研复习指导\n使用邻接矩阵表示时，时间复杂度为O(IV²)。使用带权的邻接表表示时，虽然修改dist[]\n的时间可以减少，但因为在dist[]中选择最小分量的时间不变，所以时间复杂度仍为O（(IV)。\n人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所\n有顶点的最短路径一样复杂，时间复杂度也为O(IVF)。\n注意，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与集合S\n（已求得最短路径的顶点集，归入S内的顶点的最短路径不再变更）内某顶点（记为a）以负边\n相连的顶点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于a\n原先确定的最短路径长度，而此时a在Dijkstra算法下是无法更新的。例如，对于图6.18所示的\n带权有向图，利用Dijkstra算法不一定能得到正确的结果。\n(b)\n图6.18边上带有负权值的有向带权图\n2.Floyd算法求各顶点之间最短路径问题\n求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对\n任意两个顶点v≠v，要求求出v与v之间的最短路径和最短路径长度。\nFloyd算法的基本思想是：递推产生一个n阶方阵序列A(-)，,A,.…，A\",…，A\"-I)，其中\nA[U]表示从顶点v到顶点v的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任\n意两个顶点v和v，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它\n们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶\n点k（k=0，1,，n-1）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少\n了，则以此新路径代替原路径。算法描述如下：\n定义一个n阶方阵序列A(-!),A.…,A(\"-1，其中，\nA(-[i]U] = arcs[i]U]\n[u.I 0 = []( +[(-) [)} =[(\n式中，A[]U]是从顶点v,到v、中间顶点是v的最短路径的长度，A*[i]U]是从顶点v,到v、中\n间顶点的序号不大于k的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从v\n到v的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的A\"-\"[ilU]就是v到v的最\n短路径长度，即方阵A\"-1中就保存了任意一对顶点之间的最短路径长度。\n图6.19所示为带权有向图G及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长\n度的过程如表6.3所示。算法执行过程的说明如下。\n10\n(a)有向图G\n(b)G的邻接矩阵\n图6.19带权有向图G及其邻接矩阵\n\n第6章图\n237\n初始化：方阵A(-[i]U]=arcs[i]U]。\n第1轮：将v作为中间顶点，对于所有顶点对{ij}，若有A\"[i]>A[i[0]+A[0]，则将\nA\"[]U]更新为A[][0]+A[0]U]。有A[2][1]>A[2]I0]+A[0][1]=11，更新A[2][1]=11，更\n新后的方阵标记为4\n第2轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A°[0]12]>A\"[0][1]+A[1]12]=\n10，更新A[0][2]=10，更新后的方阵标记为A'。\n第3轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A'[1]I0]>A'[1][2]+A'[2]I0]=9,\n更新 A'[1]I0]=9，更新后的方阵标记为 A。此时 A²中保存的就是任意顶点对的最短路径长度。\n表6.3Floyd算法的执行过程\nA(-1)\nA(O)\nAU)\nA(2)\nVo\nV\nVo\nV\nV2\nV\nV\nV2\n01\nV\nV2\nVo\n0\n6\n13\n0\n6\n13\n0\n6\n1\n0\n6\n10\nV\n10\n0\n4\n10\n0\n4\n10\n0\n4\n0\nV2\n5\n8\n0\n5\n11\n0\n5\n015\n11\n0\nFloyd算法的时间复杂度为O(V)。不过其代码很紧凑，且并不包含其他复杂的数据结构，\n因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。\nFloyd算法允许图中有带负权值的边，但不允许包含总权值为负的回路。Floyd算法同样适\n用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。\n也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源\n点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为O(IV)·V=O(IV)。\nBFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。\n表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结\nBFS算法\nDijkstra算法\nFloyd算法\n用途\n求单源最短路径\n求单源最短路径\n求各顶点之间的最短路径\n无权图\n适用\n适用\n适用\n带权图\n不适用\n适用\n适用\n带负权值的图\n不适用\n不适用\n适用\n带负权回路的图\n不适用\n不适用\n不适用\n时间复杂度\n0()或 O(N+ [E)\n0(V)\noW)",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0643",
        "title": "",
        "chapter_id": "c06",
        "description": "有向无环图描述表达式\n有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。\n命题追踪构建表达式的有向无环图（2019）\n有向无环图是描述含有公共子式的表达式的有效工具。例如表达式\n(（p+∞）)((p+∞)+(（p+∞)9）(q+D))\n可以用上一章描述的二叉树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的\n子表达式（c+d)和（c+d)*e，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对\n相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。\n\n238\n2026年数据结构考研复习指导\n图6.20\n二叉树描述表达式\n图6.21\n有向无环图描述表达式\n用有向无环图描述表达式的解题方法举例见本书配套课程。\n注意\n在表达式的有向无环图表示中，不可能出现重复的操作数顶点",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0644",
        "title": "拓扑排序",
        "chapter_id": "c06",
        "description": "AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边<V，V>表示活动V必\n须先于活动V进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网。\n在AOV网中，活动V是活动V的直接前驱，V是V的直接后继，这种前驱和后继关系具有传\n递性，且任何活动V不能以它自己作为自己的前驱或后继。\n称为该图的一个拓扑排序：\n1）每个顶点出现且只出现一次。\n2）若顶点A在序列中排在顶点B的前面，则在图中不存在从B到A的路径。\n或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶\n命题追踪拓扑排序和回路的关系（2011）\n对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：\n①从AOV网中选择一个没有前驱（入度为0）的顶点并输出。\n②从网中删除该顶点和所有以它为起点的有向边。\n③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况\n说明有向图中必然存在环。\n命题追踪拓扑排序的实例（2010、2014、2018、2021）\n图6.22所示为拓扑排序过程的示例。每轮选择一个入度为0的顶点并输出，然后删除该顶\n点和所有以它为起点的有向边，最后得到拓扑排序的结果为{1,2,4,3,5}。\n结点号\n1\n2\n3\n4\n5\n初始入度\n0\n1\n2\n2\n2\n第1轮\n0\n2\n2\n第2轮\n0\n2\n第3轮\n0\nA\n第4轮\n第5轮\n(a)\n图6.22有向无环图的拓扑排序过程\n\n第6章图\n239\n出\n(b)\n图6.22有向无环图的拓扑排序过程（续）\n命题追踪\n（算法题）拓扑排序的实现（2024）\n拓扑排序算法（基于邻接表存储）的实现如下：\nbool TopologicalSort(Graph G) (\nInitStack(S);\n//初始化栈，存储入度为0的顶点\ninti;\nfor（i=0;i<G.vexnum;i++)\nif(indegree[i]==0)\nPush(S,i);\n/将所有入度为0的顶点入栈\nint count=0;\n//计数，记录当前已经输出的顶点数\nwhile(!IsEmpty(S)){\n/栈不空，则存在入度为0的顶点\nPop(S,i）;\n/栈顶元素出栈\nprint[count++]=i;\n//输出顶点\nfor(p=G.vertices[i].firstarc;p;p=p-\n->nextarc){\n/将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S\nv=p->adjvex;\nif(!(--indegree[v]))\nPush(S,v);\n1/入度为0，则入栈\nif(count<G.vexnum)\nreturn\nfalse;\n/排序失败，有向图中有回路\nelse\nreturn\ntrue;\n//拓扑排序成功\n命题追踪\n不同存储方式下的拓扑排序的效率（2016）\n因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时\n间复杂度为O(IV+[E)，采用邻接矩阵存储时拓扑排序的时间复杂度为O(IV)。\n命题追踪DFS实现拓扑排序的思想（2020）\n此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码\n见本节后的习题。对于有向无环图G中的任意结点uuV，它们之间的关系必然是下列三种之一：\n1）若u是v的祖先，则在调用DFS访问u之前，必然已对v进行了DFS访问，即v的DFS\n结束时间先于u的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在\nDFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。\n2）若u是v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。\n3）若u和v没有路径关系，则u和v在拓扑序列的关系任意。\n于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。\n\n240\n2026年数据结构考研复习指导\n对一个AOV网，若采用下列步骤进行排序，则称之为逆拓扑排序：\n①从AOV网中选择一个没有后继（出度为O）的顶点并输出。\n②从网中删除该顶点和所有以它为终点的有向边。\n③重复①和②直到当前的AOV网为空。\n用拓扑排序算法处理AOV网时，应注意以下问题：\n1）入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶\n点所代表的活动开始或继续。\n命题追踪拓扑排序序列的存在性和唯一性分析（2011、2024）\n2）拓扑排序的结果可能不唯一。不少人误认为AOV网的各顶点为线性序列是拓扑序列唯一\n的充要条件，而它其实只是充分非必要条件。拓扑序列是否唯一的判断条件是在每次输\n出顶点时，检测入度为0的顶点是否唯一，若每次都唯一，则说明拓扑序列唯一。\n3）AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新\n编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般\n的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列：反之则不一定成立。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0645",
        "title": "关键路径",
        "chapter_id": "c06",
        "description": "在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的\n开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。AOE网和AOV网\n值：而AOV网中的边无权值，仅表示顶点之间的前后关系。\nAOE网具有以下两个性质：\n①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；\n②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生，\n在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始：\n也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。\n命题追踪7关键路径的性质（2020）\n在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这\n些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活\n动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的\n路径称为关键路径，而把关键路径上的活动称为关键活动。\n完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这\n是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间\n就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。\n下面给出在寻找关键活动时所用到的几个参量的定义。\n1.事件v的最早发生时间ve(k)\n指从源点v到顶点v的最长路径长度。事件v的最早发生时间决定了所有从v开始的活动\n能够开工的最早时间。可用下面的递推公式来计算：\nve(源点）=0\nvc（k)=Max{ve()+Weight(v,v)}，v为v的任意后继，Weight（v,v)表示<v,v>上的权值\n\n第6章图\n241\n注意\n计算v(）值时，按从前往后的顺序进行，可以在拓扑排序的基础上计算：\n①初始时，令ve[1..n]=0。\n②输出一个入度为O的顶点v时，计算它所有直接后继顶点v的最早发生时间，若ve]+Weight(vy\nvk)>ve[k]，则v[A]=veL]+Weight(v,vk)。以此类推，直至输出全部顶点。\n2.事件V的最迟发生时间v(k)\n指在不推迟整个工程完成的前提下，即保证它的后继事件v在其最迟发生时间v(i)能够发生\n时，该事件最迟必须发生的时间。可用下面的递推公式来计算：\nv(汇点)=v(汇点)\nv(（k)=Min{v()-Weight（vk,v）}，v为v的任意前驱\n注意\n计算v（k值时，按从后往前的顺序进行，可以在逆拓扑排序的基础上计算。增设一个栈以记录拓扑\n序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列。过程如下：\n①初始时，令v[1….n]=ve[n]。\n②栈顶顶点V出栈，计算其所有直接前驱顶点V的最迟发生时间，若vD]-Weight(vk,y)<v[k]，则\nv[k]=vU]-Weight(vk, v)。以此类推，直至输出全部栈中顶点。\n3.活动a;的最早开始时间e(i)\n指该活动弧的起点所表示的事件的最早发生时间。若边<v,v>表示活动a，则有e(i)=v(k)。\n4.活动a的最迟开始时间1(i)\n指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边<v，v>表示活\n动a，则有I(i)=v/()-Weight(vk,v)。\n5.一个活动a;的最迟开始时间I(i)和其最早开始时间e(i)的差额d(i)=I(i)-e(i)\n指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动a可以拖\n延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工\n程的进度，所以称(i)-e(i)=0即 I(i)=e(i)的活动a,是关键活动。\n命题追踪求关键路径的实例（2019、2022）\n求关键路径的算法步骤如下：\n①从源点出发，令ve（源点）=0，按拓扑有序求其余顶点的最早发生时间ve()。\n②从汇点出发，令v(汇点)=ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间v()。\n③根据各顶点的ve()值求所有弧的最早开始时间e()。\n④根据各顶点的v(）值求所有弧的最迟开始时间1()。\n③求AOE网中所有活动的差额d)，找出所有dO=0的活动构成关键路径。\n图6.23所示为求解关键路径的过程，简单说明如下：\n①求ve(）：初始ve(1）=0，在拓扑排序输出顶点过程中，求得v(2）=3，v(3）=2，v(4）=\nmax{v(2)+2,ve(3)+4}=max{5,6}=6，ve(5)=6，ve（6)=max{v(5)+1,ve（4)+2,ve(3)+\n3}=max{7,8,5}=8。\n\n242\n2026年数据结构考研复习指导\n若这是一道选择题，根据上述求ve()的过程就已经能知道关键路径。\n②求v)：初始v(6)=8，在逆拓扑排序出栈过程中，求得v(5)=7，v(4)=6，v(3)=min{v(4)-4,\nv(6)-3}=min{2,5}=2，v(2)=min{v(5)-3,v(4)-2}=min{4,4}=4，v(1)必然为0而无\n须再求。\n③弧的最早开始时间e(0等于该弧的起点的顶点的v)），结果如下表。\n④弧的最迟开始时间（(i)等于该弧的终点的顶点的v)减去该弧持续的时间，结果如下表。\n③根据 I(i)-e(i)=0的关键活动，得到的关键路径为(v,V3,v4,v6)。\nVe()\n0\nv/()\n4\n2\n1=2\na\na3\ne(i)\n0\n0\n3\n)\n2\n=\n(i)\n1\n0\n4\n5\n6\n(i)-e(i)\n1\n0\n3\n0\n图6.23求解关键路径的过程\n命题追踪缩短工期的相关分析（2013）\n对于关键路径，需要注意以下几点：\n1）关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可以通过加\n快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定\n的程度，该关键活动就可能会变成非关键活动。\n2）网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键\n活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动\n才能达到缩短工期的目的。\n各种图算法在采用邻接矩阵或邻接表存储时的时间复杂度如表6.5所示。\n表6.5采用不同存储结构时各种图算法的时间复杂度\nDijkstra\nFloyd\nPrim\nKruskal\nDFS\nBFS\n拓扑排序\n关键路径\n邻接矩阵\nO(n)\nO(n)\nO(n²)\nO(n²)\nO(n²)\nO(n²)\nO(n²)\n邻接表\nO(elogze)\nO(n+e)\nO(n+e)\nO(n+ e)\nO(n+e)",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0634",
        "title": "节的综合应用题03。",
        "chapter_id": "c06",
        "description": "3）广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像深度优先\n搜索那样有回退的情况。因此，它不是一个递归的过程。\n4）一个给定的图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入先后次序不\n同，则生成的邻接表表示也不同。\n通，使得其权值总和达到最小，且不出现回路。\n6）加速某一关键活动不一定能缩短整个工程的工期，因为AOE网中可能存在多条关键路\n径。可能存在称为桥的一种特殊关键活动，它位于所有的关键路径上，只有它加速才会\n缩短整个工期。\n思维拓展\n【网易有道笔试题】求一个无向连通图的割点。割点的定义是，若除去此结点和与其相关的\n边，无向图不再连通，描述算法。\n提示\n要判断一个点是否为割点，最简单直接的方法是，先把这个点和所有与它相关的边从图中去掉，再\n用深搜或广搜来判断剩下的图的连通性，这种方法适合判断给定结点是否为割点；还有一种比较复杂的\n方法可以快速找出所有割点，有兴趣的读者可自行搜索相关资料\n\n第\n章\n查找\n【考纲内容】\n扫扫\n（一）查找的基本概念\n（二）顺序查找法\n（三）分块查找法\n（四）折半查找法\n口\n（五）树形查找\n视频讲解\n二叉搜索树：平衡二叉树：红黑树\n（六）B树及其基本操作、B+树的基本概念\n（七）散列（Hash）表\n（八）查找算法的分析及应用\n【知识框架】\n基本概念：静态查找、动态查找\n顺序查找\n线性结构\n折半查找\n分块查找\n二叉排序树\n查找\n树形结构\n二叉平衡树\n红黑树\nB树、B+树\n厂性能分析\n散列结构一\n散列表\n冲突处理\n厂查找成功\n效率指标一\n一平均查找长度\n查找失败\n【复习提示】\n本章是考研命题的重点。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找\n长度等。对于二叉排序树、二叉平衡树和红黑树，要了解它们的概念、性质和相关操作等。B树\n和B+树是本章的难点。对于B树，考研大纲要求掌握插入、删除和查找的操作过程；对于B+树，\n仅要求了解其基本概念和性质。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的\n处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。\n7.1查找的基本概念\n1）查找。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分\n为两种：一是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    }
]