[
    {
        "id": "kc0211",
        "title": "线性表的定义",
        "chapter_id": "c02",
        "description": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n=0\n时线性表是一个空表。若用L命名线性表，则其一般表示为\nL =(a1, a2,..., ai, ai+1,..., an)\n式中，α是唯一的“第一个”数据元素，也称表头元素；a是唯一的“最后一个”数据元素，也\n称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素\n有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。\n以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。\n\n第2章线性表\n13\n由此，我们得出线性表的特点如下：\n·表中元素的个数有限。\n·表中元素具有逻辑上的顺序性，表中元素有其先后次序。\n·表中元素都是数据元素，每个元素都是单个元素。\n·表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。\n·表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。\n注意\n线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于\n不同层面的概念，因此不要将其混淆。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0212",
        "title": "线性表的基本操作",
        "chapter_id": "c02",
        "description": "一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基\n本操作来实现。线性表的主要操作如下。\n·InitList（&L)：初始化表。构造一个空的线性表。\n·Length（L)：求表长。返回线性表L的长度，即L 中数据元素的个数。\n·LocateElem（L，e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n·GetElem（L，i)：按位查找操作。获取表L中第i个位置的元素的值。\n·ListInsert（&L，i，e）：插入操作。在表L中的第i个位置上插入指定元素e。\n·ListDelete（&L，i，&e）：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。\n·PrintList（L)：输出操作。按前后顺序输出线性表L的所有元素值。\n·Empty(L)：判空操作。若L为空表，则返回true，否则返回 false。\n·DestroyList（&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\n注意\n①基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也不同。②符号“&”表示\nC++语言中的引用调用，在C语言中采用指针也可达到同样的效果。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0221",
        "title": "顺序表的定义",
        "chapter_id": "c02",
        "description": "命题追踪（算法题）顺序表的应用（2010、2011、2018、2020）\n线性表的顺序存储也称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元\n素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在顺序表的起始位置，\n第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素α在顺序表中的位序。因\n此，顺序表的特点是表中元素的逻辑顺序与其存储的物理顺序相同。\n假设顺序表L存储的起始位置为LOC（A），sizeof（ElemType）是每个数据元素所占用存\n储空间的大小，则表L所对应的顺序存储结构如图2.1所示。\n数组下标\n顺序表\n内存地址\nLOC(A)\n0\na\na2\nLOC(A)+sizeof(ElemType)\n1\n：\ni-1\na\nLOC(A)+(i-1)xsizeof(ElemType)\nn-1\nan\nLOC(A)+(n-1)xsizeof(ElemType)\n：\nMaxSize-l\nLOC(A)+(MaxSize-1)xsizeof(ElemType)\n图2.1线性表的顺序存储结构\n每个数据元素的存储位置都和顺序表的起始位置相差一个和该数据元素的位序成正比的常\n数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随\n机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。\n注意\n线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。\n\n第2章线性表\n15\n假定线性表的元素类型为ElemType，则静态分配的顺序表存储结构描述为\n#define MaxSize 50\n//定义线性表的最大长度\ntypedef struct{\nElemType data[MaxSize];\n//顺序表的元素\nint length;\n//顺序表的当前长度\n)SqList;\n//顺序表的类型定义\n维数组可以是静态分配的，也可以是动态分配的。对数组进行静态分配时，因为数组的大\n小和空间事先已经固定，所以一旦空间占满，再加入新数据就会产生溢出，进而导致程序崩溃。\n而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦\n数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到\n扩充数组存储空间的目的，而不需要为线性表一次性地划分所有空间。\n动态分配的顺序表存储结构描述为\n#define InitSize 100\n//表长度的初始定义\ntypedef struct{\nElemType *data;\n//指示动态分配数组的指针\nint MaxSize,length;\n//数组的最大容量和当前个数\n)SeqList;\n//动态分配数组顺序表的类型定义\nC的初始动态分配语句为\nL.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);\nC++的初始动态分配语句为\nL.data=new ElemType[InitSize];\n注意\n动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，\n只是分配的空间大小可以在运行时动态决定。\nVV\nvV\n顺序表的主要优点：①可进行随机访问，即可通过首地址和元素序号可以在0（1）时间内找到\n指定的元素；②存储密度高，每个结点只存储数据元素。顺序表的缺点也很明显：①元素的插入\n和删除需要移动大量的元素，插入操作平均需要移动n/2个元素，删除操作平均需要移动（n-1)/2\n个元素；②顺序存储分配需要一段连续的存储空间，不够灵活。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0222",
        "title": "顺序表上基本操作的实现",
        "chapter_id": "c02",
        "description": "命题追踪顺序表上操作的时间复杂度分析（2023）\n这里仅讨论顺序表的初始化、插入、删除和按值查找，其他基本操作的算法都很简单。\n注意\n在各种操作的实现中（包括严蔚敏老师撰写的教材），往往可以忽略边界条件判断、变量定义、内存\n分配不足等细节，即不要求代码具有可执行性，而重点在于算法的思想，\n1.顺序表的初始化\n静态分配和动态分配的顺序表的初始化操作是不同的。静态分配在声明一个顺序表时，就已\n为其分配了数组空间，因此初始化时只需将顺序表的当前长度设为0。\n//SqListL;\n1//声明一个顺序表\nvoid InitList(SqList &L){\nL.length=0;\n//顺序表初始长度为0\n\n16\n2026年数据结构考研复习指导\n动态分配的初始化为顺序表分配一个预定义大小的数组空间，并将顺序表的当前长度设为0。\nvoid InitList(SeqList &L)(\nL.data=（ElemType*)malloc（InitSize*sizeof（ElemType));//分配存储空间\nL.length=0;\n//顺序表初始长度为0\nL.MaxSize=InitSize;\n//初始存储容量\n2.插入操作\n在顺序表L的第i（1<=i<=L.length+1）个位置插入新元素é。若i的输入不合法，则\n返回false，表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾\n出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。\nbool ListInsert(SqList &L,int i,ElemType e)(\nif(i<1l|i>L.length+1)\n//判断i的范围是否有效\nreturn false;\nif(L.length>=MaxSize)\n//当前存储空间已满，不能插入\nreturn false;\nfor(int j=L.length;j>=i;j--)\n//将第i个元素及之后的元素后移\nL.data[j]=L.data[j-1];\n//在位置i处放入é\nL.data[i-1]=e;\nL.length++;\n//线性表长度加1\nreturn true;\n注意\n区别顺序表的位序和数组下标。为何判断插入位置是否合法时if语句中用1ength+1，而移动元素的\nfor语句中只用length？\n最好情况：在表尾插入（i=n+1），元素后移语句将不执行，时间复杂度为O(1)。\n最坏情况：在表头插入（i=1)，元素后移语句将执行n次，时间复杂度为O(n)。\n平均情况：假设p（p;=1/(n+1)）是在第i个位置上插入一个结点的概率，则在长度为n的\n线性表中插入一个结点时，所需移动结点的平均次数为\n1\n1+1\n1 n(n+1)\nn\np（n-i+1）=\n（n-i+1）=\n(n-i+1)=\nn+1\n=n+1\nn+1\n2\n2\ni=l\n因此，顺序表插入算法的平均时间复杂度为O(n)。\n3．删除操作\n删除顺序表L中第i（1<=i<=L.length）个位置的元素，用引用变量e返回。若i的输\n入不合法，则返回false：否则，将被删元素赋给引用变量e，并将第i+1个元素及其后的所有\n元素依次往前移动一个位置，返回true。\nbool ListDelete(SqList &L,int i,ElemType &e)(\nif(i<llli>L.length)\n//判断i的范围是否有效\nreturn false;\ne=L.data[i-1];\n/将被删除的元素赋值给e\nfor（int j=i;j<L.length;j++)\n/将第i个位置后的元素前移\nL.data[j-1]=L.data[j];\nL.length--;\n//线性表长度减1\nreturn true;\n最好情况：删除表尾元素（i=n），无须移动元素，时间复杂度为O（1)。\n\n第2章线性\n表\n17\n最坏情况：删除表头元素（i=1)，需移动除表头元素外的所有元素，时间复杂度为O(n)。\n平均情况：假设p;（p,=1/n）是删除第i个位置上结点的概率，则在长度为n的线性表中删\n除一个结点时，所需移动结点的平均次数为\n1 n(n-1) n-1\np;(n-i)=\n-（n-i）：\n（n-i)\n=1n\nn=1\nn\n2\ni=l\n因此，顺序表删除算法的平均时间复杂度为O（n)。\n可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插\n入和删除元素的位置。图2.2所示为一个顺序表在进行插入和删除操作前、后的状态，以及其数\n据元素在存储空间中的位置变化和表长变化。在图2.2（a)中，将第4个至第7个元素从后往前依\n次后移一个位置，在图2.2（b）中，将第5个至第7个元素从前往后依次前移一个位置。\n0\n0\n6\ndata\n25\n3457\n0963\ndata\n25345716480963\n删除16\ndata\n57\n50\ndata\n(a)插入新元素示例\n(b）删除表中元素示例\n图2.2顺序表的插入和删除\n4.按值查找（顺序查找）\n在顺序表L中查找第一个元素值等于é的元素，并返回其位序。\nint LocateElem(SqList L,ElemType e){\ninti;\nfor（i=0;i<L.length;i++)\nif(L.data[i]==e)\nreturni+1;\n//下标为i的元素值等于e，返回其位序i+1\nreturn0;\n//退出循环，说明查找失败\n最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为0（1)。\n最坏情况：查找的元素在表尾（或不存在）时，需要比较n次，时间复杂度为O(n)。\n则在长度为n的线性表中查找值为e的元素所需比较的平均次数为\n\"1\n1 n(n+1)\n）n+1\n=n\nn\n2\n因此，顺序表按值查找算法的平均时间复杂度为O(n)。\n顺序表的按序号查找非常简单，即直接根据数组下标访问数组元素，其时间复杂度为O(1)。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0222",
        "title": ".",
        "chapter_id": "c02",
        "description": "",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0233",
        "title": ".3.4.4.5来手动模拟算法的执行过程，在模",
        "chapter_id": "c02",
        "description": "拟过程中要标注i和j所指示的元素。\n思考：若将本题中的有序表改为无序表，你能想到时间复杂度为O（n)的方法吗？\n（提示：使用散列表。）\n06.【解答】\n算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看\n哪个表还有剩余，将剩下的部分加到新的顺序表后面。\n本题代码如下：\nbool Merge(SeqList A,SeqList B,SeqList &C){\n/将有序顺序表A与B合并为一个新的有序顺序表C\nif(A.length+B.length>C.maxSize)\n//大于顺序表的最大长度\nreturn false;\nint i=0，j=0,k=0;\nwhile(i<A.length&&j<B.length)(\n//循环，两两比较，小者存入结果表\nif(A.data[i]<=B.data[j])\nC.data[k++]=A.data[i++];\nelse\nC.data[k++]=B.data[j++];\nwhile(i<A.length)\n//还剩一个没有比较完的顺序表\nC.data[k++]=A.data[i++];\nwhile(j<B.length)\nC.data[k++]=B.data[j++];\nC.length=k;\nreturntrue;\n注意\n本算法的方法非常典型，需牢固掌握。\n07.【解答】\n算法思想：首先将数组A[m+n]中的全部元素(a,a2,a3,…,am,b,b2,b3,.….,bn)原地逆置为\n(bn,bn-1,b-2,….,b1,amam-1,am-2,,a)，然后对前n个元素和后m个元素分别使用逆置算法，\n即可得到（b，b2,b3,.…，bm,a,a2,a3,.…,am），从而实现顺序表的位置互换。\n本题代码如下：\ntypedef int DataType;\nvoid Reverse(DataType A[],int left,int right,int arraySize){\n//逆转（aleft,aleft+l,aleft+2,\",aright)为(aright,aright-l,\",aleft)\nif(left>=rightllright>=arraySize)\nreturn;\nint mid=(left+right)/2;\nfor（int i=0;i<=mid-left;i++){\nDataType temp=A[left+i];\nA[left+i]=A[right-i];\nA[right-i]=temp;\nvoid Exchange(DataType A[],int m,int n,int arraySize)\n*数组A[m+n]中，从0到m-1存放顺序表（a1，a2，a3，\"，am），从m到m+n-1存放顺序表\n\n第2章线性\n表\n25\n(b1，b2，b3，…，bn），算法将这两个表的位置互换*/\nReverse(A,0,m+n-1,arraySize);\nReverse(A,0,n-l,arraySize);\nReverse(A,n,m+n-l,arraySize);\n08.【解答】\n算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最\n少的时间在表中查找数值为x的元素”，这里应使用折半查找法。\n本题代码如下：\nvoid SearchExchangeInsert(ElemType A[],ElemType x)(\nint low=0,high=n-1,mid;\n//low和high指向顺序表下界和上界的下标\nwhile(low<=high){\nmid=(1ow+high)/2;\n/找中间位置\nif(A[mid]==x) break;\n/找到x，退出while循环\nelse if(A[mid]<x)\nlow=mid+1；//到中点mid的右半部去查\nelse high=mid-1;\n//到中点mid的左半部去查\n/下面两个if语句只会执行\n个\nif（A[mid]==x&&mid!=n-l）{\n//若最后一个元素与×相等，则不存在与其后\n继交换的操作\n+]+]]]\nif(low>high){\n//查找失败，插入数据元素x\nfor（i=n-l;i>high;i--）A[i+l]=A[i];\n//后移元素\nA[i+1]=x;\n/插入x\n//结束插入\n本题的算法也可写成三个函数：查找函数、交换后继函数与插入函数。写成三个函数的优点\n是逻辑清晰、易读。\n09.【解析】\n1）算法的基本设计思想。\n使用三个下标变量从小到大遍历数组。当三个下标变量指向的元素相等时，输出并向前推进\n指针，否则仅移动小于最大元素的下标变量，直到某个下标变量移出数组范围，即可停止。\n2）算法的实现。\nvoid samekey（int A[],int B[],int C[],int n）(\nint i=0,j=0,k=0;\n//定义三个工作指针\nwhile(i<n&&j<n&&k<n){\n//相同则输出，并集体后移\nif(A[i]==B[j]&&B[j]==C[k]）{\nprintf(\"d\\n\",A[i]);\ni++;j++;k++;\n)elset\nintmaxNum=max(A[i],max（B[j],C[k])）;\nif(A[i]<maxNum)i++;\nif(B[j]<maxNum)j++;\nif(C[k]<maxNum)k++;\n3）每个指针移动的次数不超过n次，且每次循环至少有一个指针后移，所以时间复杂度为\nO(n)，算法只用到了常数个变量，空间复杂度为O(1)。\n10.【解答】\n1）算法的基本设计思想：\n\n26\n2026年数据结构考研复习指导\n可将问题视为把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个\n元素)，先将a逆置得到ab，再将b逆置得到ab-，最后将整个ab逆置得到（ab-)-=ba。设\nReverse函数执行将数组逆置的操作，对abcdefgh向左循环移动3（p=3）个位置的过程如下：\nReverse(0,p-1)得到 cbadefgh;\nReverse（p，n-1)得到 cbahgfed;\nReverse(0,n-1)得到 defghabc。\n注：在Reverse中，两个参数分别表示数组中待转换元素的始末位置。\n2）使用C语言描述算法如下：\nvoid Reverse（int R[],int from,int to）{\nint i,temp;\nfor（i=0;i<（to-from+1)/2;i++)\n{temp=R[from+i];R[from+i]=R[to-i];R[to-i]=temp;}\nvoid Converse（int R[],int n,int p)(\nReverse(R,0,p-1);\nReverse(R,p,n-1);\nReverse(R,0,n-1);\n3）上述算法中三个Reverse函数的时间复杂度分别为 O(p/2)、O(n-p)/2)和O(n/2)，故所\n设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。\n【另解】借助辅助数组来实现。算法思想：创建大小为p的辅助数组S，将R中前p个整数\n依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的\n后续单元。时间复杂度为O(n)，空间复杂度为O(p)。\n11.【解答】\n1）算法的基本设计思想如下。\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n①若a=b，则a或b为所求中位数，算法结束。\n②若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的\n长度相等。\n③若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的\n长度相等。\n在保留的两个升序序列中，重复过程①、②、③，直到两个序列中均只含一个元素时为止，\n较小者为所求的中位数。\n2）本题代码如下：\nint M Search（int A[],int B[],intn)(\nint s1,dl,m1,s2,d2,m2;\ns1=0;d1=n-1;\ns2=0;d2=n-1;\nwhile(s1!=dl||s2!=d2）{\nm1=（s1+d1）/2;\nm2=（s2+d2)/2;\nif(A[m1]==B[m2])\nreturn A[ml];\n/满足条件①\nif(A[m1]<B[m2]){\n/满足条件②\nif（(s1+d1）%2==0）{\n1若元素个数为奇数\ns1=ml;\n川舍弃A中间点以前的部分，且保留中间点\nd2=m2;\n川舍弃B中间点以后的部分，且保留中间点\n\n第2章线性\n表\n27\nelser\n1/元素个数为偶数\ns1=m1+1;\n//舍弃A的前半部分\nd2=m2;\n//舍弃B的后半部分\nelse{\n//满足条件③\nif（（s1+d1）2==0）{\n1//若元素个数为奇数\nd1=ml;\n/舍弃A中间点以后的部分，且保留中间点\ns2=m2;\n//舍弃B中间点以前的部分，且保留中间点\nelsel\n1//元素个数为偶数\nd1=ml;\n//舍弃A的后半部分\ns2=m2+1;\n1//舍弃B的前半部分\nreturn A[s1]<B[s2]? A[s1]:B[s2];\n3）算法的时间复杂度为O（log2n)，空间复杂度为O（1)。\n【另解】对两个长度为n的升序序列A和B中的元素按从小到大的顺序依次访问，这里访问\n的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为0(1)。按\n照上述规则访问第n个元素时，这个元素为两个序列A和B的中位数。\n12.【解答】\n1）算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元\n素的元素Num。然后重新计数，确认Num是否是主元素。\n算法可分为以下两步：\n①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到\nc中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计\n数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一\n轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。\n②判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大\n于n/2，则为主元素；否则，序列中不存在主元素。\n2）算法实现如下：\nint Majority(int A[],int n)(\nint i,c,count=l;\nllc用来保存候选主元素，count用来计数\nC=A[0];\n//设置A[0]为候选主元素\nfor(i=1;i<n;i++)\n//查找候选主元素\nif(A[i]==c)\ncount++;\n//对A中的候选主元素计数\nelse\nif(count>0)\n1//处理不是候选主元素的情况\ncount--;\nelsel\n//更换候选主元素，重新计数\nC=A[i];\ncount=1;\nif(count>0)\nfor（i=count=0;i<n;i++)\n//统计候选主元素的实际出现次数\nif(A[i]==c)\ncount++;\nif(count>n/2) return c;\n//确认候选主元素\n\n28\n2026年数据结构考研复习指导\nelse return -1;\n1/不存在主元素\n3）实现的程序的时间复杂度为O(n)，空间复杂度为O(1)。\n说明\n本题若采用先排好序再统计的方法【时间复杂度为O（nlog2n)]，则只要解答正确，最高可拿11分。\n即便是写出O（n²）的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得\n不偿失的。本算法的方法非常典型，需牢固掌握\n13.【解答】\n1）算法的基本设计思想：\n要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用\n来记录A中是否出现了1~n中的正整数，B[0]对应正整数1，B[n-1]对应正整数n，初始化B\n中全部为0。A中含有n个整数，因此可能返回的值是1~n+1，当A中n个数恰好为1~n时返回\nn+1。当数组A中出现了小于或等于0或大于n的值时，会导致1~n中出现空余位置，返回结果\n必然在1~n中，因此对于A中出现了小于或等于0或大于n的值，可以不采取任何操作。\n经过以上分析可以得出算法流程：从A[0]开始遍历A，若0<A[i]<=n，则令B[A[i]-1]=1；\n否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，\n返回i+1即为结果，此时说明A中未出现的最小正整数在1和n之间。若B[i]全部不为0，返\n回i+1（跳出循环时i=n，i+1等于n+1），此时说明A中未出现的最小正整数是n+1。\n2）算法实现：\nint findMissMin(int A[],int n)\nint i,*B;\n/标记数组\nB=(int *)malloc(sizeof(int）*n);//分配空间\nmemset(B,0,sizeof(int)*n);\n/赋初值为0\nfor(i=0;i<n;i++)\nif(A[i]>0&&A[i]<=n)\n/若A[i]的值介于1~n，则标记数组B\nB[A[i]-1]=1;\nfor(i=0;i<n;i++)\n/扫描数组B，找到目标值\nif （B[i]==0）break;\nreturn i+l;\n/返回结果\n3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为O（1)量级，因此时间复\n杂度为O(n)。空间复杂度：额外分配了B[n］，空间复杂度为O(n)。\n14.【解答】\n分析。由D=a-b+b-c+c-a≥0有如下结论。\n①当a=b=c时，距离最小。\n②其余情况。不失一般性，假设a≤b≤c，观察下面的数轴：\nq-D=17\nL2=b-\nD-=\n=7+7+7=0<|-0|+|-q|+1q-=q\n由D的表达式可知，事实上决定D大小的关键是a和c之间的距离，于是问题就可以简化\n\n第2章线性表\n29\n为每次固定c找一个a，使得L=c-a最小。\n1）算法的基本设计思想：\n①使用Dmin记录所有已处理的三元组的最小距离，初值为一个足够大的整数。\n②集合S、S和S分别保存在数组A、B、C中。数组的下标变量i=j=k=0，当i<IS小\nj<IS|且k<[S;[时（IS|表示集合S中的元素个数），循环执行下面的a）～c)。\na）计算(A[i],BU],C[k])的距离D：（计算D)\nb）若D<Dmin，则Dmin=D；（更新D)\nc）将A[i]、BU]、C[K]中的最小值的下标+1;\n（对照分析：最小值为a，最大值为c，这里c\n不变而更新a，试图寻找更小的距离D）\n③输出 Dmin，结束。\n2）算法实现：\n#define INT_MAX Ox7fffffff\nintabs_（inta）{//计算绝对值\nif(a<o)return-a;\nelse return a;\nboolxls_min（inta，intb，intc）（//a是否是三个数中的最小值\nif（a<=b&&a<=c) return true;\nreturn false;\n/D_min用于记录三元组的最小距离，初值赋为INTMAX\nint i=0,j=0,k=0,D_min=INT_MAX,D;\nwhile(i<n&&j<m&&k<p&&D_min>0){\nD=abs_(A[i]-B[j])+abs_(B[j]-C[k]）+abs_(C[k]-A[i]);//计算D\nif（D<D_min)D_min=D;\n//更新D\nif(xls_min(A[i],B[j],C[k]）)\n//更新a\ni++;\nelse if(xls_min(B[j],C[k],A[i]))\nj++;\nelse k++;\nreturn D_min;\n3）设n=(ISi|+IS|+ISsl)，时间复杂度为O(n)，空间复杂度为O(1)。\n2.3线性表的链式表示\n顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任一元素，但插入和\n删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑\n上相邻的元素在物理位置上也相邻，它通过“链”建立元素之间的逻辑关系，因此插入和删除操作\n不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。\n公众号：小兔网盘免费分享无水印PDF",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0231",
        "title": "单链表的定义",
        "chapter_id": "c02",
        "description": "命题追踪单链表的应用（2009、2012、2013、2015、2016、2019）\n线性表的链式存储也称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元\n素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存\n放一个指向其后继的指针。单链表结点结构如图2.3所示，其中data为数据域，存放数据元素；\n\n30\n2026年数据结构考研复习指导\nnext为指针域，存放其后继结点的地址。\ndata\nnext\n图2.3单链表结点结构\n单链表中结点类型的描述如下：\ntypedef struct LNode\n//定义单链表结点类型\nElemType data;\n//数据域\nstruct LNode *next;\n//指针域\n)LNode,*LinkList;\n利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存\n储空间的缺点。单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能\n直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。\n通常用头指针L（或head等）来标识一个单链表，指出链表的起始地址，头指针为NULL\n时表示一个空表。此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称\n为头结点。头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，\n头指针工指向头结点，如图2.4(a)所示。单链表不带头结点时，头指针L指向第一个数据结点，\n如图2.4(b)所示。表尾结点的指针域为NULL（用“^”表示）。\n(a)带表头结点的单链表\n(b)不带表头结点的单链表\n图2.4带头结点和不带头结点的单链表\n头结点和头指针的关系：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结\n点是带头结点的链表中的第一个结点，结点内通常不存储信息。\n引入头结点后，可以带来两个优点：\n①第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作\n和在表的其他位置上的操作一致，无须进行特殊处理。\n②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），\n因此空表和非空表的处理也就得到了统一。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0232",
        "title": "单链表上基本操作的实现",
        "chapter_id": "c02",
        "description": "带头结点单链表的操作代码书写较为方便，如无特殊说明，本节均默认链表带头结点。\n1.单链表的初始化\n带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要\n创建一个头结点，并让头指针指向头结点，头结点的next域初始化为NULL。\nbool InitList（LinkList &L)(\n//带头结点的单链表的初始化\nL=(LNode*)malloc(sizeof(LNode));\n//创建头结点?\nL->next=NULL;\n/头结点之后暂时还没有元素结点\nreturn true;\n不带头结点的单链表初始化时，只需将头指针L初始化为NULL。\nbool InitList(LinkList &L)(\n//不带头结点的单链表的初始化\n①执行s=（LNode*）malloc（sizeof（LNode））的作用是由系统生成一个LNode型的结点，并将该结点的起始位置赋给指针变量s。\n\n第2章线性\n表\n31\nL=NULL;\nreturn true;\n注意\n设p为指向链表结点的结构体指针，则*p表示结点本身，因此可用p->data或（*p）.data访问*p\n这个结点的数据域，二者完全等价。成员运算符（.）左边是一个普通的结构体变量，而指向运算符（一>）\n左边是一个结构体指针。通过（*p）.next可以得到指向下一个结点的指针，因此（*（*p）.next）.data\n就是下一个结点中存放的数据，或者直接用p->next->data。\n2.求表长操作\n求表长操作是计算单链表中数据结点的个数，需要从第一个结点开始依次访问表中每个结\n点，为此需设置一个计数变量，每访问一个结点，其值加1，直到访问到空结点为止。\nint Length(LinkList L){\nint len=0;\n//计数变量，初始为0\nLNode *p=L;\nwhile(p->next!=NULL){\np=p->next;\nlen++;\n//每访问一个结点，计数加1\nreturn len;\n求表长操作的时间复杂度为O(n)。另需注意的是，因为单链表的长度是不包括头结点的，因\n此不带头结点和带头结点的单链表在求表长操作上会略有不同。\n3.按序号查找结点\n从单链表的第一个结点开始，沿着next域从前往后依次搜索，直到找到第i个结点为止，\n则返回该结点的指针：若i大于单链表的表长，则返回NULL。\nLNode *GetElem(LinkList L,int i）(\nLNode *p=L;\n//指针p指向当前扫描到的结点\nint j=0;\n//记录当前结点的位序，头结点是第0个结点\nwhile(p!=NULL&&j<i）\n//循环找到第i个结点\np=p->next;\nj++;\nreturn\n!d\n//返回第i个结点的指针或NULL\n按序号查找操作的时间复杂度为O(n)。\n4.按值查找表结点\n从单链表的第一个结点开始，从前往后依次比较表中各结点的数据域，若某结点的data域\n等于给定值e，则返回该结点的指针：若整个单链表中没有这样的结点，则返回NULL。\nLNode *LocateElem(LinkList L,ElemType e){\nLNode *p=L->next;\np=p->next;\nreturn p;\n/找到后返回该结点指针，否则返回NULL\n按值查找操作的时间复杂度为O(n)。\n5.插入结点操作\n插入结点操作将值为×的新结点插入到单链表的第i个位置。先检查插入位置的合法性，然\n\n32\n2026年数据结构考研复习指导\n后找到待插入位置的前驱，即第i-1个结点，再在其后插入。其操作过程如图2.5所示。\n图2.5单链表的插入操作\n命题追踪单链表插入操作的过程（2016、2024）\n首先查找第i-1个结点，假设第i-1个结点为*p，然后令新结点*s的指针域指向*p的后\n继，再令结点*p的指针域指向新插入的结点*s。\nbool ListInsert(LinkList &L,int i,ElemType e){\nLNode *p=L;\n//指针p指向当前扫描到的结点\nint j=0;\n/记录当前结点的位序，头结点是第0个结点\nwhile（p!=NULL&&j<i-1){\n//循环找到第i-1个结点\np=p->next;\nj++;\nif(p==NULL)\n//i值不合法\nreturn false;\nLNode *s=(LNode*)malloc(sizeof(LNode));\ns->data=e;\ns->next=p->next;\n//图2.5中操作步骤①\np->next=s;\n//图2.5中操作步骤②\nreturn true;\n插入时，①和②的顺序不能颠倒，否则，先执行p->next=s后，指向其原后继的指针就不\n存在了，再执行s->next=p->next时，相当于执行了s->next=s，显然有误。本算法主要的\n时间开销在于查找第i-1个元素，时间复杂度为O（n)。若在指定结点后插入新结点，则时间复杂\n度仅为O(1)。需注意的是，当链表不带头结点时，需要判断插入位置i是否为1，若是，则要做\n特殊处理，将头指针L指向新的首结点。当链表带头结点时，插入位置i为1时不用做特殊处理。\n扩展：对某一结点进行前插操作。\n前插操作是指在某结点的前面插入一个新结点，后插操作的定义刚好与之相反。在单链表插\n入算法中，通常都采用后插操作。以上面的算法为例，先找到第i-1个结点，即插入结点的前驱，\n再对其执行后插操作。由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头\n结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为*s，将*s插入到*p\n的前面。我们仍然将*s插入到*p的后面，然后将p->data与s->data交换，这样做既满足逻\n辑关系，又能使得时间复杂度为O(1)。该方法的主要代码片段如下：\nx-dxu-\n//修改指针域，不能颠倒\np->next=s;\ntemp=p->data;\nI交换数据域部分\np->data=s->data;\ns->data=temp;\n6.删除结点操作\n删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1\n个结点，即被删结点的前驱，再删除第i个结点。其操作过程如图2.6所示。\n\n第2章\n线\n性\n未\n33\n图2.6单链表结点的删除\n假设结点*p为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改*p\n的指针域，将*p的指针域next指向*g的下一结点，然后释放*g的存储空间。\nbool ListDelete（LinkList &L,int i,ElemType &e){\nLNode *p=L;\n/指针p指向当前扫描到的结点\nint j=0;\n//记录当前结点的位序，头结点是第0个结点\n(>x\n//循环找到第i-1个结点\np=p->next;\nj++;\nif(p->next==NULLI1j>i-1)\n//i值不合法\nfalse;\nreturn\nLNode *q=p->next;\nl/令q指向被删除结点\ne=q->data;\n//用e返回元素的值\nxu-b=xu<-\n//将*q结点从链中“断开”\nfree(q);\n/释放结点的存储空间?\nreturn\ntrue;\n同插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为O(n)。当链表不带\n头结点时，需要判断被删结点是否为首结点，若是，则要做特殊处理，将头指针L指向新的首结\n点。当链表带头结点时，删除首结点和删除其他结点的操作是相同的。\n扩展：删除结点*p。\n要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱，然后执行删\n除操作。其实，删除结点*p的操作可用删除*p的后继来实现，实质就是将其后继的值赋予其自\n身，然后再删除后继，也能使得时间复杂度为O(1)。该方法的主要代码片段如下：\nq=p->next;\n//令g指向*p的后继结点\np->data=p->next->data;\n//用后继结点的数据域覆盖\nxu<-b=xu<-\n//将*g结点从链中“断开”\nfree（q);\n//释放后继结点的存储空间\n7.采用头插法建立单链表\n该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将\n新结点插入到当前链表的表头，即头结点之后，如图2.7所示。算法实现如下：\n每次将s所指的结点插在前端\n图2.7采用头插法建立单链表\n①执行free（q）的作用是由系统回收一个LNode型结点，回收后的空问可供再次生成结点时用。\n\n34\n2026年数据结构考研复习指导\nLinkListList_HeadInsert（LinkList&L）//逆向建立单链表\nLNode *s; int x;\n//设元素类型为整型\nL=(LNode*)malloc(sizeof(LNode)）;\n//创建头结点\nL->next=NULL;\n/初始为空链表\nscanf(\"%d\",&x）;\n//输入结点的值\nwhi1e(x!=9999)(\n//输入9999表示结束\ns=（LNode*）malloc（sizeof（LNode））;//创建新结点\ns->data=x;\ns->next=L->next;\nL->next=s;\n//将新结点插入表中，L为头指针\nscanf（\"d\",&x）;\nreturn L;\n采用头插法建立单链表时，读入数据的顺序与生成的链表中元素的顺序是相反的，可用来实\n现链表的逆置。每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。\n思考\n若单链表不带头结点，则上述代码中哪些地方需要修改？①\n8.采用尾插法建立单链表\n头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。\n若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加\n一个尾指针r，使其始终指向当前链表的尾结点，如图2.8所示。算法实现如下：\n每次将s所指的结点插在末端\n图2.8采用尾插法建立单链表\nLinkList List_TailInsert（LinkList&L）//正向建立单链表\nint x;\n//设元素类型为整型\nL=（LNode*)malloc(sizeof（LNode)）;\n//创建头结点\nLNode *s,*r=L;\n//r为表尾指针\nscanf(\"d\"，&x）;\n/输入结点的值\nwhile(x!=9999){\n//输入9999表示结束\ns=（LNode*)malloc（sizeof(LNode));\ns->data=x;\nr->next=s;\nr=s;\n//r指向新的表尾结点\nscanf(\"%d\",&x）;\nr->next=NULL;\n//尾结点指针置空\nreturn L;\n因为附设了一个指向表尾结点的指针，所以时间复杂度和头插法的相同。\n①主要修改之处：因为在头部插入新结点，每次插入新结点后，都需要将它的地址赋值给头指针L。\n\n第2章线性\n表\n35\n注意\n单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通\n过画图的方法理清算法的思路，然后进行算法的编写。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0233",
        "title": "双链表",
        "chapter_id": "c02",
        "description": "单链表结点中只有一个指向其后继的指针，使得单链表只能从前往后依次遍历。要访问\n某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为O(n)。\n为了克服单链表的这个缺点，引入了双链表，双链表结点中有两个指针prior和next，分\n别指向其直接前驱和直接后继，如图2.9所示。表头结点的prior域和尾结点的next域都\n是NULL。\n图2.9双链表示意图\n双链表中结点类型的描述如下：\ntypedef struct DNodel\n//定义双链表结点类型\nElemType data;\n//数据域\nstruct DNode *prior,*next;\n//前驱和后继指针\n)DNode，*DLinklist;\n双链表在单链表结点中增加了一个指向其前驱的指针prior，因此双链表的按值查找和按位\n查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这\n是因为“链”变化时也需要对指针prior做出修改，其关键是保证在修改的过程中不断链。此外，\n双链表可以很方便地找到当前结点的前驱，因此，插入、删除操作的时间复杂度仅为O(1)。\n1.双链表的插入操作\n在双链表中p所指的结点之后插入结点*s，其指针的变化过程如图2.10所示。\n公众号：小兔网盘\n图2.10双链表插入结点过程\n免费网课+无水印PDF\n命题追踪双链表中插入操作的实现（2023）\n插入操作的代码片段如下：\nxau<-d=xau<-s ①\n//将结点*s插入到结点*p之后\no-x-\n③ s->prior=p;\n④ p->next=s;\n上述代码的语句顺序不是唯一的，但也不是任意的，①步必须在④步之前，否则*p的后继结\n点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求\n在结点*p之前插入结点*s，请读者思考具体的操作步骤。\n\n36\n2026年数据结构考研复习指导\n2.双链表的删除操作\n删除双链表中结点*p的后继结点*q，其指针的变化过程如图2.11所示。\n②\n图2.11双链表删除结点过程\n命题追踪双链表中删除操作的实现（2016）\n删除操作的代码片段如下：\np->next=q->next;\n//图2.11中步骤①\nd=rotd<-xu<-b\n//图2.11中步骤②\nfree(q);\n//释放结点空间\n若问题改成要求删除结点*g的前驱结点*p，请读者思考具体的操作步骤。\n在建立双链表的操作中，也可采用如同单链表的头插法和尾插法，但在操作上需要注意指针\n的变化和单链表有所不同。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0234",
        "title": "循环链表",
        "chapter_id": "c02",
        "description": "1.循环单链表\n循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，\n从而整个链表形成一个环，如图2.12所示。\n在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，\n循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针L。\n图2.12循环单链表\n命题追踪循环单链表中删除首元素的操作（2021）\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是，若操作是在表尾进行，则\n执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，\n所以在任何位置上的插入和删除操作都是等价的，而无须判断是否是表尾。\n在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意\n个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。\n其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，\nr->next即头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度。\n2.循环双链表\n由循环单链表的定义不难推出循环双链表。不同的是，在循环双链表中，头结点的prior\n指针还要指向表尾结点，如图2.13所示。当某结点*p为尾结点时，p->next==L；当循环双链\n表为空表时，其头结点的prior域和next域都等于L。\n\n第2章线性\n表\n37\n图2.13循环双链表",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0235",
        "title": "静态链表",
        "chapter_id": "c02",
        "description": "静态链表是用数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，\n与前面所讲的链表中的指针不同的是，这里的指针是结点在数组中的相对地址（数组下标），也\n称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。\n静态链表和单链表的对应关系如图2.14所示。\n2\n6\na\nd\n(a）静态链表示例\n(b)静态链表对应的单链表\n图2.14静态链表存储示意图\n静态链表结构类型的描述如下：\n#define MaxSize 50\n//静态链表的最大长度\ntypedef struct{\n//静态链表结构类型的定义\nElemType data;\n//存储数据元素\nint next;\n//下一个元素的数组下标\n)SLinkList[MaxSize];\n静态链表以next==-1作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，\n只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些\n不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    },
    {
        "id": "kc0236",
        "title": "顺序表和链表的比较",
        "chapter_id": "c02",
        "description": "1.存取（读/写）方式\n顺序表既可以顺序存取，也可以随机存取，链表只能从表头开始依次顺序存取。例如在第i\n个位置上执行存取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。\n2.逻辑结构与物理结构\n采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻\n辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。\n3.查找、插入和删除操作\n对于按值查找，顺序表无序时，两者的时间复杂度均为O（n)：顺序表有序时，可采用折半查\n找，此时的时间复杂度为O(log2n)。对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，\n而链表的平均时间复杂度为O(n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链\n表的插入、删除操作，只需修改相关结点的指针域即可。\n\n38\n2026年数据结构考研复习指导\n4.空间分配\n顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出\n现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量\n闲置：预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元\n素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存\n储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。此外，链表\n的每个结点都带有指针域，因此存储密度不够大。\n在实际中应该怎样选取存储结构呢？\n1.基于存储的考虑\n难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链\n表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n2.基于运算的考虑\n在顺序表中按序号访问α,的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，\n因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且\n表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操\n作主要是比较操作，从这个角度考虑显然后者优于前者。\n3.基于环境的考虑\n顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前\n者实现较为简单，这也是用户考虑的一个因素。\n总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性\n表选择顺序存储，而频繁进行插入、删除操作的线性表（动态性较强）宜选择链式存储。\n注意\n只有熟练掌握顺序存储和链式存储，才能深刻理解它们的优缺点。",
        "related_points": [
            {
                "id": "string",
                "relation_type": "string"
            }
        ],
        "questions": [
            "question_id"
        ]
    }
]