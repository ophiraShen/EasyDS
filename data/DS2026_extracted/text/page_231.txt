第6章图
219
indegree=outdegree=0;
for(m=0;m<G.numVertices;m++)
/计算顶点的出度
outdegree+=G.Edge[k][m];
for(m=0;m<G.numVertices;m++)
//计算顶点的入度
indegree+=G.Edge[m][k];
if(outdegree>indegree)(
printf("c",G.VerticesList[k]);
count++;
return count;
//返回K顶点的个数
6.3
图的遍历
图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点
访问一次，且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊
的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。
图的遍历比树的遍历要复杂得多，因为图的任意一个顶点都可能和其余的顶点相邻接，所
以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在
遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组visited[]来标记
顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。
6.3.1广度优先搜索
广度优先搜索（Breadth-First-Search，BFS）类似于树的层序遍历。基本思想是：首先访问起
始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w，W2,，w，然后依次访问
Wi，W2,"，w,的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访
问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选
图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。
Dijkstra单源最短路径算法和Prim最小生成树算法也应用了类似的思想。
换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和v有路径相通
且路径长度为1，2，·的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问
批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层
的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。
广度优先搜索算法的伪代码如下：
bool visited[MAx_VERTEX_NUM];
/访问标记数组
void BFsTraverse(Graph G)(
//对图G进行广度优先遍历
for（i=0;i<G.vexnum;++i)
visited[i]=FALSE;
/访问标记数组初始化
InitQueue(Q);
//初始化辅助队列Q
for（i=0;i<G.vexnum;++i)
1//从0号顶点开始遍历
if(!visited[i])
//对每个连通分量调用一次BFS（）
BFS(G,i);
//若v未访问过，从v;开始调用BFS（）
用邻接表实现广度优先搜索的算法如下：
void BFS(ALGraph G,int i){
