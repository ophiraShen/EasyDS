340
2026年数据结构考研复习指导
下面是直接插入排序的代码，其中再次用到了前面提到的“哨兵”（作用相同）。
void InsertSort(ElemType A[],int n)(
int i,j;
for(i=2;i<=n;i++)
//依次将A[2]~A[n]插入前面已排序序列
if(A[i]<A[i-1]){
若A[i]关键码小于其前驱，将A[i]插入有序表
A[O]=A[i];
/复制为哨兵，A[0]不存放元素
for（j=i-1;A[0]<A[j];--j)//从后往前查找待插入位置
A[j+1]=A[j];
//向后挪位
A[j+1]=A[0];
/复制到插入位置
假定初始序列为49，38.65.97，76.13,27.49，初始时49可以视为一个已排好序的子序列，
按照上述算法进行直接插入排序的过程如图8.1所示，括号内是已排好序的子序列。
[初始关键字]：
(49)
65
97
76
13
27
49
i=2:
(38)
49)
97
76
13
27
49
i=3:
(65)
(38
49
65)
97
76
13
27
49
i=4:
(97)
(38
49
65
97)
76
13
27
49
i=5:
(76)
(38
49
65
76
97)
13
27
49
(1#
i=6:
38
49
65
(13)
97)
27
49
#
i=7:
(27)
(13
38
49
65
76
97)
49
i=8:
(49)
(13
27
38
49
65
76
97)
监视哨L.R[0]
图8.1直接插入排序示例
直接插入排序算法的性能分析如下：
空间效率：仅使用了常数个辅助单元，因而空间复杂度为0（1)。
时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作
都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。
在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，
因而时间复杂度为O(n)。
在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达
到最大，总的移动次数也达到最大，总的时间复杂度为O(²)。
平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为
平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n²/4。
因此，直接插入排序算法的时间复杂度为O(²)。
稳定性：因为每次插入元素时总是从后往前先比较再移动，所以不会出现相同元素相对位置
发生变化的情况，即直接插入排序是一个稳定的排序算法。
适用性：直接插入排序适用于顺序存储和链式存储的线性表，采用链式存储时无须移动元素。
8.2.2折半插入排序
从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：①从前面的有序子
表中查找出待插入元素应该被插入的位置：②给插入位置腾出空间，将待插入元素复制到表中的
插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半
