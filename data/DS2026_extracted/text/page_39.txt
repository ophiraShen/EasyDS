第2章线性
表
27
elser
1/元素个数为偶数
s1=m1+1;
//舍弃A的前半部分
d2=m2;
//舍弃B的后半部分
else{
//满足条件③
if（（s1+d1）2==0）{
1//若元素个数为奇数
d1=ml;
/舍弃A中间点以后的部分，且保留中间点
s2=m2;
//舍弃B中间点以前的部分，且保留中间点
elsel
1//元素个数为偶数
d1=ml;
//舍弃A的后半部分
s2=m2+1;
1//舍弃B的前半部分
return A[s1]<B[s2]? A[s1]:B[s2];
3）算法的时间复杂度为O（log2n)，空间复杂度为O（1)。
【另解】对两个长度为n的升序序列A和B中的元素按从小到大的顺序依次访问，这里访问
的含义只是比较序列中两个元素的大小，并不实现两个序列的合并，因此空间复杂度为0(1)。按
照上述规则访问第n个元素时，这个元素为两个序列A和B的中位数。
12.【解答】
1）算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元
素的元素Num。然后重新计数，确认Num是否是主元素。
算法可分为以下两步：
①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到
c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计
数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一
轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。
②判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大
于n/2，则为主元素；否则，序列中不存在主元素。
2）算法实现如下：
int Majority(int A[],int n)(
int i,c,count=l;
llc用来保存候选主元素，count用来计数
C=A[0];
//设置A[0]为候选主元素
for(i=1;i<n;i++)
//查找候选主元素
if(A[i]==c)
count++;
//对A中的候选主元素计数
else
if(count>0)
1//处理不是候选主元素的情况
count--;
elsel
//更换候选主元素，重新计数
C=A[i];
count=1;
if(count>0)
for（i=count=0;i<n;i++)
//统计候选主元素的实际出现次数
if(A[i]==c)
count++;
if(count>n/2) return c;
//确认候选主元素
