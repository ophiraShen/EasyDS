54
2026年数据结构考研复习指导
pb=pb->next;
/后移指针
free(u);
/释放B中当前结点
)//while结束
while(pa)(
/B已遍历完，A未完
!ed=n
pa=pa->next;
free(u);
/释放A中剩余结点
while(pb)(
//A已遍历完，B未完
u=pb;
pb=pb->next;
free(u);
/释放B中剩余结点
pc->next=NULL;
//置结果链表尾指针为NULL
free(lb);
//释放B表的头结点
return la;
链表归并类型的试题在各学校历年真题中出现的频率很高，故应扎实掌握解决此类问题的思
想。该算法的时间复杂度为O(lenl+len2)，空间复杂度为O(1)。
10.【解答】
算法思想：因为两个整数序列已存入两个链表中，操作从两个链表的第一个结点开始，若对
应数据相等，则后移指针：若对应数据不等，则A链表从上次开始比较结点的后继开始，B链表
仍从第一个结点开始比较，直到B链表到尾表示匹配成功。A链表到尾而B链表未到尾表示失败。
操作中应记住A链表每次的开始结点，以便下次匹配时好从其后继开始。
本题代码如下：
int Pattern(LinkList A,LinkList B){
LNode *p=A;
/lp为A链表的工作指针，本题假定A和B均无头结点
LNode *pre=p;
llpre记住每趟比较中A链表的开始结点
LNode *q=B;
Ilg是B链表的工作指针
while(p&&q)
if(p->data==q->data）(//结点值相同
p=p->next;
q=q->next;
elsef
pre=pre->next;
p=pre;
IIA链表新的开始比较结点
q=B;
llg从B链表第一个结点开始
if（q==NULL)
I/B已经比较结束
return
/说明B是A的子序列
else
return
0;
/B不是A的子序列
注意
该题其实是字符串模式匹配的链式表示形式，读者应该结合字符串模式匹配的内容重新考虑能否优
化该算法。
11.【解答】
