第2章线性表
15
假定线性表的元素类型为ElemType，则静态分配的顺序表存储结构描述为
#define MaxSize 50
//定义线性表的最大长度
typedef struct{
ElemType data[MaxSize];
//顺序表的元素
int length;
//顺序表的当前长度
)SqList;
//顺序表的类型定义
维数组可以是静态分配的，也可以是动态分配的。对数组进行静态分配时，因为数组的大
小和空间事先已经固定，所以一旦空间占满，再加入新数据就会产生溢出，进而导致程序崩溃。
而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦
数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到
扩充数组存储空间的目的，而不需要为线性表一次性地划分所有空间。
动态分配的顺序表存储结构描述为
#define InitSize 100
//表长度的初始定义
typedef struct{
ElemType *data;
//指示动态分配数组的指针
int MaxSize,length;
//数组的最大容量和当前个数
)SeqList;
//动态分配数组顺序表的类型定义
C的初始动态分配语句为
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
C++的初始动态分配语句为
L.data=new ElemType[InitSize];
注意
动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，
只是分配的空间大小可以在运行时动态决定。
VV
vV
顺序表的主要优点：①可进行随机访问，即可通过首地址和元素序号可以在0（1）时间内找到
指定的元素；②存储密度高，每个结点只存储数据元素。顺序表的缺点也很明显：①元素的插入
和删除需要移动大量的元素，插入操作平均需要移动n/2个元素，删除操作平均需要移动（n-1)/2
个元素；②顺序存储分配需要一段连续的存储空间，不够灵活。
2.2.2顺序表上基本操作的实现
命题追踪顺序表上操作的时间复杂度分析（2023）
这里仅讨论顺序表的初始化、插入、删除和按值查找，其他基本操作的算法都很简单。
注意
在各种操作的实现中（包括严蔚敏老师撰写的教材），往往可以忽略边界条件判断、变量定义、内存
分配不足等细节，即不要求代码具有可执行性，而重点在于算法的思想，
1.顺序表的初始化
静态分配和动态分配的顺序表的初始化操作是不同的。静态分配在声明一个顺序表时，就已
为其分配了数组空间，因此初始化时只需将顺序表的当前长度设为0。
//SqListL;
1//声明一个顺序表
void InitList(SqList &L){
L.length=0;
//顺序表初始长度为0
