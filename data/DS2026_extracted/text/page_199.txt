第5章树与二叉树
187
在采用树的双亲指针数组表示作为并查集的存储表示时，集合元素的编号从0到SIZE-1。
其中SIZE是最大元素的个数。
3.并查集的基本实现
并查集的结构定义如下：
#define SIZE 100
int
UFSets[SIZE];
//集合元素数组（双亲指针数组）
下面是并查集主要运算的实现。
（1）并查集的初始化操作
void Initial(int S[]){
I/s即并查集
for（int i=0;i<SIzE;i++)
//每个自成单元素集合
S[i]=-1;
（2）并查集的Find操作
在并查集s中查找并返回包含元素×的树的根。
int Find(int S[],int x）{
//循环寻找×的根
while(S[x]>=0)
x=S[x];
return x;
/根的S[]小于0
判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。
（3）并查集的Union操作
求两个不相交子集合的并集。若将两个元素所在的集合合并为一个集合，则需要先找到两个
元素的根，再令一棵子集树的根指向另一棵子集树的根。
void Union(int S[l,int Rootl,int Root2){
if(Root1==Root2) return;
//要求Root1与Root2是不同的集合
S[Root2]=Rootl;
/将根Root2连接到另一根Root1下面
Find操作和Union操作的时间复杂度分别为O（d和O（1)，其中d为树的深度。
4.并查集实现的优化
在极端情况下，n个元素构成的集合树的深度为n，则Find操作的最坏时间复杂度为O(n)。
改进的办法是：在做Union操作之前，首先判别子集中的成员数量，然后令成员少的根指向成
员多的根，即把小树合并到大树，为此可令根结点的绝对值保存集合树中的成员数量。
（1）改进的 Union 操作
void Union(int S[],int Rootl,int Root2){
if(Rootl==Root2) return;
if(S[Root2]>S[Root1]){
//Root2结点数更少
S[Root1]+=S[Root2];
//累加集合树的结点总数
S[Root2]=Root1;
//小树合并到大树
1
elset
//Root1结点数更少
S[Root2]+=S[Root1];
//累加结点总数
S[Root1]=Root2;
//小树合并到大树
采用这种方法构造得到的集合树，其深度不超过log2n」+1。
随着子集逐对合并，集合树的深度越来越大，为了进一步减少确定元素所在集合的时间，还
可进一步对上述Find操作进行优化，当所查元素×不在树的第二层时，在算法中增加一个压缩
