52
2026年数据结构考研复习指导
从第一个公共结点开始到链表的尾结点，这一部分是重合的，因此它们肯定也是同时到达第一公
共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。
根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长
的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到
链表结束。此时，该方法的时间复杂度为O(lenl+len2)。
06.【解答】
算法思想：循环遍历链表C，采用尾插法将一个结点插入表A，这个结点为奇数号结点，这
样建立的表A与原来的结点顺序相同；采用头插法将下一结点插入表B，这个结点为偶数号结点，
这样建立的表B与原来的结点顺序正好相反。
本题代码如下：
LinkList DisCreat_2(LinkList &A){
LinkList B=（LinkList）malloc（sizeof（LNode））;/创建B表表头
B->next=NULL;
//B表的初始化
LNode *p=A->next,*q;
//p为工作指针
LNode *ra=A;
//ra始终指向A的尾结点
while(p!=NULL){
ra->next=p;
;ra=p;
//将*p链到A的表尾
p=p->next;
if（p!=NULL）{
q=p->next;
//头插后，*p将断链，因此用g记忆*p的后继
x
//将*p插入到B的前端
B->next=p;
!b=d
ra->next=NULL;
I/A尾结点的next域置空
return B;
该算法特别需要注意的是，采用头插法插入结点后，*p的指针域已改变，若不设变量保存
其后继结点，则会引起断链，从而导致算法出错。
07.【解答】
算法思想：题中链表是有序表，因此所有相同值域的结点都是相邻的。用p扫描递增单链表
L，若*p结点的值域等于其后继结点的值域，则删除后者，否则p移向下一个结点。
本题代码如下：
void Del_Same（LinkList &L)
LNode *p=L->next,*q;
llp为扫描工作指针
if(p==NULL)
return;
while(p->next!=NULL)(
q=p->next;
llg指向*p的后继结点
if(p->data==q->data){
//找到重复值的结点
p->next=q->next;
//释放*q结点
free(q);
/释放相同元素值的结点
else
本算法的时间复杂度为O(n)，空间复杂度为O(1)。
本题也可采用尾插法，将头结点摘下，然后从第一结点开始，依次与已经插入结点的链表的
