222
2026年数据结构考研复习指导
6.3.2深度优先搜索
与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如
其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”地搜索一个图。
它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访
问的任意一个顶点w，再访问与w邻接且未被访问的任意一个顶点w重复上述过程。当不
能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该
点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。
一般情况下，其递归形式的算法十分简洁，算法过程如下：
bool visited[MAX_VERTEX_NUM];
//访问标记数组
void DFsTraverse(Graph G)(
//对图G进行深度优先遍历
for(i=0;i<G.vexnum;i++)
visited[i]=FALSE;
/初始化已访问标记数组
for（i=0;i<G.vexnum;i++)
//本代码中是从v开始遍历
if(!visited[i])
//对尚未访问的顶点调用DFS（）
DFS(G,i);
用邻接表实现深度优先搜索的算法如下：
void DFS(ALGraph G,int i）{
visit(i);
//访问初始顶点i
visited[i]=TRUE;
//对i做已访问标记
for(p=G.vertices[i].firstarc;p;p=p->nextarc)(/检测i 的所有邻接点
j=p->adjvex;
if(visited[j]==FALSE)
DFS(G,j);
//j为i的尚未访问的邻接点，递归访问j
用邻接矩阵实现深度优先搜索的算法如下：
void DFS（MGraph G,int i){
visit(i);
/访问初始顶点i
visited[i]=TRUE;
//对i做已访问标记
for（j=0;j<G.vexnum;j++）{
/检测i的所有邻接点
if(visited[j]==FALSE&&G.edge[i][j]==1)
DFS(G,j);
j为i的尚未访问的邻接点，递归访问j
命题追踪深度优先遍历的过程（2015、2016）
以图6.11的无向图为例，深度优先搜索的过程：首先访问a，并置a访问标记：然后访问与a
邻接且未被访问的顶点b，置b访问标记：然后访问与b邻接且未被访问的顶点d，置d访问标
记。此时d已没有未被访问过的邻接点，所以返回上一个访问的顶点b，访问与其邻接且未被访问
的顶点e，置e访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为abdehcfg。
注意
图的邻接矩阵表示是唯一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表也不同。因
此，对同样一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历得
到的DFS序列和BFS序列是不唯一的。
