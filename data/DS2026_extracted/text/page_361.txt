第8章排
序
349
命题追踪
快速排序的中间过程的分析（2014、2019、2023）
此时，指针i（==j）之前的元素均小于49，指针i之后的元素均大于或等于49，将49放
在i所指位置即其最终位置，经过第一趟排序后，将原序列分割成了前后两个子序列。
第一趟后：
127
38
13}
49
76
97
65
按照同样的方法对各子序列进行快速排序，若待排序列中只有一个元素，显然已有序。
第二趟后：
113)
27
[38)
49
149
65}
76
1971
第三趟后：
13
27
38
49
49
1651
76
97
第四趟后：
13
27
49
49
65
76
97
用二叉树的形式描述这个快速排序示例的递归调用过程，如图8.4所示。
第一层快排处理后：
9
第一层快排处理后：
第二层快排要
273813
65926 9
第二层快排处理后：
处理的部分：
第三层快排要
13
38
处理的部分：
(a)第一层快排处理后
(b)第二层快排处理后
第一层快排处理后：
49
第一层快排处理后：
第二层快排处理后：
第二层快排处理后：
第三层快排处理后：13
38
第三层快排处理后：
13
38
第四层快排要处理的部分：
65
第四层快排处理后：
65
(c)第三层快排处理后
(d）第四层快排处理后：最终结果
图8.4快速排序的递归执行过程
假设划分算法已知，记为Partition（），返回的是上述的k，则L（k）已放在其最终位置。
因此可以先对表进行划分，然后对两个子表递归地调用快速排序算法进行排序。代码如下：
if(low<high)(
//递归跳出的条件
/lPartition（）就是划分操作，将表A[lowhigh]划分为满足上述条件的两个子表
int pivotpos=Partition(A，low,high）;/划分
QuickSort（A，low,pivotpos-1）;//依次对两个子表进行递归排序
QuickSort(A,pivotpos+l,high);
命题追踪（算法题）快速排序中划分操作的应用（2016）
快速排序算法的性能主要取决于划分操作的好坏。考研所考查的快速排序的划分操作通常总
以表中第一个元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动，将比枢轴小的
元素向左移动，使得一趟Partition（）操作后，表中的元素被枢轴一分为二。代码如下：
int Partition（ElemType A[],int low,int high){ //一趟划分
ElemType pivot=A[low]；//将当前表中第一个元素设为枢轴，对表进行划分
