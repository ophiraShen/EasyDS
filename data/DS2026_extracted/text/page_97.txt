第3章栈、队列和数组
85
况和front指向当前元素，rear指向队尾元素的下一个元素的计算是相同的。
注意
数组A[n]的下标范围为0~n-1。若写成A[..n］，则说明下标范围为0~n。
07.B
循环队列中，每删除一个元素，队首指针front=（front+1）%6，每插入一个元素，队尾
指针rear=（rear+1）%6。上述操作后，front=0，rear=3。
08.D
当队列中只有一个元素时，front指向该元素的前一个位置，rear指向该元素，因此当队
列为空时，队首指针等于队尾指针，这样第一个元素入队后，才能符合题目要求。
09.C
既然不能附加任何其他数据成员，只能采用牺牲一个存储单元的方法来区分是队空还是队
满，约定以“队列头指针在队尾指针的下一位置作为队满的标志”，因此选择选项C。选项A是
判断队列是否空的条件，选项B和D都是干扰项。
注意
对于这类具体问题，举一些特例判断往往比直接思考问题能更快得到答案。
10.A
若用（rear+1）（n+1)==front作为队满标志，则说明题目采用了牺牲一个存储单元的方
法来区分队空和队满，因此可用front==rear 作为队空标志。
11.D
虽然链式队列采用动态分配方式，但其长度也受内存空间的限制，不能无限制增长。顺序队
列和链式队列的入队和出队时间复杂度均为O(1)。顺序队列和链式队列都可以进行顺序访问。对
于顺序队列，可通过队首指针和队尾指针计算队列中的元素个数，而链式队列则不能。
12.B
因为队列需在双端进行操作，所以选项C和D的链表显然不太适合链队。对于选项A，链
表在完成入队和出队后还要修改为循环的，对于队列来讲这是多余的（画蛇添足）。对于选项B，
因为有首指针，所以适合删除首结点：因为有队尾指针，所以适合在其后插入结点。
13.A
因为非循环双链表只带队首指针，所以在执行入队操作时需要修改队尾结点的指针域，而查
找队尾结点需要O（n)的时间。选项B、C和D均可在O（1)的时间内找到队首和队尾。
14.A
因为在队头做出队操作，为便于删除队首元素，所以总是选择链头作为队头。
15.D
队列用链式存储时，删除元素从表头删除，通常仅需修改头指针，但若队列中仅有一个元素，
则队尾指针也需要被修改，当仅有一个元素时，删除后队列为空，需修改队尾指针为
rear=front。
16.D
插入操作时，先将结点x插入到链表尾部，再让rear指向这个结点x。选项C的做法不够
严密，因为是队尾，所以队尾x->next必须置为空。
