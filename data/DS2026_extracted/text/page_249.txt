第6章图
237
初始化：方阵A(-[i]U]=arcs[i]U]。
第1轮：将v作为中间顶点，对于所有顶点对{ij}，若有A"[i]>A[i[0]+A[0]，则将
A"[]U]更新为A[][0]+A[0]U]。有A[2][1]>A[2]I0]+A[0][1]=11，更新A[2][1]=11，更
新后的方阵标记为4
第2轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A°[0]12]>A"[0][1]+A[1]12]=
10，更新A[0][2]=10，更新后的方阵标记为A'。
第3轮：将v作为中间顶点，继续检测全部顶点对{i,j}。有A'[1]I0]>A'[1][2]+A'[2]I0]=9,
更新 A'[1]I0]=9，更新后的方阵标记为 A。此时 A²中保存的就是任意顶点对的最短路径长度。
表6.3Floyd算法的执行过程
A(-1)
A(O)
AU)
A(2)
Vo
V
Vo
V
V2
V
V
V2
01
V
V2
Vo
0
6
13
0
6
13
0
6
1
0
6
10
V
10
0
4
10
0
4
10
0
4
0
V2
5
8
0
5
11
0
5
015
11
0
Floyd算法的时间复杂度为O(V)。不过其代码很紧凑，且并不包含其他复杂的数据结构，
因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。
Floyd算法允许图中有带负权值的边，但不允许包含总权值为负的回路。Floyd算法同样适
用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。
也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源
点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为O(IV)·V=O(IV)。
BFS算法、Dijkstra算法和Floyd算法求最短路径的总结如表6.4所示。
表6.4BFS算法、Dijkstra算法和Floyd算法求最短路径的总结
BFS算法
Dijkstra算法
Floyd算法
用途
求单源最短路径
求单源最短路径
求各顶点之间的最短路径
无权图
适用
适用
适用
带权图
不适用
适用
适用
带负权值的图
不适用
不适用
适用
带负权回路的图
不适用
不适用
不适用
时间复杂度
0()或 O(N+ [E)
0(V)
oW)
6.4.3
有向无环图描述表达式
有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。
命题追踪构建表达式的有向无环图（2019）
有向无环图是描述含有公共子式的表达式的有效工具。例如表达式
(（p+∞）)((p+∞)+(（p+∞)9）(q+D))
可以用上一章描述的二叉树来表示，如图6.20所示。仔细观察该表达式，可发现有一些相同的
子表达式（c+d)和（c+d)*e，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对
相同子式的共享，从而节省存储空间，图6.21所示为该表达式的有向无环图表示。
