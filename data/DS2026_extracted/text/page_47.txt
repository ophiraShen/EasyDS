第2章线性
表
35
注意
单链表是整个链表的基础，读者一定要熟练掌握单链表的基本操作算法。在设计算法时，建议先通
过画图的方法理清算法的思路，然后进行算法的编写。
2.3.3双链表
单链表结点中只有一个指向其后继的指针，使得单链表只能从前往后依次遍历。要访问
某个结点的前驱（插入、删除操作时），只能从头开始遍历，访问前驱的时间复杂度为O(n)。
为了克服单链表的这个缺点，引入了双链表，双链表结点中有两个指针prior和next，分
别指向其直接前驱和直接后继，如图2.9所示。表头结点的prior域和尾结点的next域都
是NULL。
图2.9双链表示意图
双链表中结点类型的描述如下：
typedef struct DNodel
//定义双链表结点类型
ElemType data;
//数据域
struct DNode *prior,*next;
//前驱和后继指针
)DNode，*DLinklist;
双链表在单链表结点中增加了一个指向其前驱的指针prior，因此双链表的按值查找和按位
查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这
是因为“链”变化时也需要对指针prior做出修改，其关键是保证在修改的过程中不断链。此外，
双链表可以很方便地找到当前结点的前驱，因此，插入、删除操作的时间复杂度仅为O(1)。
1.双链表的插入操作
在双链表中p所指的结点之后插入结点*s，其指针的变化过程如图2.10所示。
公众号：小兔网盘
图2.10双链表插入结点过程
免费网课+无水印PDF
命题追踪双链表中插入操作的实现（2023）
插入操作的代码片段如下：
xau<-d=xau<-s ①
//将结点*s插入到结点*p之后
o-x-
③ s->prior=p;
④ p->next=s;
上述代码的语句顺序不是唯一的，但也不是任意的，①步必须在④步之前，否则*p的后继结
点的指针就会丢掉，导致插入失败。为了加深理解，读者可以在纸上画出示意图。若问题改成要求
在结点*p之前插入结点*s，请读者思考具体的操作步骤。
