第4章串
111
断”法处理，要克服这种端，只能不限定串长的最大长度，即采用动态分配的方式。
2.堆分配存储表示
堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是
在程序执行过程中动态分配得到的。
typedef struct{
char *ch;
/按串长分配存储区，ch指向串的基地址
int length;
//串的长度
)HString;
在C语言中，存在一个称为堆的自由存储区，并用malloc（）和free（）函数来完成动态存
储管理。利用malloc（）为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则
返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来指示；若分配失败，则返
回NULL。已分配的空间可用free（）释放掉。
上述两种存储表示通常为高级程序设计语言所采用。块链存储表示仅做简单介绍。
3.块链存储表示
类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性（每个元素只
有一个字符)，在具体实现时，每个结点既可以存放一个字符，又可以存放多个字符。每个结点
称为块，整个链表称为块链结构。图4.1(a)是结点大小为4（每个结点存放4个字符）的链表，最
后一个结点占不满时通常用“#”补上：图4.1(b)是结点大小为1的链表。
nead
ABCDEFGH>I###A
（a）结点大小为4的链表
B→
（b）结点大小为1的链表
图4.1串值的链式存储方式
4.2串的模式匹配
4.2.1简单的模式匹配算法
模式匹配是指在主串中找到与模式串（想要搜索的某个字符串）相同的子串，并返回其所在
的位置。这里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。
int Index(SString S,SString T){
int i=1,j=1;
while(i<=s.length&&j<=T.length)(
if(S.ch[i]==T.ch[j]){
++i;++j;
1//继续比较后继字符
elser
i=i-j+2;j=1;
//指针后退重新开始匹配
）
if(j>T.length)return i-T.length;
else return 0;
在上述算法中，分别用计数指针i和j指示主串S和模式串T中当前待比较的字符位置。
