第8章排
序
355
置，其中至少有一个元素是在数组的首端或尾端。②基准元素不在数组的首端或尾端，第二趟快
速排序对基准元素划分开的两个子序列分别进行一次划分，两个子序列各确定一个基准元素。这
样，两趟排序后就至少能确定三个元素的最终位置。基于上述结论，观察题中的四个选项，选项
A的2，3,6，7,9符合第一种或第二种情况；选项B中2，9符合第一种情况；选项D中5，9符合第
一种情况；最后看选项C，只有9处于最终位置，因此不可能是快速排序第二趟的结果。
18.D
基于上题中分析得出的结论，观察题中的四个选项，选项A的28，72符合第一种情况；选项
B的2，72符合第一种情况；选项C的2，28，32符合第一种或第二种情况；最后看选项D，只有
12和32处于最终位置，既不符合第一种情况，又不符合第二种情况。
19.D
第一趟划分后得到的序列中只有一个枢轴，因此可将当前序列和最终排好序的序列进行比较，
如下表所示。枢轴会出现在两个序列的相同位置，可以看出枢轴只可能是77、81，选项只有81。
在当前序列中，77左边有比它大的元素80，因此77不是枢轴：而81左边都是比它小的元素，
右边都是比它大的元素，因此81是枢轴。
当前序列
68
11
70
23
80
77
48
81
93
88
最终序列
11
23
48
68
70
77
80
81
88
93
20.A
依题意，对数组M进行第一趟快速排序后，会将M划分为三部分：小于枢轴值的块P，枢
轴元素，大于枢轴值的块Q。P和Q块内都是无序的，但是P块内的数据≤枢轴值，Q块内的数
据≥枢轴值，因此P块内的数据≤Q块内的数据，即P与Q块间有序。
二、综合应用题
01.【解答】
本题可采用基于快速排序的划分思想来设计算法，只需遍历一次即可，其时间复杂度为O(n),
空间复杂度为O(1)。假设表为L[1..n]，基本思想是：先从前往后找到一个偶数元素L（i），再
从后往前找到一个奇数元素（j），将二者交换；重复上述过程直到i大于j。
算法的实现如下：
void move(ElemType A[],int len){
//对表A按奇偶进行一趟划分
inti=0,j=len-1;
//i表示左端偶数元素的下标：j表示右端奇数元素的下标
while（i<j){
while（i<j&&A[i]%2！=0）i++；l/从前往后找到一个偶数元素
while（i<j&&A[j］%2！=1）j--；//从后往前找到一个奇数元素
if（i<j){
Swap(A[i],A[j]);
//交换这两个元素
i++;j--;
02.【解答】
显然，本题最直接的做法是用排序算法对数组先进行从小到大的排序，然后直接提取L(k)
便得到了第k小的元素，但其平均时间复杂度将达到O(mlog2n)以上。此外，还可采用小顶堆的方
它基于快速排序的划分操作。
这个算法的主要思想如下：从数组L[1.n]中选择枢轴pivot（随机或直接取第一个）进行和
