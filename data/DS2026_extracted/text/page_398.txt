386
2026年数据结构考研复习指导
较次数始终为1+2++n-1=n(n-1)/2，选项I正确。两种排序算法的辅助空间都是O(1)，无
差别，选项ⅡI错误。初始有序时，移动次数均为0：对于通常情况，直接插入排序每趟插入都需
要依次向后挪位，而简单选择排序只需与找到的最小元素交换位置，后者的移动次数少很多，选
项IⅢI错误。
20.D
直接插入排序和快速排序的特点如下表所示。
适合初始序列情况
适合元素数量
空间复杂度
稳定性
直接插入排序
大部分元素有序
较少
0(1)
稳定
快速排序
基木无序
较多
O(log2n)
不稳定
可见，选项I、ⅡI、ⅢI、IV都是采用直接插入排序而不采用快速排序的可能原因。
21.C
稳定的内部排序算法：插入排序、冒泡排序、归并排序和基数排序。不稳定的内部排序算法：
简单选择排序、快速排序、希尔排序和堆排序。
二、综合应用题
01.【解答】
直接插入排序的交换次数更多，因此应当采用简单选择排序。
初始序列：3,7,6,9,7,1,4,5,20
第一次：1,7,6,9,7,3,4,5,20
交换1,3
第二次：1,3,6,9,7,7,4,5,20
交换3.7
第三次：1,3,4,9,7,7,6,5,20
交换4,6
第四次：1,3,4,5,7,7,6,9,20
）交换5.9
第五次：1,3,4,5,6,7,7,9,20交换6,7
所以最小交换次数为5（注意这里求的是交换次数，而不是移动次数或比较次数）。
02.【解答】
1）算法的基本设计思想如下：将数组A[1..m+n]视为一个已经过m趟插入排序的表，则从
m+1趟开始，将后n个元素依次插入前面的有序表中。
2）算法的实现如下：
void Insert_Sort(ElemType A[],int m,int n)(
int i,j;
for（i=m+1;i<=m+n;i++）{
//依次将A[m+1..m+n]插入有序表
A[0]=A[i];
//复制为哨兵
for(j=i-1;A[j]>A[0];j--)
//从后往前插入
A[j+1]=A[j];
1/元素后移
A[j+1]=A[0];
/插入
3）时间复杂度由m和n共同决定，从上面的算法不难看出，在最坏情况下元素的比较次数
为O(mn)，而元素移动的次数为O(mn)，所以时间复杂度为O(mn)。
因为算法只用到了常数个辅助空间，所以空间复杂度为O(1)。
此外，本题也可采用归并排序，将A[1.m]和A[m+1..m+n]视为两个待归并的有序子序列，
算法的时间复杂度为O(m+n)，空间复杂度为O(m+n)。
03.【解答】
基本思想：以K，为枢轴进行一趟快速排序。将快速排序算法改为以最后一个元素为枢轴，
