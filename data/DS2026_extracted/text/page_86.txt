74
2026年数据结构考研复习指导
理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，对两个元素进行
比较，若相等，则将链表中的下一个元素与栈中再弹出的元素进行比较，直至链表到尾。这时若
栈是空栈，则得出链表中心对称的结论：否则，当链表中的一个元素与栈中弹出元素不等时，结
论为链表非中心对称，结束算法的执行。
本题代码如下：
int dc（LinkList L,int n){
inti;
char s[n/2];
//s字符栈
LNode *p=L->next;
//工作指针p，指向待处理的当前元素
for(i=0;i<n/2;i++){
//链表前一半元素入栈
s[i]=p->data;
p=p->next;
i-
//恢复最后的i值
if（n%2==1)
//若n是奇数，后移过中心结点
p=p->next;
while(p!=NULL&&s[i]==p->data)(
//检测是否中心对称
i--;
//li充当栈顶指针
p=p->next;
if(i==-1)
/栈为空栈
return
1;
/链表中心对称
else
return
0;
//链表中心不对称
算法先将“链表的前一半”元素（字符）入栈。当n为偶数时，前一半和后一半的个数相同；
当n为奇数时，链表中心结点字符不必比较，移动链表指针到下一字符开始比较。比较过程中遇
到不相等时，立即退出while循环，不再进行比较。
本题也可以先将单链表中的元素全部入栈，然后扫描单链表工并比较，直到比较到单链表工
尾为止，但算法需要两次扫描单链表L，效率不及上述算法高。
05.【解答】
两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，S1栈顶指针为-1，S2栈顶指
针为maxsize。两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。
本题代码如下：
#define
maxsize
100
//两个栈共享顺序存储空间所能达到的最多元素数，
/初始化为100
#define
elemtp int
//假设元素类型为整型
typedef
struct{
elemtp stack[maxsize];
//栈空间
int
top[2];
//top为两个栈顶指针
)stk;
stk
S;
l/s是如上定义的结构类型变量，为全局变量
本题的关键在于，两个栈入栈和出栈时的栈顶指针的计算。S1栈是通常意义下的栈：而S2
栈入栈操作时，其栈顶指针左移（减1），出栈时，栈顶指针右移（加1）。
此外，对于所有栈的操作，都要注意“入栈判满、出栈判空”的检查。
（1）入栈操作
代码如下：
int push(int i,elemtp x)(
l/入栈操作。i为栈号，i=0表示左边的S1栈，i=1表示右边的S2栈，x是入栈元素
