第6章图
235
思考：Diikstra算法与Prim算法有何异同之处？
命题追踪Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）
例如，对图6.17中的图应用Dijkstra算法求从顶点1出发至其余顶点的最短路径的过程，如
表6.2所示。算法执行过程的说明如下。
每轮得到的最短路径如下：
第1轮：1→5，路径距离为5
第2轮：1→5→4，路径距离为7
第3轮：1→5→2，路径距离为8
第4轮：1→5→2→3，路径距离为9
图6.17应用Dijkstra算法图
表6.2从v到各终点的dist值和最短路径的求解过程
顶点
第1轮
第2轮
第3轮
第4轮
10
8
8
2
v→V2
V→V5→V2
V→Vs→V2
14
13
9
3
8
V1-→V5-V3
V1-Vs-→V4-→V3
vI-Vs-→V2-→V3
7
4
8
V→V5→V4
5
5
V-Vs
集合S
(1.5)
(1,5,4)
{1,5,4,2}
{1,5,4,2,3}
初始化：集合S初始为{v}，V可达v2和V，V不可达v和v4，因此dist[]数组各元素的
初始值依次设置为dist[2]=10，dist[3]=∞，dist[4]=∞，dist[5]=5。
第1轮：选出最小值dist[5]，将顶点vs并入集合S，即此时已找到v到v的最短路径。当
vs加入S后，从v到集合V-S中可达顶点的最短路径长度可能会产生变化。因此需要更新dist[]
数组。vs可达v2，因v→v5→v2的距离8比dist[2]=10小，更新dist[2]=8；vs可达v3，
vi→V5→>V的距离 14，更新 dist[3]=14；vs可达v4，Vi→Vs→V4的距离 7，更新 dist[4]=7。
第2轮：选出最小值 dist[4］，将顶点v4并入集合S。继续更新 dist[]数组。v4不可达
V2，dist[2]不变；v4可达v3，V→v5→V4→v的距离13比dist[3]小，故更新dist[3]=13。
第3轮：选出最小值dist[2]，将顶点v2并入集合S。继续更新 dist[]数组。v2可达v3,
v→v5→v2→v的距离9比dist[3]小，更新dist[3]=9。
第4轮：选出唯一最小值dist[3]，将顶点v并入集合S，此时全部顶点都已包含在S中。
显然，Dijkstra算法也是基于贪心策略的。
①Dijkstra算法的流程、操作与Prim算法的都很相似，都基于贪心策略。区别在于，i.目的不同：Dijkstra 算法的目的是构建单
源点的最短路径树：Prim算法的目的是构建最小生成树。ii.算法思路略有不同：Prim算法从一个点开始，每次选择权值最小
的边，将其连接到已构建的生成树上，直至所有顶点都已加入：而Dijkstra算法每次找出到源点距离最近且未归入集合的
点，并把它归入集合，同时以这个点为基础更新从源点到其他所有顶点的距离。ii.适用的图不同：Pri算法只能用于带权无
向图：Dijkstra算法可用于带权有向图或带权无向图。
