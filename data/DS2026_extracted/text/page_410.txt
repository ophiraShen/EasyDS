398
2026年数据结构考研复习指导
生成三个初始归并段，分别是37,51,63,92,94,99；14,15,23,31,48,56,60,90,166；8,17,43,100。
2）最大值为n，最小值为m。
归纳总结
下面对本章所介绍的排序算法进行一次系统的比较和复习。
1.直接插入排序、冒泡排序和简单选择排序是基本的排序算法，它们主要用于元素个数n
不是很大（n<10000）的情形。
它们的平均时间复杂度均为O（²），实现也都非常简单。直接插入排序对于规模很小的元素
序列（n≤25）非常有效。它的时间复杂度与待排序元素序列的初始排列有关。在最好情况下，
直接插入排序只需要n-1次比较操作就可以完成，且不需要交换操作。在平均情况下和最差情况
下，直接插入排序的比较和交换操作都是O(n²)。冒泡排序在最好情况下只需要一趟排序过程就
可以完成，此时也只需要n-1次比较操作，不需要交换操作。简单选择排序的关键字比较次数与
待排序元素序列的初始排列无关，其比较次数总是O（n²)，但元素移动次数则与待排序元素序列
的初始排列有关，最好情况下数据不需要移动，最坏情况下元素移动次数不超过3（n-1)。
从空间复杂度来看，这三种基本的排序算法除一个辅助元素外，都不需要其他额外空间。从
稳定性来看，直接插入排序和冒泡排序都是稳定的，但简单选择排序不是。
2.对于中等规模的元素序列（n≤1000），希尔排序是一种很好的选择。
在希尔排序中，开始时增量较大，分量较多，每个组内的记录数较少，因而记录的比较和移
动次数较少，且移动距离较远；到后来步长越来越小（最后一步为1），分组越少，每个组内的记
上和实验上都已证明，在希尔排序中，记录的总比较次数和总移动次数比直接插入排序时少得多，
特别是当n越大时效果越明显。而且，希尔排序代码简单，基本上不需要什么额外内存，但希尔
排序是一种不稳定的排序算法。公众号：小兔网盘免费分享无水印PDF
3.对于元素个数n很大的情况，可以采用快速排序、堆排序、归并排序或基数排序，其中
快速排序和堆排序都是不稳定的，而归并排序和基数排序是稳定的排序算法。
快速排序是最通用的高效内部排序算法，特别是它的划分思想经常在很多算法设计题中出
现。平均情况下它的时间复杂度为O(nlog2n)，一般情况下所需要的额外空间也是O(log2n)。但是
快速排序在有些情况下也可能会退化（如元素序列已经有序时），时间复杂度会增加到O(²），空
间复杂度也会增加到O(n)。但我们可以通过“三者取中”法来避免最坏情况的发生。
堆排序也是一种高效的内部排序算法，它的时间复杂度是O(nlog2n)，而且没有什么最坏情况
会导致堆排序的运行明显变慢，并且堆排序基本上不需要额外的空间。但堆排序不大可能提供比
快速排序更好的平均性能。
归并排序也是一个重要的高效排序算法，它的一个重要特性是性能与输入元素序列无关，时
间复杂度总是O(nlog2n)。归并排序的主要缺点是需要O(n)的额外存储空间。
基数排序是一种相对特殊的排序算法，这类算法不仅是对元素序列的关键字进行比较，更重
要的是它们对关键字的不同位部分进行处理和比较。虽然基数排序具有线性增长的时间复杂度，
但由于在常规编程环境中，基数排序的线性时间开销实际上并不比快速排序的时间开销小很多，
并且由于基数排序基于的关键字抽取算法受到操作系统和排序元素的影响，其适应性远不如普通
