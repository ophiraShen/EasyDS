30
2026年数据结构考研复习指导
next为指针域，存放其后继结点的地址。
data
next
图2.3单链表结点结构
单链表中结点类型的描述如下：
typedef struct LNode
//定义单链表结点类型
ElemType data;
//数据域
struct LNode *next;
//指针域
)LNode,*LinkList;
利用单链表可以解决顺序表需要大量连续存储单元的缺点，但附加的指针域，也存在浪费存
储空间的缺点。单链表的元素离散地分布在存储空间中，因此是非随机存取的存储结构，即不能
直接找到表中某个特定结点。查找特定结点时，需要从表头开始遍历，依次查找。
通常用头指针L（或head等）来标识一个单链表，指出链表的起始地址，头指针为NULL
时表示一个空表。此外，为了操作上的方便，在单链表第一个数据结点之前附加一个结点，称
为头结点。头结点的数据域可以不设任何信息，但也可以记录表长等信息。单链表带头结点时，
头指针工指向头结点，如图2.4(a)所示。单链表不带头结点时，头指针L指向第一个数据结点，
如图2.4(b)所示。表尾结点的指针域为NULL（用“^”表示）。
(a)带表头结点的单链表
(b)不带表头结点的单链表
图2.4带头结点和不带头结点的单链表
头结点和头指针的关系：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结
点是带头结点的链表中的第一个结点，结点内通常不存储信息。
引入头结点后，可以带来两个优点：
①第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作
和在表的其他位置上的操作一致，无须进行特殊处理。
②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），
因此空表和非空表的处理也就得到了统一。
2.3.2单链表上基本操作的实现
带头结点单链表的操作代码书写较为方便，如无特殊说明，本节均默认链表带头结点。
1.单链表的初始化
带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要
创建一个头结点，并让头指针指向头结点，头结点的next域初始化为NULL。
bool InitList（LinkList &L)(
//带头结点的单链表的初始化
L=(LNode*)malloc(sizeof(LNode));
//创建头结点?
L->next=NULL;
/头结点之后暂时还没有元素结点
return true;
不带头结点的单链表初始化时，只需将头指针L初始化为NULL。
bool InitList(LinkList &L)(
//不带头结点的单链表的初始化
①执行s=（LNode*）malloc（sizeof（LNode））的作用是由系统生成一个LNode型的结点，并将该结点的起始位置赋给指针变量s。
