116
2026年数据结构考研复习指导
当模式串已匹配相等序列中不存在满足上述条件的子串时（可视为k=1），显然应让主串的
第i个字符和模式串的第1个字符进行比较。
当模式串的第1个字符（j=1）与主串的第i个字符发生失配时，规定next[1]=0。
通过上述分析可以得出next函数的公式：
0，
j=1
next[j]=
max{k|1<k<j且'p*Px-=P-x+"P-+），当此集合不为空时
[1,
其他情况
要用代码来实现，难度貌似还不小，下面来尝试推理求解的科学步骤。
首先由公式可知
next[1]=0
设next[j]=k，此时k应满足的条件在上文中已描述。
此时next[j+1]=？可能有两种情况：
（1）若pk=P，则表明在模式串中
p1...pk-ipk'=pj-k+1·.pj-iPj
且不可能存在k'>k满足上述条件，此时 next[j+1]=k+1，即
next[j+l]=next[j]+1
（2）若pk≠P，则表明在模式串中
dt-d...+x-d.d-d...d
匹配，当 pk≠pg 时，应将 pi".pk 向右滑动至用第 next [k]个字符与 p;进行比较，若 Pnext[k]
与 pg 仍不匹配，则需要寻找长度更短的相等前后缀，下一步继续用 Pnext[next[kj)与 p 进行较，
以此类推，直到找到某个更小的k'=next[next…·[k]]（1<k'<k<j)，满足条件
'p1..pk='pj-k+1..·pj'
则next[j+1]=k'+1。
也可能不存在任何k'满足上述条件，即不存在长度更短的相等前后缀，令next[j+1]=1
理解起来有点儿费劲？下面举一个简单的例子。
图4.4 的模式串中已求得6个字符的 next 值,现求 next[7],因为 next[6]=3,又 po≠p3,
所以需要比较p6和p（因next[3]=1），p6≠p1，而next[1]=0，因此next[7]=1;求next[8]，
因为p=P1，所以next[8]=next[7]+1=2；求next[9]，因为p=p2，所以next[9]=3。
1
2
34
5
模式串
al
b
next[j]
0112232
图4.4求模式串的next值
*4.KMP算法的实现
通过上述分析写出求next值的程序如下：
void get_next(sString T,int next[]){
inti=1,j=0;
next[1]=0;
while(i<T.length){
if（j==011T.ch[i]==T.ch[j]){
++i;++j；
next[i]=j;//若p=pj，则 next[j+1]=next[j]+1
