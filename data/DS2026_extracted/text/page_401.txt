第8章排序
389
每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并总共需要的比较次数为
S(n- 1)(k- 1)=[1ogzr (n- 1)(k- 1)=[1og2r(n- 1)(k - 1)/[1og2k]
式中，（k-1）/log2k随k增长而增长，因此内部归并时间亦随k的增长而增长。这将抵消因增大
k而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。
为了使内部归并不受k的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，
可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的元素，内
部结点用来记忆左右子树中的“失败者”，而让胜利者往上继续进行比较，一直到根结点。若比
较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。
命题追踪败者树的实现原理（2024）
如图8.17（a）所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，
此时，根结点ls[0]所指的段的关键字最小。对于k路归并，初始构造败者树需要k-1次比较。
b3中的6输出后，将下一关键字填入b3，继续比较。
12
15
12
20
40
(a)
(b)
图8.17实现5路归并的败者树
因为k路归并的败者树深度为「log2k+1，所以从k个记录中选择最小关键字，仅需进行[log2k]
次比较。因此总的比较次数约为
S(n-1) [1og2k]=[logkr](n-1)[1og2k]=(n-1)[1og2r]
可见，使用败者树后，内部归并的比较次数与k无关了。因此，只要内存空间允许，增大归
并路数k将有效地减少归并树的高度，从而减少I/O次数，提高外部排序的速度。
值得说明的是，归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓
冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外
存交换数据的次数增大。当k值过大时，虽然归并趟数会减少，但读/写外存的次数仍会增加。
8.7.4置换-选择排序（生成初始归并段）
从8.7.2节的讨论可知，减少初始归并段个数r也可以减少归并趟数S。若总的记录个数为n，
每个归并段的长度为（，则归并段的个数r=「n/C]。采用内部排序算法得到的各个初始归并段长
①本节中出现的关于比较次数的公式只是为了帮助读者理解相关原理，无须死记硬背。
