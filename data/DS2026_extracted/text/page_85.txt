第3章栈、队列和数组
73
二、综合应用题
01.【解答】
CD出栈后的状态如下图所示。
此时有如下3种操作：①E入栈后出栈，出栈序列为CDEBA：②B出栈，E入栈后出栈，出
栈序列为CDBEA：③B出栈，A出栈，E入栈后出栈，出栈序列为CDBAE。
所以，以CD开头的出栈序列有CDEBA、CDBEA、CDBAE三种。
02.【解答】
能得到出栈序列BCAED。可由A入，B入，B出，C入，C出，A出，D入，E入，E出，
D出得到。不能得到出栈序列DBACE。若出栈序列以D开头，说明在D之前的入栈元素是A、B
和C，三个元素中C是栈顶元素，B和A不可能早于C出栈，所以不可能得到出栈序列DBACE。
03.【解答】
1）选项A、D合法，而选项B、C不合法。在B中，先入栈1次，再连续出栈2次，错误。
在选项C中，入栈和出栈次数不一致，会导致最终的栈不空。选项A、D均为合法序列，请自行
模拟。注意，在操作过程中，入栈次数一定大于或等于出栈次数；结束时，栈一定为空。
栈序列（由“1”和“O”组成的字符串），每扫描至任意一个位置均需检查出栈次数（“O”的个
数）是否小于入栈次数（“1”的个数），若大于则为非法序列。扫描结束后，再判断入栈和出栈次
数是否相等，若不相等则不合题意，为非法序列。
本题代码如下：
bool Judge(char A[ ])(
int i=0;
int j=k=0;
/li为下标，j和k分别为字母1和O的个数
while(A[i]!='\o'）{
//未到字符数组尾
switch(A[i]){
case'I':j++;break;
/1入栈次数增1
case 'o':k++;
if（k>j）{printf（"序列非法\n"）；exit（0）；）
i++;
//不论A[i]是I还是O，指针i均后移
if（j!=k）{
printf（"序列非法\n"）;
returnfalse;
elset
printf（"序列合法\n"）;
return
true;
【另解】入栈后，栈内元素个数加1；出栈后，栈内元素个数减1，因此可将判定一组出入栈
序列是否合法转化为一组由+1、-1组成的序列，它的任意前缀子序列的累加和不小于0（每次出
栈或入栈操作后判断）则合法；否则非法。
04.【解答】
算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次入栈。在处
