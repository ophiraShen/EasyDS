第8章排
序
385
中，插入排序仅需比较n-1+4次，而希尔排序和冒泡排序的比较次数均远大于此。
10.A
简单选择排序的总比较次数显然是确定的。折半插入排序每趟的比较次数都为O(log2m）（m
为当前已排好序的子序列的长度），因此总比较次数也是确定的。基数排序不是基于比较的排序
算法。其他几种排序算法的比较次数显然和序列的初始状态有关。
11.C
堆是用于排序的，在查找时它是无序的，所以效率没有其他查找结构的高。
12.A
基数排序每趟需要利用前一趟已排好的序列，无法并行执行。快速排序每趟划分的子序列互
不影响，可以并行执行。冒泡排序每趟对未排序的所有元素进行一趟处理，无法并行执行。堆排
序可以并行执行，因为根结点的左右子树构成的子堆在执行过程中是互不影响的。
13.B
每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里{11，12}和{4，5}
所处的位置并不是最终位置，因此不可能是冒泡和选择排序。二路归并算法经过第二趟后应该是
每4个元素有序的，但{11，12，13,7并非有序，因此也不可能是二路归并排序。
14.A
题中给出的排序过程，每一趟都是从前往后依次比较使最大值沉底，符合冒泡排序的特点。
分别用其他3种排序算法尝试，归并排序第一趟后的结果为（2，12，16，88,5，10)，基数排序第一趟
后的结果为（10,2，12，5，16，88)，希尔排序显然不符合。
15.A
对于选项1，简单选择排序每次选择未排序序列中的最小元素放入其最终位置。对于选项ⅡⅡ
希尔排序每次对划分的子表进行排序，得到局部有序的结果，所以不能保证每趟结束都能确定一
个元素的最终位置。对于选项III，快速排序每趟结束后都将枢轴元素放到最终位置。对于选项IV，
堆排序属于选择排序，每次都将大根堆的根结点与表尾结点交换，确定其最终位置。对于选项V，
二路归并排序每趟对子表进行两两归并，从而得到若干局部有序的结果，但无法确定最终位置。
16.B
归并排序的代码比插入排序的代码更为复杂，前者的空间复杂度是O（n)，后者是O（1)。但是
前者的时间复杂度是O(nlog2n)，后者是O(n²)。
17.D
在顺序存储的条件下，插入排序、选择排序、冒泡排序的时间复杂度都是O(r²)，更换为链
式存储后的时间复杂度还是O（n²）。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链
式存储不支持这种性质，所以时间复杂度会增加。
18.D
当数据规模较小时可选择复杂度为O（n²）的简单排序算法，当数据规模较大时应选择复杂度
为O(nlog2n)的排序算法，当数据规模大到内存无法放下时需选择外部排序算法，选项I正确。
数据的存储方式主要分为顺序存储和链式存储，有些排序算法（如堆排序）只能用于顺序存储方
式，选项ⅡI正确。若对数据稳定性有要求，则不能选择不稳定的排序算法，选项IⅢI显然正确。
当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是
O(n)，而归并排序的时间复杂度依旧是O(nlog2n)，选项 IV正确。
19.A
考虑比较极端的情况，对于有序数组，直接插入排序的比较次数为n-1，简单选择排序的比
