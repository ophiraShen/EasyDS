第5章树与二叉树
163
结点（左、右结点都不为空，注意是双分支），若是，则Num++。
06.【解答】
采用递归算法实现交换二叉树的左、右子树，首先交换b结点的左孩子的左、右子树，然后
交换b结点的右孩子的左、右子树，最后交换b结点的左、右孩子，当结点为空时递归结束（后
序遍历的思想）。算法实现如下：
void swap(BiTree b){
//本算法递归地交换二叉树的左、右子树
if(b)(
swap(b->lchild) ;
//递归地交换左子树
swap(b->rchild);
//递归地交换右子树
temp=b->lchild;
I/交换左、右孩子结点
b->lchild=b->rchild;
b->rchild=temp;
07.【解答】
设置一个全局变量1（初值为1）来表示进行先序遍历时，当前访问的是第几个结点。然后
可以借用先序遍历的代码模型，先序遍历二叉树。当二叉树b为空时，返回特殊字符+#+；当k==i
时，该结点即要找的结点，返回b->data；当k≠i时，递归地在左子树中查找，若找到则返回
该值，否则继续递归地在右子树中查找，并返回其结果。对应的递归模型如下：
f(b,k)='#
当b=NULL时
f(b,k)=b->data
当i=k时
f(b,k)=((ch=f(b->lchild,k))=='#'?f(b->rchild,k):ch)
其他情况
算法的实现如下：
int i=1;
/遍历序号的全局变量
ElemType PreNode(BiTree b,int k)(
//本算法查找二叉树先序遍历序列中第k个结点的值
if(b==NULL)
//空结点，则返回特殊字符
return
!#，
if(i==k)
//相等，则当前结点即第k个结点
return
b->data;
i++;
/下一个结点
ch=PreNode(b->lchild,k);
//左子树中递归寻找
if（ch!='#')
//在左子树中，则返回该值
return ch;
ch=PreNode(b->rchild,k);
//在右子树中递归寻找
return ch;
本题实质上就是一个遍历算法的实现，只不过用一个全局变量来记录访问的序号，求其他遍
历序列的第k个结点也采用相似的方法。二叉树的遍历算法可以引申出大量的算法题，因此考生
务必要熟练掌握二叉树的遍历算法。
08.【解答】
删除以元素值×为根的子树，只要能删除其左、右子树，就可以释放值为×的根结点，因此
宜采用后序遍历。算法思想：删除值为×的结点，意味着应将其父结点的左（右）子女指针置空，
用层次遍历易于找到某结点的父结点。本题要求删除树中每个元素值为×的结点的子树，因此要
遍历完整棵二叉树。算法实现如下：
void DeleteXTree(BiTree &bt)(
//删除以bt为根的子树
if(bt){
