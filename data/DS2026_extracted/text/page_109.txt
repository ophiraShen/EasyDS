第3章栈、队列和数组
97
对于（（②a*（b+c））-d），提出操作符并去掉括号后，可得后缀表达式为abc+*d-。
学完第5章后，可将表达式画成二叉树的形式，再用后序遍历即可求得后缀表达式。
03.D
FIFO页面替换算法用到了队列。其余的都只用到了栈。
04.B
利用栈求表达式的值时，可以分别设立运算符栈和运算数栈，其原理不变。选项B中A入栈，
B入栈，计算得R1，C入栈，计算得R2，D入栈，计算得R3，由此得栈深为2。选项A、C、D
依次计算得栈深为4、3、3。因此选择选项B。
技巧
根据运算符优先级，统计已依次入栈但还未参与计算的运算符的个数。以选项C为例，当“（”“A”
“-”入栈时，“（”和“-”还未参与运算，此时运算符栈大小为2，“B”和“*”入栈时运算符大小为3，
“C”入栈时“B*C”运算，运算符栈大小为2，以此类推。
05.B
栈与递归有着紧密的联系。递归模型包括递归出口和递归体两个方面。递归出口是递归算法
的出口，即终止递归的条件。递归体是一个递推的关系式。根据题意有
f（0)=2:
f（1)=1*f（0)=2;
f（f（1))=f（2)=2*f（1)=4。
06.C
计算F(8)的递归调用树如下图所示：
由图可知，递归函数F（）调用的次数为9。
07.C
func（func（5））=func（4）=func（2）+func（0）=4，因此第4个被执行的func函数是func（4）。
也可以采用画出递归调用树的方式，即某个函数的执行次序等于其在递归调用树的先序遍历中的次序。
08.B
通常情况下，递归算法在计算机实际执行的过程中包含很多的重复计算，所以效率会低。
09.C
系统提供的栈中，若被调用函数有局部变量，也要压入栈中。
10.B
11.A
使用栈可以模拟递归的过程，以此来消除递归，但对于单向递归和尾递归而言，可以用迭代
的方式来消除递归，选项A正确。不同的入栈和出栈组合操作，会产生许多不同的输出序列，B
