第2章
线
性
未
33
图2.6单链表结点的删除
假设结点*p为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改*p
的指针域，将*p的指针域next指向*g的下一结点，然后释放*g的存储空间。
bool ListDelete（LinkList &L,int i,ElemType &e){
LNode *p=L;
/指针p指向当前扫描到的结点
int j=0;
//记录当前结点的位序，头结点是第0个结点
(>x
//循环找到第i-1个结点
p=p->next;
j++;
if(p->next==NULLI1j>i-1)
//i值不合法
false;
return
LNode *q=p->next;
l/令q指向被删除结点
e=q->data;
//用e返回元素的值
xu-b=xu<-
//将*q结点从链中“断开”
free(q);
/释放结点的存储空间?
return
true;
同插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为O(n)。当链表不带
头结点时，需要判断被删结点是否为首结点，若是，则要做特殊处理，将头指针L指向新的首结
点。当链表带头结点时，删除首结点和删除其他结点的操作是相同的。
扩展：删除结点*p。
要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱，然后执行删
除操作。其实，删除结点*p的操作可用删除*p的后继来实现，实质就是将其后继的值赋予其自
身，然后再删除后继，也能使得时间复杂度为O(1)。该方法的主要代码片段如下：
q=p->next;
//令g指向*p的后继结点
p->data=p->next->data;
//用后继结点的数据域覆盖
xu<-b=xu<-
//将*g结点从链中“断开”
free（q);
//释放后继结点的存储空间
7.采用头插法建立单链表
该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将
新结点插入到当前链表的表头，即头结点之后，如图2.7所示。算法实现如下：
每次将s所指的结点插在前端
图2.7采用头插法建立单链表
①执行free（q）的作用是由系统回收一个LNode型结点，回收后的空问可供再次生成结点时用。
