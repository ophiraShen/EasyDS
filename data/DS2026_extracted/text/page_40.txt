28
2026年数据结构考研复习指导
else return -1;
1/不存在主元素
3）实现的程序的时间复杂度为O(n)，空间复杂度为O(1)。
说明
本题若采用先排好序再统计的方法【时间复杂度为O（nlog2n)]，则只要解答正确，最高可拿11分。
即便是写出O（n²）的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得
不偿失的。本算法的方法非常典型，需牢固掌握
13.【解答】
1）算法的基本设计思想：
要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用
来记录A中是否出现了1~n中的正整数，B[0]对应正整数1，B[n-1]对应正整数n，初始化B
中全部为0。A中含有n个整数，因此可能返回的值是1~n+1，当A中n个数恰好为1~n时返回
n+1。当数组A中出现了小于或等于0或大于n的值时，会导致1~n中出现空余位置，返回结果
必然在1~n中，因此对于A中出现了小于或等于0或大于n的值，可以不采取任何操作。
经过以上分析可以得出算法流程：从A[0]开始遍历A，若0<A[i]<=n，则令B[A[i]-1]=1；
否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标i，
返回i+1即为结果，此时说明A中未出现的最小正整数在1和n之间。若B[i]全部不为0，返
回i+1（跳出循环时i=n，i+1等于n+1），此时说明A中未出现的最小正整数是n+1。
2）算法实现：
int findMissMin(int A[],int n)
int i,*B;
/标记数组
B=(int *)malloc(sizeof(int）*n);//分配空间
memset(B,0,sizeof(int)*n);
/赋初值为0
for(i=0;i<n;i++)
if(A[i]>0&&A[i]<=n)
/若A[i]的值介于1~n，则标记数组B
B[A[i]-1]=1;
for(i=0;i<n;i++)
/扫描数组B，找到目标值
if （B[i]==0）break;
return i+l;
/返回结果
3）时间复杂度：遍历A一次，遍历B一次，两次循环内操作步骤为O（1)量级，因此时间复
杂度为O(n)。空间复杂度：额外分配了B[n］，空间复杂度为O(n)。
14.【解答】
分析。由D=a-b+b-c+c-a≥0有如下结论。
①当a=b=c时，距离最小。
②其余情况。不失一般性，假设a≤b≤c，观察下面的数轴：
q-D=17
L2=b-
D-=
=7+7+7=0<|-0|+|-q|+1q-=q
由D的表达式可知，事实上决定D大小的关键是a和c之间的距离，于是问题就可以简化
