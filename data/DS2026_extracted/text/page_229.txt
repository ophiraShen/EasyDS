第6章图
217
图也可视为具有对边的有向图）。该邻接表对应的图G如下图所示。
03.【解答】
1）对于邻接矩阵表示的无向图，边数等于矩阵中1的个数除以2；对于邻接表表示的无向
图，边数等于边结点的个数除以2。对于邻接矩阵表示的有向图，边数等于矩阵中1的
个数；对于邻接表表示的有向图，边数等于边结点的个数。
2）在邻接矩阵表示的无向图或有向图中，对于任意两个顶点i和j，邻接矩阵中 arcs[i][j]
或arcs[j][i]为1表示有边相连，否则表示无边相连。在邻接表表示的无向图或有向图
中，对于任意两个顶点i和j，若从顶点表结点i出发找到编号为/的边表结点或从顶点表
结点j出发找到编号为i的边表结点，表示有边相连：否则为无边相连。
3）对于邻接矩阵表示的无向图，顶点i的度等于第i行中1的个数；对于邻接矩阵表示的
有向图，顶点i的出度等于第i行中1的个数；入度等于第i列中1的个数；度数等于它
们的和。对于邻接表表示的无向图，顶点1的度等于顶点表结点1的单链表中边表结点
的个数；对于邻接表表示的有向图，顶点i的出度等于顶点表结点i的单链表中边表结
点的个数，顶点i的入度等于邻接表中所有编号为1的边表结点数；度数等于入度与出
度之和。
04.【解答】
按各顶点的出度进行排序。n个顶点的有向图，其顶点的最大出度是n-1，最小出度为0。
这样排序后，出度最大的顶点编号为1，出度最小的顶点编号为n。之后，进行调整，即只要存
在弧<i,>，就不管顶点j的出度是否大于顶点i的出度，都把i编号在顶点j的编号之前，因为
只有≤j，弧<i,j>对应的1才能出现在邻接矩阵的上三角。
通过后面小节的学习，会发现采用拓扑排序并依次编号是一种更为简便的方法。
05.【解答】
算法思想：设图的顶点分别存储在数组v[n］中。首先初始化邻接矩阵。遍历邻接表，在依
次遍历顶点v[i]的边链表时，修改邻接矩阵的第i行的元素值。若链表边结点的值为j，则置
arcs[i］[j］=1。遍历完邻接表时，整个转换过程结束。此算法对于无向图、有向图均适用。
算法的实现如下：
void Convert(ALGraph &G,int arcs[M][N]){
//此算法将邻接表方式表示的图G转换为邻接矩阵arcs
for（i=0;i<n;i++）{
//依次遍历各顶点表结点为头的边链表
p=(G->v[i]).firstarc;
/取出顶点i的第一条出边
while(p!=NULL){
//遍历边链表
arcs[i][p->adjvex]=1;
p=p->nextarc;
/取下一条出边
//while
l/for
06.【解答】
考查图的邻接矩阵的性质。
