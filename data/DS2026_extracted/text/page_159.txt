第5章树与二叉树
147
3.中序线索二叉树的遍历
中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先
找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。在中序线索二叉树中找结
点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访
问的结点（右子树中最左下的结点）为其后继。不含头结点的线索二叉树的遍历算法如下。
1）求中序线索二叉树的中序序列下的第一个结点：
ThreadNode *Firstnode(ThreadNode *p){
while（p->ltag==0）p=p->lchild;//最左下结点（不一定是叶结点）
return p;
2）求中序线索二叉树中结点p在中序序列下的后继：
ThreadNode*Nextnode(ThreadNode*p)(
if(p->rtag==0）return Firstnode(p->rchild）；//右子树中最左下结点
else return p->rchild;
l//若rtag==1则直接返回后继线索
请读者自行分析并完成求中序线索二叉树的最后一个结点和结点p前驱的运算?。
3）利用上面两个算法，可写出不含头结点的中序线索二叉树的中序遍历的算法：
void Inorder(ThreadNode *T){
for（ThreadNode*p=Firstnode（T);p!=NULL;p=Nextnode(p))
visit(p);
4.先序线索二叉树和后序线索二叉树
上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和建立后序线索二叉树的代码
类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。
以图5.19(a)的二叉树为例给出手工求先序线索二叉树的过程：先序序列为ABCDF，然后依
次判断每个结点的左右链域，若为空，则将其改造为线索。结点A，B均有左右孩子；结点C无左
孩子，将左链域指向前驱B，无右孩子，将右链域指向后继D：结点D无左孩子，将左链域指向
前驱C，无右孩子，将右链域指向后继F；结点F无左孩子，将左链域指向前驱D，无右孩子，
也无后继，所以置空，得到的先序线索二叉树如图5.19（b)所示。求后序线索二叉树的过程：后序
序列为CDBFA，结点C无左孩子，也无前驱，所以置空，无右孩子，将右链域指向后继D；结
点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B；结点F无左孩子，将左
链域指向前驱B，无右孩子，将右链域指向后继A，得到的后序线索二叉树如图5.19（c）所示。
小兔网盘
免费网课+无水印PDF
(a)一颗二叉树
(b)先序线索二叉树
(c)后序线索二叉树
图5.19先序线索二叉树和后序线索二叉树
如何在先序线索二叉树中找结点的后继？若有左孩子，则左孩子就是其后继；若无左孩子但
有右孩子，则右孩子就是其后继；若为叶结点，则右链域直接指示了结点的后继。
ltag和1child，此外调用函数改为求左了树的中序线索二叉树的最后个结点，即求中序线索二叉树中结点p的前驱。
