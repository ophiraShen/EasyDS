第5章树与二叉树
161
45.A
根据中序遍历的特点，v有左右子树，以v为根的子树的中序序列为：v的左子树的中序序列,v,v
的右子树的中序序列。又因为T的中序序列为“…,P,v,q…”，可知p属于v的左子树，q属于v的
右子树。在v的左子树的中序序列中：假设p有右孩子，则p的右孩子在中序序列中应在p之后，与
p是最后一个遍历结点矛盾，因此p不存在右孩子。在v的右子树的中序序列中：假设g存在左孩子，
则g的左孩子在中序序列中应在q之前，与q是第一个遍历结点矛盾，因此q不存在左孩子。
二、综合应用题
01.【解答】
二叉树的先序序列是NLR，后序序列是LRN。要使NLR=NRL（后序序列反序）成立，L
或R应为空，这样的二叉树每层只有一个结点，即二叉树的形态是其高度等于结点个数。以3个
结点a.b，c为例，其形态如下图所示。
02.【解答】
二叉树的先序序列是NLR，后序序列是LRN。要使NLR=LRN成立，L和R应均为空，所
以满足条件的二叉树只有一个根结点。
03.【解答】
采用层次遍历的算法，设置变量leve1记录当前结点所在的层数，设置变量1ast指向当
前层的最右结点，每次层次遍历出队时与last指针比较，若两者相等，则层数加1，并让1ast
指向下一层的最右结点，直到遍历完成。level的值即二叉树的高度。
算法实现如下：
int Btdepth(BiTree T){
//采用层次遍历的非递归方法求解二叉树的高度
if(!T)
return0;
/树空，高度为0
int front=-l,rear=-1;
int last=0,level=0;
//last指向当前层的最右结点
BiTree Q[MaxSize];
/设置队列Q，元素是二叉树结点指针且容量足够
Q[++rear]=T;
//将根结点入队
BiTree p;
while（front<rear){
/队不空，则循环
p=Q[++front];
/队列元素出队，即正在访问的结点
if(p->lchild)
Q[++rear]=p->lchild;//左孩子入队
if (p->rchild)
Q[++rear]=p->rchild;//右孩子入队
//处理该层的最右结点
if（front=
=last){
level++;
//层数增1
last=rear;
//last指向下层
return
level;
求某层的结点个数、每层的结点个数、树的最大宽度等，都可采用与此题类似的思想。当然，
