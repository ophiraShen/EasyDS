第3章栈、队列和数组
65
if(S.top==MaxSize-1)
//栈满，报错
return false;
S.data[++s.top]=x;
//指针先加1，再入栈
return true;
当栈不满时，top先加1，再入栈。若初始时将top定义为0，函数3和4应如何改写？
（4）出栈
bool Pop(SqStack &S,ElemType &x)(
if(s.top==-1)
//栈空，报错
return false;
x=S.data[s.top--];
//先出栈，指针再减1
return true;
（5）读栈顶元素
bool GetTop(SqStack S,ElemType &x){
if(s.top==-1)
//栈空，报错
return false;
x=S.data[s.top];
//x记录栈顶元素
return true;
仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。
注意
这里的top指的是栈顶元素。于是，入栈操作为s.data[++s.top］=x，出栈操作为
x=S.data[S.top--]。若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，则入栈操
作变为 S.data[S.top++]=x；出栈操作变为 x=S.data[--S.top]。相应的栈空、栈满条件也会发
生变化。请读者仔细体会其中的不同之处，做题时要灵活应变。
3.共享栈
利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分
别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图3.3所示。
0
MaxSize-l
栈数组
0号栈栈底
0号栈栈顶1号栈栈顶
1号栈栈底
图3.3两个顺序栈共享存储空间
两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为
再赋值，1号栈入栈时top1先减1再赋值；出栈时则刚好相反。
共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满
时才发生上溢。其存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。
3.1.3栈的链式存储结构
采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存
在栈满上溢的情况。通常采用单链表实现链栈，并规定所有操作都是在单链表的表头进行的。这
里规定链栈没有头结点，Lhead指向栈顶元素，如图3.4所示。
