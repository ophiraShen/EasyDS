第8章排
序
341
查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，
可以对直接插入排序算法做如下改进：因为是顺序存储的线性表，所以查找有序子表时可以用折
半查找来实现。确定待插入位置后，就可统一地向后移动元素。
折半插入排序算法的排序过程举例见本书配套课程，其代码如下：
void InsertSort（ElemType A[l,int n)(
int i，j,low,high,mid;
for（i=2;i<=n;i++）{
//依次将A[2]～A[n]插入前面的已排序序列
A[0]=A[i];
//将A[i]暂存到A[0]
low=1;high=i-1;
//设置折半查找的范围
while(low<=high）{
//折半查找（默认递增有序）
mid=(1ow+high)/2;
/取中间点
if（A[mid] >A[0]）high=mid-1；//查找左半子表
else low=mid+1;
//查找右半子表
for(j=i-1;j>=high+l;--j)
A[j+1]=A[j];
/统一后移元素，空出插入位置
A[high+1]=A[0];
//插入操作
命题追踪
直接插入排序和折半插入排序的比较（2012）
从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，时间复杂度约为O(nlog2n)，
该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数并未改变，
它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O(r²），但对于数据量不算
很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序算法。
折半插入排序仅适用于顺序存储的线性表。
8.2.3希尔排序
从前面的分析可知，直接插入排序算法的时间复杂度为O（n²)，但若待排序列为“正序”时，
其时间效率可提高至O（n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔
排序正是基于这两点分析对直接插入排序进行改进而得来的，也称缩小增量排序。
命题追踪希尔排序中各子序列采用的排序算法（2015）
希尔排序的基本思想是：先将待排序表分割成若干形如L[i,i+d,i+2d.·，i+kd]的“特殊”
子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个
表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。
命题追踪根据希尔排序的中间过程判断所采用的增量（2014、2018）
希尔排序的过程如下：先取一个小于n的增量d，把表中的全部记录分成d组，所有距离为d
的倍数的记录放在同一组，在各组内进行直接插入排序：然后取第二个增量d<d，重复上述过程，
直到所取到的d=1，即所有记录已放在同一组中，再进行直接插入排序，此时已经具有较好的局部
有序性，因此可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列。仍以8.2.1节的
关键字为例，假定第一趟取增量d=5，将该序列分成5个子序列，即图中第2行至第6行，分别对
直接插入排序，结果如第11行所示；最后对整个序列进行一趟直接插入排序，整个排序过程如
图8.2所示。
