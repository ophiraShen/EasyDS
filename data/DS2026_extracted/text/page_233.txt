第6章图
221
从上例不难看出，图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，这也说明
了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。
1.BFS算法的性能分析
无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均
需入队一次，在最坏的情况下，空间复杂度为O(IV)。
命题追踪基于邻接表存储的BFS的效率（2012）
遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结
构。采用邻接表存储时，每个顶点均需搜索（或入队）一次，时间复杂度为O(I)，在搜索每个顶
点的邻接点时，每条边至少访问一次，时间复杂度为O(E)，总的时间复杂度为O(V+E)。采用
邻接矩阵存储时，查找每个顶点的邻接点所需的时间为O(IV)，总时间复杂度为O(IV)。
2.BFS算法求解单源最短路径问题
若图G=（V,E)为非带权图，定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路
径中最少的边数；若从u到v没有通路，则d(u,v)=∞∞。
使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度
优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。
BFS算法求解单源最短路径问题的算法如下：
void BFS_MIN_Distance(Graph G,int u)(
lld[i]表示从u到i结点的最短路径
for（i=0;i<G.vexnum;++i)
d[i]=;
//初始化路径长度
visited[u]=TRUE;d[u]=0;
EnQueue(Q,u);
while(!isEmpty(Q)){
//BFS算法主过程
DeQueue(Q,u);
/队头元素u出队
for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w))
if(!visited[w]){
//w为u的尚未访问的邻接顶点
visited[w]=TRUE;
/设已访问标记
d[w]=d[u]+1;
/路径长度加1
EnQueue (Q, w) ;
/顶点w入队
3.广度优先生成树
在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树，如图6.12所示。
需要注意的是，同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的，
但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的。
图6.12图的广度优先生成树
