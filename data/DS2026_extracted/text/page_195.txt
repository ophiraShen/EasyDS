第5章
树与二叉树
183
算法代码如下：
typedef struct node
ElemType
data;
//数据域
struct node *fch,*nsib;
//孩子与兄弟域
)*Tree;
int Leaves(Tree t){
//计算以孩子兄弟表示法存储的森林的叶子数
if（t==NULL)
returno;
//树空返回0
if（t->fch==NULL)
//若结点无孩子，则该结点必是叶子
return
1+Leaves（t->nsib）；//返回叶结点和其兄弟子树中的叶结点数
else
//孩子子树和兄弟子树中叶子数之和
return
Leaves(t->fch)+Leaves(t->nsib);
05.【解答】
由孩子兄弟链表表示的树，求高度的算法思想：采用递归算法，若树为空，高度为零；否则，
高度为第一子女树高度加1和兄弟子树高度的大者。其非递归算法使用队列，逐层遍历树，取得
树的高度。算法代码如下：
int Height(CsTree bt)(
//递归求以孩子兄弟链表表示的树的深度
int hc,hs;
if(bt==NULL)
return
0;
else（//否则，高度取子女高度+1和兄弟子树高度的大者
hc=Height(bt->firstchild);
Ⅱ1第一子女树高
hs=Height(bt->nextsibling);
//兄弟树高
if(hc+1>hs)
return
hc+1;
else
return hs;
5.5树与二叉树的应用
5.5.1哈夫曼树和哈夫曼编码
1.哈夫曼树的定义
在介绍哈夫曼树之前，先介绍几个相关的概念：
在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。
从树的根到一个结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。
树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为
WPL=
i=1
式中，w是第i个叶结点所带的权值，1是该叶结点到根结点的路径长度。
在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，
也称最优二叉树。例如，图5.24中的3棵二叉树都有4个叶结点α,b,c,d，分别带权7，5，2,4，
它们的带权路径长度分别为
