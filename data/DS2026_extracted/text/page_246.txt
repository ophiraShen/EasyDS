234
2026年数据结构考研复习指导
根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是
连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。
在Kruskal算法中，最坏情况需要对|E条边各扫描一次。通常采用堆（见第7章）来存放边
的集合，每次选择最小权值的边需要O(logE)的时间：每次使用并查集来快速判断两个顶点是
否属于一个集合所需的时间为O(α(IV))，α(IV1)的增长极其缓慢，可视为常数。算法的总时间复
杂度为O(|Elog2|El)，不依赖于IV，因此Kruskal算法适合于边稀疏而J顶点较多的图。
6.4.2最短路径
命题追踪）最短路径的分析与举例以及相关的算法（2009、2023）
6.3节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个
顶点vo到图中其余任意一个顶点v，的一条路径所经过边上的权值之和，定义为该路径的带权路
径长度，把带权路径长度最短的那条路径（可能不止一条）称为最短路径。
求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他
顶点间的最短路径。带权有向图G的最短路径问题一般可分为两类：一是单源最短路径，即求
图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra（迪杰斯特拉）算法求解：二是
求每对顶点间的最短路径，可通过Floyd（弗洛伊德）算法来求解。
1.Dijkstra算法求单源最短路径问题
Dijkstra算法设置一个集合S记录已求得的最短路径的顶点，初始时把源点vo放入S，集合
S每并入一个新顶点V，都要修改源点vo到集合V-S中顶点当前的最短路径长度值（这里可能
不太好理解？没关系，继续往下看，相信会逐步理解）。
在构造的过程中还设置了三个辅助数组：
·final[]：标记各顶点是否已找到最短路径，即是否归入集合S。
·dist[]：记录从源点vo到其他各顶点当前的最短路径长度，它的初始值为：若从vo到
v有弧，则dist[i]为弧上的权值；否则置dist[i]为o。
·path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。在算法结束时，可
根据其值追溯得到源点v到顶点v的最短路径。
假设从顶点0出发，即vo=0，集合S最初只包含顶点O，邻接矩阵arcs表示带权有向
图，arcs[i][j]表示有向边<i>的权值，若不存在有向边<ij>，则arcs[i][j]为o。
Dijkstra算法的步骤如下（不考虑对path[]的操作）：
1）初始化：集合S初始为{0]，dist[]的初始值dist[i]=arcs[0][i],i=1,2,"，n-1。
的一条从vo出发的最短路径的终点，令S=SU{}。
3）修改从vo出发到集合V-S上任意一个顶点v可达的最短路径长度：若dist[j]+
arcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]。
4）重复2）～3）操作共n-1次，直到所有的顶点都包含在集合S中。
步骤3）也就是开头留下的疑问，每当一个顶点加入集合S后，可能需要修改源点vo到集
合V-S中可达顶点当前的最短路径长度，下面举一简单例子证明。如下图所示，源点为Vo，初
始时S={vo}，dist[1]=3，dist[2]=7，当将v并入集合S后，dist[2]需要更新为4。
