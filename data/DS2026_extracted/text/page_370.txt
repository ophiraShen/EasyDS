358
2026年数据结构考研复习指导
剩下1个，就不用再选。选择排序中的堆排序是历年统考考查的重点。
8.4.1简单选择排序
根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为
L[1..]，第i趟排序即从L[i.n]中选择关键字最小的元素与L（i）交换，每一趟排序可以确定
一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。
简单选择排序算法的过程较为简单，相关举例见本书配套课程，其代码如下：
void SelectSort(ElemType A[],intn)(
for（int i=0;i<n-l;i++）{
//一共进行n-1趟
int min=i;
/记录最小元素位置
for（int j=i+1;j<n;j++)
//在A[i.n-1]中选择最小的元素
if(A[j]<A[min]） min=j;
//更新最小元素位置
if（min!=i) swap(A[i],A[min]);
//封装的swap（）函数共移动元素3次
简单选择排序算法的性能分析如下：
空间效率：仅使用常数个辅助单元，所以空间效率为O（1)。
时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不
会超过3（n-1)次，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列
的初始状态无关，始终是n（n-1)/2次，因此时间复杂度始终是O（n²)。
稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与含有相同关
键字的元素的相对位置发生改变。例如，表L={2,2,1}，经过一趟排序后L={1,2,2}，最终排
序序列也是L={1，2，2}，显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳
定的排序算法。
适用性：简单选择排序适用于顺序存储和链式存储的线性表，以及关键字较少的情况。
8.4.2堆排序
堆的定义如下，n个关键字序列L[1..n]称为堆，当且仅当该序列满足：
①L(i)≥L(2i)且L(i)≥L(2i+1）或
②L(i)≤L(2i)且L(i)≤L(2i+1）(1≤i≤Ln/2」)
命题追踪堆的性质与特点（2020）
可以将堆视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆），大根堆的最大元素
存放在根结点，且其任意一个非根结点的值小于或等于其双亲结点值。满足条件②的堆称为小根
堆（小顶堆），小根堆的定义刚好相反，根结点是最小元素。图8.5所示为一个大根堆。
图8.5一个大根堆示意图
