56
2026年数据结构考研复习指导
xu-dxu-rd-
//将p结点从链表上摘下
q=p->pre;
/以下查找p结点的插入位置
(<-><)u
q=q->pre;
p->next=q->next;
if(q->next!=NULL)q->next->pre=p;/
/将p结点排在同频率的第一个
p->pre=q;
!d=xau<-b
return p;
//返回值为x的结点的指针
14.【解答】
1）算法的基本设计思想：
首先，遍历链表计算表长n，并找到链表的尾结点，将其与首结点相连，得到一个循环单链
表。然后，找到新链表的尾结点，它为原链表的第n-k个结点，令L指向新链表尾结点的下-
个结点，并将环断开，得到新链表。
2）本题代码如下：
LNode *Converse（LNode *L,int k){
int n=l;
//n用来保存链表的长度
LNode *p=L;
//p为工作指针
while(p->next!=NULL){
//计算链表的长度
p=p->next;
n++;
l/循环执行完后，p指向链表尾结点
p->next=L;
//将链表连成一个环
for（int i=1;i<=n-k;i++)
//寻找链表的第n-k个结点
p=p->next;
L=p->next;
/令L指向新链表尾结点的下一个结点
p->next=NULL;
//将环断开
return L;
3）本算法的时间复杂度为O(n)，空间复杂度为O(1)。
15.【解答】
1）算法的基本设计思想：
设置快慢两个指针分别为fast和slow最初都指向链表头head。slow每次走一步，即
快，若有环，则fast一定先进入环，而slow后进入环。两个指针都进入环后，经过若干操作
后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。
如下图所示，当slow刚进入环时，fast早已进入环。因为fast每次比slow多走一步
且fast与slow的距离小于环的长度，所以fast与slow相遇时，slow所走的距离不超过环
的长度。
head
fast
如下图所示，设头结点到环的入口点的距离为a，环的入口点沿着环的方向到相遇点的距离
为x，环长为r，相遇时fast绕过了n圈。
