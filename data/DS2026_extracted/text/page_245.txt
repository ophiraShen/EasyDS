第6章图
233
while((V-U)!=O){
若树中不含全部顶点
设(u,v)是使ueU与v∈(V-U)，且权值最小的边;
T=TU{（u,v）};
/边归入树
U=UU{v};
/顶点归入树
Prim算法的时间复杂度为O(IV)，不依赖于|E，因此它适用于求解边稠密的图的最小生成
树。虽然采用其他方法能改进Prim算法的时间复杂度，但增加了实现的复杂性。
2.Kruskal算法
与Prim算法从顶点开始扩展最小生成树不同，Kruskal算法是一种按权值的递增次序选择合
适的边来构造最小生成树的方法。
命题追踪Kruskal算法构造最小生成树的实例（2015、2018、2020）
通图T={V，，每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序，不断选取
当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上（使用并查集
判断这两个顶点是否属于同一棵集合树），则将此边加入T，否则舍弃此边而选择下一条权值
最小的边。以此类推，直至T中所有顶点都在一个连通分量上。
Kruskal算法的步骤如下：
假设G=(V,E)是连通图，其最小生成树T=(U,ET)。
初始化：U=V,Er=O。即每个顶点构成一棵独立的树，T此时是一个仅含IV个顶点的森林。
循环（重复直至T是一棵树）：按G的边的权值递增顺序依次从E-Er中选择一条边，
若这条边加入T后不构成回路，则将其加入Er，否则舍弃，直到Er中含有n-1条边。
V
V
V
图6.16Kruskal算法构造最小生成树的过程
Kruskal算法的简单实现如下：
void Kruskal(V,T)(
T=V;
//初始化树T，仅含顶点
numS=n;
//连通分量数
while(numS>1)(
//若连通分量数大于1
从E中取出权值最小的边（v，u）；
if（v和u属于T中不同的连通分量）（
T=TU((v,u）};
//将此边加入生成树中
numS--;
//连通分量数减1
