236
2026年数据结构考研复习指导
使用邻接矩阵表示时，时间复杂度为O(IV²)。使用带权的邻接表表示时，虽然修改dist[]
的时间可以减少，但因为在dist[]中选择最小分量的时间不变，所以时间复杂度仍为O（(IV)。
人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所
有顶点的最短路径一样复杂，时间复杂度也为O(IVF)。
注意，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与集合S
（已求得最短路径的顶点集，归入S内的顶点的最短路径不再变更）内某顶点（记为a）以负边
相连的顶点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于a
原先确定的最短路径长度，而此时a在Dijkstra算法下是无法更新的。例如，对于图6.18所示的
带权有向图，利用Dijkstra算法不一定能得到正确的结果。
(b)
图6.18边上带有负权值的有向带权图
2.Floyd算法求各顶点之间最短路径问题
求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于0的带权有向图，对
任意两个顶点v≠v，要求求出v与v之间的最短路径和最短路径长度。
Floyd算法的基本思想是：递推产生一个n阶方阵序列A(-)，,A,.…，A",…，A"-I)，其中
A[U]表示从顶点v到顶点v的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任
意两个顶点v和v，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它
们之间不存在有向边，则以作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶
点k（k=0，1,，n-1）作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少
了，则以此新路径代替原路径。算法描述如下：
定义一个n阶方阵序列A(-!),A.…,A("-1，其中，
A(-[i]U] = arcs[i]U]
[u.I 0 = []( +[(-) [)} =[(
式中，A[]U]是从顶点v,到v、中间顶点是v的最短路径的长度，A*[i]U]是从顶点v,到v、中
间顶点的序号不大于k的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从v
到v的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的A"-"[ilU]就是v到v的最
短路径长度，即方阵A"-1中就保存了任意一对顶点之间的最短路径长度。
图6.19所示为带权有向图G及其邻接矩阵。应用Floyd算法求所有顶点之间的最短路径长
度的过程如表6.3所示。算法执行过程的说明如下。
10
(a)有向图G
(b)G的邻接矩阵
图6.19带权有向图G及其邻接矩阵
