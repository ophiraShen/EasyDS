368
2026年数据结构考研复习指导
读者也可能会注意到，当只有一个结点时，显然是满足题意的，但我们不举一个结点的例子
是为了体现出排序树与大根堆的区别。
03.【解答】
在基于比较的排序算法中，插入排序、快速排序和归并排序只有在将元素全部排完序后，才
能得到前k个最小的元素序列，算法的效率不高。
冒泡排序、堆排序和简单选择排序可以，因为它们在每一趟中都可以确定一个最小的元素。
采用堆排序最合适，对于n个元素的序列，建立初始堆的时间不超过4n，取得第k个最小元素之
的时间为kn，当k≥5时，通过比较可以得出堆排序最优。
注意
求前k个最小元素的顺序排列可采用的排序算法有冒泡排序、堆排序和简单选择排序。
04.【解析】
1）除最后一个分支结点外，其余每个分支结点都有4个孩子，所以该树是完全4叉树。插
入元素65后，再删除堆顶元素的树形分别如下图1和图2所示。
0
88
90)
图1插入65后的树形
88
90
图2删除堆顶元素后的树形
2）父结点的编号为（k-1)/4，第i个孩子的编号为4xk+i，i=1,2,3,4。
3）与二叉堆类似，插入和删除操作都有向上、向下调整的过程，操作时间都与树的高度有
关。因此，插入和删除操作的时间复杂度都为O(logmn)，其中n为元素个数。
05.【解答】
算法的思想是：每趟在原始链表中摘下关键字最大的结点，把它插入结果链表的最前端，
在原始链表中摘下的关键字越来越小，在结果链表前端插入的关键字也越来越小，因此最后形
成的结果链表中的结点将按关键字非递减的顺序有序链接。
单链表的定义如第2章所述，假设它不带表头结点。
void selectSort(LinkedList& L)(
I对不带表头结点的单链表L执行简单选择排序
LinkNode *h=L,*p,*g,*r,*s;
L=NULL;
while(h!=NULL){
/持续扫描原链表
p=s=h;q=r=NULL;
//指针s和r记忆最大结点和其前驱；p为工作指针，q为其前驱
