第6章图
229
1）采用深度优先遍历。深度优先搜索总是尽可能“深”地搜索图，根据存储结构可知深度
的是，当存储结构固定时，生成树的树形也就固定了，比如不能先搜索(1，3)。
2）采用广度优先遍历。广度优先搜索总是尽可能“广”地搜索图，一层一层地向外扩展，
如图(c)所示。
02.【解答】
1）右图不能被二分，左图能被二分，染色情况如下图所示。
蓝色
红色
2）从任意一个结点开始，将其染成红色，并从该结点开始对整个图进行遍历，在遍历过程
中，若当前遍历的结点a有一条边指向b，则可能出现三种情况：①b未被染色，将它
染成与结点a不同的颜色，并且继续遍历与b相连的结点；②a与b的颜色相同，说明
该图不能被二分，直接返回：③a与b的颜色不同，跳过b点。
3）上述遍历无论是使用深度优先还是使用广度优先，时间复杂度都为O（n+m)），其中的n
和m分别是顶点数和边数。需要一个数组来存储各结点的颜色及是否已访问，空间复杂
度为 O(n)。
03.【解答】
一个无向图G是一棵树的条件是，G必须是无回路的连通图或有n-1条边的连通图。这里
采用后者作为判断条件。对连通的判定，可以用能否一次遍历全部顶点来实现。可以采用深度
优先搜索算法在遍历图的过程中统计可能访问到的顶点个数和边的条数，若一次遍历就能访问
到n个顶点和n-1条边，则可断定此图是一棵树。算法实现如下：
bool isTree(Graph& G){
for（i=1;i<=G.vexnum;i++)
visited[i]=FALSE;
//访问标记visited[]初始化
int Vnum=0,Enum=0;
//记录顶点数和边数
DFS(G,1,Vnum,Enum,visited);
if (Vnum==G.vexnum&&Enum==2*(G.vexnum-1))
return
true;
//符合树的条件
else
return
false;
//不符合树的条件
void DFS(Graph& G,int v,int& Vnum,int& Enum,int visited[]）{
//深度优先遍历图G，统计访问过的顶点数和边数，通过Vnum和Enum返回
visited[v]=TRUE;Vnum++;
//作访问标记，顶点计数
int w=FirstNeighbor(G,v);
/取v的第一个邻接顶点
while(w!=-1)(
//当邻接顶点存在
Enum++;
//边存在，边计数
if(!visited[w])
//当该邻接顶点未访问过
DFS(G,w,Vnum,Enum,visited);
w=NextNeighbor(G, v,w) ;
04.【解答】
