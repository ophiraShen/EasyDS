370
2026年数据结构考研复习指导
向下调整堆;
返回出队元素；
08.【解答】
1）算法思想。
【方法1】定义含10个元素的数组A，初始时元素值均为该数组类型能表示的最大数MAX。
forM中的每个元素s
if（s<A[9]）丢弃A[9]并将s按升序插入A;
当数据全部扫描完毕，数组A[0]～A[9]保存的就是最小的10个数。
【方法2】定义含10个元素的大根堆H，元素值均为该堆元素类型能表示的最大数MAX。
forM中的每个元素s
if（s<H的堆顶元素）删除堆顶元素并将s插入H;
当数据全部扫描完毕，堆H中保存的就是最小的10个数。
2）算法平均情况下的时间复杂度是O(n)，空间复杂度是O(1)。
8.5归并排序、基数排序和计数排序
8.5.1归并排序
命题追踪
二路归并操作的功能（2022）
归并排序与上述基于交换、选择等排序的思想不一样，归并的含义是将两个或两个以上的有
序表合并成一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表，每个
子表的长度为1，然后两两归并，得到「n/2|个长度为2或1的有序表；继续两两归并如此重
复，直到合并成一个长度为n的有序表为止，这种排序算法称为二路归并排序。
图8.9所示为二路归并排序的一个例子，经过三趟归并后合并成了有序序列。
初始关键字
[49]
[38]
[65]
[97]
[76][13]
[27]
L
L
L
第一趟归并后
[38
“49]
[65
97]
[13
76]
[27]
#
第二趟归并后
[38
49
65
971
[13
27
76]
第三趟归并后
[13
27
38
49
65
76
97]
图8.9
二路归并排序示例
命题追踪（算法题）归并排序思想的应用（2011）
Merge（）的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表
A[low..mid]、A[mid+1..high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B
中。每次从B的两段中取出一个记录进行关键字的比较，将较小者放入A中，当B中有一段的下
标超出其对应的表长（该段的所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A
中。算法如下：
ElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));//辅助数组 B
void Merge（ElemType A[],int low,int mid,int high)(
