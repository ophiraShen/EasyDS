220
2026年数据结构考研复习指导
visit(i);
/访问初始顶点1
visited[i]=TRUE;
/对主做已访问标记
EnQueue(Q,i);
/顶点i入队
while(!IsEmpty(Q))(
DeQueue(Q,v);
/队首顶点v出队
for(p=G.vertices[v] .firstarc;pip=p->nextarc)(//检测v的所有邻接点
w=p->adjvex;
if(visited[w]==FALSE){
visit(w);
//w为v的尚未访问的邻接点，访问w
visited[w]=TRUE;
//对w做已访问标记
//顶点w入队
EnQueue（Q,w);
用邻接矩阵实现广度优先搜索的算法如下：
void BFS(MGraph G,int i){
visit(i);
/访问初始顶点i
visited[i]=TRUE;
//对i做已访问标记
EnQueue(Q,i）;
//顶点i入队
while(!IsEmpty(Q)){
DeQueue(Q,v);
//队首顶点v出队
for（w=0;w<G.vexnum;w++)
/检测v的所有邻接点
if(visited[w]==FALSE&&G.edge[v][w]==l){
visit(w);
//w为v的尚未访问的邻接点，访问w
visited[w]=TRUE;
//对w做已访问标记
EnQueue(Q,w);
//顶点w入队
辅助数组visited[]标志顶点是否被访问过，其初始状态为FALSE。在图的遍历过程
中，一旦某个顶点v,被访问，就立即置visited[i]为TRUE，防止它被多次访问。
命题追踪广度优先遍历的过程（2013）
下面通过实例演示广度优先搜索的过程，给定图G如图6.11所示。假设从顶点a开始访
问，a先入队。此时队列非空，取出队头元素α，因为b，c与a邻接且未被访问过，于是依次访
问b，c，并将b，c依次入队。队列非空，取出队头元素b，依次访问与b邻接且未被访问的顶点
d,e，并将d，e入队（注意：a与b也邻接，但a已置访问标记，所以不再重复访问）。此时队列
非空，取出队头元素c，访问与c邻接且未被访问的顶点fg，并将fg入队。此时，取出队头元
素d，但与d邻接且未被访问的顶点为空，所以不进行任何操作。继续取出队头元素e，将h入
队列……·最终取出队头元素h后，队列为空，从而循环自动跳出。遍历结果为abcdefgh。
图6.11
一个无向图G
