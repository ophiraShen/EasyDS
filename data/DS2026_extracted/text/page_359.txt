第8章排
序
347
基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，
般很少直接考查，通常会重点考查快速排序算法的相关内容。
8.3.1冒泡排序
冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序
（A[i-1]>A[i])，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元
素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最
小的元素如气泡一般逐渐往上“漂浮”至“水面”（或关键字最大的元素如石头一般下沉至水底）。
下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或
最大元素）放到了序列的最终位置.…·这样最多做n-1趟冒泡就能把所有元素排好序。
图8.3所示为冒泡排序的过程，第一趟冒泡时：27<49，不交换；13<27，不交换；76>13，
交换：97>13，交换：65>13，交换；38>13，交换；49>13，交换。通过第一趟冒泡后，最小
元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排
序，如此重复，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。
49
13
B
3
3
13
3
38
49
27
27
27
27
27
65
38
49
38
38
38
38
97
65
38
49
49
49
49
76
97
65
49
49
49
49
13
76
97
65
65
65
65
27
27
76
97
76
76
76
49
49
49
76
97
97
97
初
第
第
第
第
第
最
始
二
三
一
五
终
状
趟
趟
趟
趟
趟
状
态
后
后
后
后
后
态
图8.3
冒泡排序示例
冒泡排序算法的代码如下：
void BubbleSort(ElemType A[],int n)(
for（inti=0;i<n-l;i++){
bool flag=false;
//表示本趟冒泡是否发生交换的标志
for(int j=n-1;j>i;j--)
//一趟冒泡过程
if(A[j-1]>A[j]){
//若为逆序
swap(A[j-1],A[j]);
//使用封装的swap函数交换?
flag=true;
if(flag==false)
return;
//本趟遍历后没有发生交换，说明表已经有序
冒泡排序的性能分析如下：
空间效率：仅使用了常数个辅助单元，因而空间复杂度为O（1)。
时间效率：当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换），
①本章有多处要两两交换元素，为使代码更简洁，使用函数swap（int&a，int&b），其代码如下：
int temp=a;a=b;b=temp;
