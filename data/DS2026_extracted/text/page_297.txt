第7章查
找
285
二叉排序树插入操作的算法描述如下：
int BST_Insert(BiTree &T,KeyType k){
if（T==NULL）{
//原树为空，新插入的记录为根结点
T=(BiTree)malloc(sizeof(BsTNode));
T->data=k;
T->lchild=T->rchild=NULL;
return1;
//返回1，插入成功
else if(k==T->data)
//树中存在相同关键字的结点，插入失败
return0;
else if(k<T->data)
/插入T的左子树
return BsT_Insert(T->lchild,k);
else
//插入T的右子树
return
BST_Insert(T->rchild,k);
4.二叉排序树的构造
命题追踪构造二叉排序树的过程（2020）
从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适位置。设插入的关键字序
列为{45,24,53,45,12.24}，则生成的二叉排序树如图7.6所示。
45
(a）空树
(b）插入45
（c）插入24
（d）插入53
(e）插入12
图7.6二叉排序树的构造过程
构造二叉排序树的算法描述如下：
void Creat_BsT(BiTree &T,KeyType str[],int n){
T=NULL;
//初始时T为空树
int i=0;
while(i<n){
//依次将每个关键字插入二叉排序树
BST_Insert(T,str[i]);
i++;
5.二叉排序树的删除
在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被
删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时
确保二叉排序树的性质不会丢失。删除操作的实现过程按3种情况来处理：
①若被删除结点：是叶结点，则直接删除，不会破坏二叉排序树的性质。
②若结点：只有一棵左子树或右子树，则让=的子树成为=父结点的子树，替代=的位置。
③若结点=有左、右两棵子树，则令=的直接后继（或直接前驱）替代=，然后从二叉排序
树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。
图7.7显示了在3种情况下分别删除结点45，78，78的过程。
