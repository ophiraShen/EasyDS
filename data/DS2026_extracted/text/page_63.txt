第2章
线
表
51
pre
本题代码如下：
LinkList Reverse_2(LinkList L){
xu-dxu-ddpo
p->next=NULL;
//处理第一个结点
while（r!=NULL){
/r为空，则说明p为最后一个结点
//依次继续遍历
p=r;
r=r->next;
p->next=pre;
/指针反转
L->next=p;
1//处理最后一个结点
returnL;
上述两个算法的时间复杂度为O(n)，空间复杂度为O(1)。
04.【解答】
因为链表是无序的，所以只能逐个结点进行检查，执行删除。
本题代码如下：
void RangeDelete(LinkList &L,int min,int max)(
LNode *pr=L,*p=L->link;
/lp是检测指针，pr是其前驱
while(p!=NULL)
if（p->data>min&&p->data<max）{//寻找到被删结点，删除
pr->link=p->link;
free(p);
p=pr->link;
elser
//否则继续寻找被删结点
!d=xd
p=p->link;
05.【解答】
两个单链表有公共结点，即两个链表从某一结点开始，它们的next都指向同一结点。每个单
链表结点只有一个next域，因此从第一个公共结点开始，之后的所有结点都是重合的，不可能再
出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像Y，而不可能像X。
本题极容易联想到“峦”方法：在第一个链表上顺序遍历每个结点，每遍历一个结点，在第
二个链表上顺序遍历所有结点，若找到两个相同的结点，则找到了它们的公共结点。显然，该算
法的时间复杂度为O(lenlxlen2)。
接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化：如何判断两个单链表有
没有公共结点？应注意到这样一个事实：若两个链表有一个公共结点，则该公共结点之后的所有
结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合
的部分时，只需要分别遍历两个链表到最后一个结点。若两个尾结点是一样的，则说明它们有公
共结点，否则两个链表没有公共结点。
然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达
尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个长k个结点，我们先在长
的链表上遍历k个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。两个链表
