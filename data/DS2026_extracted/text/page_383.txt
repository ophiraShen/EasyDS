第8章排序
371
//表A的两段A[low..mid]和A[mid+1...high]各自有序，将它们合并成一个有序表
int i,j,k;
for(k=low;k<=high;k++)
B[k]=A[k];
//将A中所有元素复制到B中
for（i=low,j=mid+1,k=i;i<=mid&&j<=high;k++）{
if(B[i]<=B[j])
//比较B的两个段中的元素
A[k]=B[i++];
/将较小值复制到A中
else
A[k]=B[j++];
while(i<=mid)
A[k++]=B[i++]；/若第一个表未检测完，复制
while(j<=high)
A[k++]=B[j++]；//若第二个表未检测完，复制
注意
在上面的代码中，最后两个while循环只有一个会执行。
有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行log2n趟。
递归形式的二路归并排序算法是基于分治的，其过程如下。
分解：将含有n个元素的待排序表分成各含n/2个元素的子表，采用二路归并排序算法对两
个子表递归地进行排序。
合并：合并两个已排序的子表得到排序结果。
void MergeSort(ElemType A[l,int low,int high)(
if(low<high）(
int mid=（low+high)/2;
//从中间划分两个子序列
MergeSort(A,low,mid);
/对左侧子序列进行递归排序
MergeSort(A,mid+l,high);
//对右侧子序列进行递归排序
Merge(A,low,mid,high);
//归并
命题追踪
归并排序和插入排序的对比（2017）
命题追踪
二路归并比较次数的分析（2024）
路归并排序算法的性能分析如下：
空间效率：Merge（）操作中，辅助空间刚好为n个单元，因此算法的空间复杂度为O(n)。
时间效率：每趟归并的时间复杂度为O（n)，共需进行「1og2n趟归并，因此算法的时间复杂
度为 O(nlog2n)。
稳定性：Merge（）操作不会改变相同关键字记录的相对次序，因此二路归并排序算法是一种
稳定的排序算法。
适用性：归并排序适用于顺序存储和链式存储的线性表。
注意
一般而言，对于N个元素进行k路归并排序时，排序的趟数m满足k"=N，从而m=logkN，又考虑到m
为整数，因此m=「logkV。这和前面的二路归并排序算法是一致的。
8.5.2基数排序
基数排序是一种很特别的排序算法，它不基于比较和移动进行排序，而基于关键字各位的大
