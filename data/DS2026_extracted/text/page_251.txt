第6章图
239
出
(b)
图6.22有向无环图的拓扑排序过程（续）
命题追踪
（算法题）拓扑排序的实现（2024）
拓扑排序算法（基于邻接表存储）的实现如下：
bool TopologicalSort(Graph G) (
InitStack(S);
//初始化栈，存储入度为0的顶点
inti;
for（i=0;i<G.vexnum;i++)
if(indegree[i]==0)
Push(S,i);
/将所有入度为0的顶点入栈
int count=0;
//计数，记录当前已经输出的顶点数
while(!IsEmpty(S)){
/栈不空，则存在入度为0的顶点
Pop(S,i）;
/栈顶元素出栈
print[count++]=i;
//输出顶点
for(p=G.vertices[i].firstarc;p;p=p-
->nextarc){
/将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
v=p->adjvex;
if(!(--indegree[v]))
Push(S,v);
1/入度为0，则入栈
if(count<G.vexnum)
return
false;
/排序失败，有向图中有回路
else
return
true;
//拓扑排序成功
命题追踪
不同存储方式下的拓扑排序的效率（2016）
因为输出每个顶点的同时还要删除以它为起点的边，所以采用邻接表存储时拓扑排序的时
间复杂度为O(IV+[E)，采用邻接矩阵存储时拓扑排序的时间复杂度为O(IV)。
命题追踪DFS实现拓扑排序的思想（2020）
此外，利用上一节的深度优先遍历也可以实现拓扑排序，下面简单描述其思路，具体代码
见本节后的习题。对于有向无环图G中的任意结点uuV，它们之间的关系必然是下列三种之一：
1）若u是v的祖先，则在调用DFS访问u之前，必然已对v进行了DFS访问，即v的DFS
结束时间先于u的DFS结束时间。从而可考虑在DFS函数中设置一个时间标记，在
DFS调用结束时，对各顶点计时。因此，祖先的结束时间必然大于子孙的结束时间。
2）若u是v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。
3）若u和v没有路径关系，则u和v在拓扑序列的关系任意。
于是，按结束时间从大到小排列，就可以得到一个拓扑排序序列。
