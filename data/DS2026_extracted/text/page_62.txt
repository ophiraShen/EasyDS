50
2026年数据结构考研复习指导
minpre
pre
本题代码如下：
LinkList Delete Min(LinkList &L){
LNode *pre=L,*p=pre->next;
/lp为工作指针，pre指向其前驱
LNode*minpre=pre，*minp=p；l/保存最小值结点及其前驱
while(p!=NULL){
if(p->data<minp->data){
!d=dutu
//找到比之前找到的最小值结点更小的结点
minpre=pre;
pre=p;
1/继续扫描下一个结点
p=p->next;
minpre->next=minp->next;
//删除最小值结点
free(minp);
returnL;
算法需要从头至尾扫描链表，时间复杂度为O(n)，空间复杂度为O(1)。
若本题改为不带头结点的单链表，则实现上会有所不同，请读者自行思考。
03.【解答】
解法1：将头结点摘下，然后从第一结点开始，依次插入到头结点的后面（头插法建立单链
表），直到最后一个结点为止，这样就实现了链表的逆置，如下图所示。
头插法
本题代码如下：
LinkList Reverse l(LinkList L){
LNode *p,*r;
/lp为工作指针，r为p的后继，以防断链
p=L->next;
1/从第一个元素结点开始
L->next=NULL;
l/先将头结点L的next域置为NULL
while(p!=NULL){
//依次将元素结点摘下
r=p->next;
l/暂存p的后继
p->next=L->next;
/将p结点插入到头结点之后
L->next=p;
p=r;
returnL;
解法2：大部分辅导书都只介绍解法1，这对读者的理解和思维是不利的。为了将调整指针
这个复杂的过程分析清楚，我们借助图形来进行直观的分析。
结点的指针都已调整完毕，它们的next都指向其原前驱结点。现在令*p结点的next域指向
*pre结点，注意到一旦调整指针的指向，*p的后继结点的链就会断开，为此需要用r来指向原
*p的后继结点。处理时需要注意两点：一是在处理第一个结点时，应将其next域置为NULL，
而不是指向头结点（因为它将作为新表的尾结点）：二是在处理完最后一个结点后，需要将头结
点的指针指向它。
