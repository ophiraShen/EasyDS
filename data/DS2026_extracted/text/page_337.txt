第7章查
找
325
中第i次探测得到的散列地址，假设得到的另一个散列地址H仍然发生冲突，只得继续求下一个
地址H，以此类推，直到H不发生冲突为止，则H为关键字在表中的地址。
1．开放定址法
所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非
同义词表项开放。其数学递推公式为
H,=(H(key) +d)% m
式中，H(key)为散列函数；i=1,2,··，k（k≤m-1)；m表示散列表表长；d为增量序列。
取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法：
命题追踪?堆积现象导致的结果（2014）
1）线性探测法，也称线性探测再散列法。d=1,2,…，m-1。它的特点是：冲突发生时，顺
序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址是表首地址0），直
到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。
线性探测法可能使第i个散列地址的同义词存入第1+1个散列地址，这样本应存入第i+
1个散列地址的元素就争夺第1+2个散列地址的元素的地址从而造成大量元素在相
邻的散列地址上聚集（或堆积）起来，大大降低了查找效率。
2）平方探测法，也称二次探测法。d=1²,-1²,2²,-2²,.…,k²,-k²，其中k≤m/2，散列表长度
m必须是一个可以表示成4k+3的素数。
平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能
探测到散列表上的所有单元，但至少能探测到一半单元。
3）双散列法。d=ixHash2(key)。需要使用两个散列函数，当通过第一个散列函数H(key)得
到的地址发生冲突时，则利用第二个散列函数Hashz（key)计算该关键字的地址增量。它的
具体散列函数形式如下：
H,=(H(key) + ixHash2(key)) % m
初始探测位置H=H(key)%m。i是冲突的次数，初始为0。
4）伪随机序列法。d=伪随机数序列。
命题追踪
散列表中删除部分元素后的查找效率分析（2023）
注意
采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的查找路径，删
除元素时可以做一个删除标记，进行逻辑删除，具体举例见本书配套课程。但这样做的副作用是：执行
多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。
2.拉链法（链接法，chaining）
显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，
可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地
址为i的同义词链表的头指针存放在散列表的第i个单元中，因而查找、插入和删除操作主要在
同义词链中进行。拉链法适用于经常进行插入和删除的情况。
用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可尝试计算本例的平均ASL）。
